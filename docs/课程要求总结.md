# ECE 391 MP3 课程要求总结

## 课程基本信息

**课程名称**: ECE 391 - Computer Systems Engineering
**学校**: University of Illinois at Urbana-Champaign (UIUC)
**项目**: Machine Problem 3 (MP3) - Operating System Development
**版本**: 2017年秋季学期
**团队**: 小组项目（2-3人）
**总计**: 5个 Checkpoints

---

## Checkpoint 时间表 (2017年版本)

| Checkpoint   | 截止日期                       | 时间      |
|--------------|----------------------------|---------|
| Checkpoint 1 | Monday, October 22, 2017   | 6:00 PM |
| Checkpoint 2 | Monday, October 29, 2017   | 6:00 PM |
| Checkpoint 3 | Monday, November 12, 2017  | 6:00 PM |
| Checkpoint 4 | Tuesday, November 27, 2017 | 6:00 PM |
| Checkpoint 5 | Monday, December 10, 2017  | 6:00 PM |

---

## Checkpoint 1: 处理器初始化与基础架构

### 截止日期

2017年10月22日（周一）下午6点

### 核心目标

建立操作系统的基础框架，实现从引导到保护模式的转换，并建立内存保护机制。

### 实现要求

#### 1. 引导与保护模式

- **文件**: `boot.S`
- **要求**:
    - 使用 GRUB Multiboot 规范引导内核
    - 从实模式切换到32位保护模式
    - 设置初始堆栈指针
    - 跳转到C代码入口点

#### 2. 中断描述符表 (IDT)

- **文件**: `idt_init.c`, `exception_handler.c`, `interrupt_handler.S`
- **要求**:
    - 初始化256个IDT表项
    - 实现20个x86异常处理程序（0-19，跳过15）:
        - 0: Divide Error (除零错误)
        - 1: Debug Exception
        - 2: NMI Interrupt
        - 3: Breakpoint
        - 4: Overflow
        - 5: BOUND Range Exceeded
        - 6: Invalid Opcode (无效操作码)
        - 7: Device Not Available
        - 8: Double Fault
        - 9: Coprocessor Segment Overrun
        - 10: Invalid TSS
        - 11: Segment Not Present
        - 12: Stack Segment Fault
        - 13: General Protection Fault (通用保护错误)
        - 14: Page Fault (页错误)
        - 16: Floating-Point Error
        - 17: Alignment Check
        - 18: Machine Check
        - 19: SIMD Floating-Point Exception
    - 设置异常使用陷阱门 (Trap Gate)
    - 设置中断使用中断门 (Interrupt Gate)
    - 为系统调用保留 0x80 号中断入口 (DPL=3)

#### 3. 分页系统

- **文件**: `paging.c`, `paging.h`
- **要求**:
    - 创建页目录 (Page Directory，1024个条目)
    - 创建页表 (Page Table，1024个条目)
    - 内存映射方案:
        - **0-4MB**: 使用4KB页表映射
            - 特别地，0xB8000映射到视频内存（VGA文本模式）
            - 其余部分标记为"不存在"
        - **4-8MB**: 使用4MB大页直接映射到内核
            - 起始地址: 0x400000
            - Supervisor级别 (us=0)
            - 可读写 (rw=1)
        - **8MB以上**: 标记为"不存在"（为用户程序预留）
    - 启用CR0寄存器的分页位
    - 加载CR3寄存器指向页目录

#### 4. GDT/LDT/TSS

- **文件**: `x86_desc.h`, `x86_desc.S`
- **要求**:
    - Global Descriptor Table (GDT) 已提供
    - Local Descriptor Table (LDT) 已提供
    - Task State Segment (TSS) 初始化

### 测试要求

必须通过以下测试（在 `tests.c` 中）：

1. **idt_test()**:
    - 验证异常、中断、系统调用的IDT表项正确设置
    - 检查偏移地址不为NULL

2. **paging_valid_test()**:
    - 检查页目录第0项（页表）的present位
    - 检查页目录第1项（内核4MB页）的present位
    - 验证页表基址正确
    - 验证内核基址 = 0x400000

3. **paging_dereference_test()**:
    - 解引用视频内存地址 (0xB8000)
    - 解引用内核起始地址 (0x400000)
    - 解引用内核中间地址
    - 解引用内核结束地址 (0x7FFFFC)
    - 以上均不应导致Page Fault

4. **exception_test()**:
    - 触发除零异常
    - 触发Page Fault（访问NULL指针）
    - 验证异常处理程序正确执行

### 交付物

- 能够通过GRUB引导的内核
- 完整的IDT初始化代码
- 工作的分页系统
- 所有测试通过
- 代码注释和文档

---

## Checkpoint 2: 设备驱动程序

### 截止日期

2017年10月29日（周一）下午6点

### 核心目标

实现硬件设备驱动，使操作系统能够与键盘、RTC和终端交互。

### 实现要求

#### 1. 8259 PIC (可编程中断控制器)

- **文件**: `i8259.c`, `i8259.h`
- **要求**:
    - 初始化主从PIC芯片
        - 主PIC端口: 0x20 (命令), 0x21 (数据)
        - 从PIC端口: 0xA0 (命令), 0xA1 (数据)
    - 实现中断屏蔽/使能函数:
        - `enable_irq(irq_num)`: 使能特定IRQ
        - `disable_irq(irq_num)`: 禁用特定IRQ
    - 实现EOI (End of Interrupt) 发送:
        - `send_eoi(irq_num)`: 发送中断结束信号
    - 配置级联关系（IRQ 2连接从PIC）

#### 2. RTC驱动

- **文件**: `rtc_handler.c`, `rtc_handler.h`
- **要求**:
    - 设置RTC中断频率（2Hz - 8192Hz）
    - 使用端口0x70和0x71访问CMOS寄存器
    - 在IDT中设置RTC中断处理程序（IRQ 8，IDT入口0x28）
    - 实现RTC设备驱动函数表:
        - `rtc_open()`: 初始化RTC为2Hz
        - `rtc_read()`: 阻塞直到RTC中断发生后返回
        - `rtc_write()`: 改变RTC频率
        - `rtc_close()`: 关闭RTC
    - 处理RTC中断:
        - 读取寄存器C以清除中断
        - 发送EOI
    - **重要**: `rtc_open` 必须重置频率为2Hz
    - **重要**: `rtc_read` 必须等待RTC中断发生才返回

#### 3. 键盘驱动

- **文件**: `keyboard.c`, `keyboard.h`
- **要求**:
    - 在IDT中设置键盘中断处理程序（IRQ 1，IDT入口0x21）
    - 从端口0x60读取扫描码
    - 实现扫描码到ASCII的转换:
        - 支持大小写字母、数字、符号
        - 处理特殊键: Enter, Backspace, Tab, Space
        - 支持Shift键（左右Shift）
        - 支持Caps Lock（大小写锁定）
        - 支持Ctrl和Alt修饰键
    - 维护128字节键盘缓冲区
    - 缓冲区管理:
        - 遇到回车时设置缓冲区完成标志
        - 缓冲区满时忽略新输入
    - 键盘回显（在屏幕上显示按下的字符）
    - 发送EOI给PIC

#### 4. 终端驱动

- **文件**: `terminal.c`, `terminal.h`
- **要求**:
    - 实现终端设备驱动函数表:
        - `terminal_open()`: 打开终端
        - `terminal_read(fd, buf, nbytes)`: 从键盘读取一行
            - 最多读取128字节（包括换行符）
            - 阻塞直到用户按下Enter
            - 返回实际读取的字节数
            - **重要**: 128字符限制包括换行符
            - **重要**: 必须处理缓冲区溢出情况
        - `terminal_write(fd, buf, nbytes)`: 向屏幕写入
            - 写入指定数量的字符
            - 返回实际写入的字节数
            - **重要**: 不应该在null字节处停止
        - `terminal_close()`: 关闭终端
    - 行缓冲模式（等待换行符）
    - 与键盘驱动协作获取输入

### 测试要求

必须通过以下测试：

1. **terminal_test()**:
    - 测试终端打开
    - 测试不同长度字符串的读写
    - 验证terminal_read返回正确字节数
    - 验证terminal_write返回正确字节数
    - 测试3次读写循环

2. **rtc_test()**:
    - 测试RTC中断是否触发
    - 测试频率变化（2Hz, 4Hz, 8Hz等）
    - 验证rtc_read阻塞行为

3. **keyboard_test()**:
    - 测试按键输入
    - 测试Shift、Caps Lock
    - 测试特殊字符
    - 验证缓冲区管理

### 交付物

- 完整的RTC驱动
- 完整的键盘驱动
- 完整的终端驱动
- 8259 PIC初始化和管理代码
- 所有测试通过

---

## Checkpoint 3: 文件系统

### 截止日期

2017年11月12日（周一）下午6点

### 核心目标

实现一个只读文件系统，支持文件和目录的读取操作。

### 实现要求

#### 1. 文件系统结构

- **文件**: `file_system.c`, `file_system.h`
- **文件系统镜像**: `filesys_img` (在启动时作为模块加载)

#### 2. 文件系统布局

```
+---------------------------+
|      Boot Block           |  ← 4KB，包含目录项和统计信息
|  - dir_count (63最大)     |
|  - inode_count            |
|  - data_block_count       |
|  - directory entries[63]  |
+---------------------------+
|      Inode 0              |  ← 每个inode 4KB
|      Inode 1              |     描述文件长度和数据块索引
|      ...                  |
|      Inode N              |
+---------------------------+
|   Data Block 0            |  ← 每块4KB
|   Data Block 1            |     存储实际文件数据
|   ...                     |
|   Data Block M            |
+---------------------------+
```

#### 3. 数据结构定义

**目录项 (Directory Entry)** - 64字节:

```c
typedef struct dentry {
    char filename[32];      // 文件名（不一定null结尾）
    uint32_t filetype;      // 0=RTC设备, 1=目录, 2=普通文件
    uint32_t inode_num;     // inode编号（仅文件类型使用）
    uint8_t reserved[24];   // 保留字节
} dentry_t;
```

**启动块 (Boot Block)**:

```c
typedef struct boot_block {
    uint32_t dir_count;     // 目录项数量
    uint32_t inode_count;   // inode数量
    uint32_t data_count;    // 数据块数量
    uint8_t reserved[52];   // 保留字节
    dentry_t direntries[63]; // 目录项数组
} boot_block_t;
```

**Inode (索引节点)** - 4KB:

```c
typedef struct inode {
    uint32_t length;           // 文件长度（字节）
    uint32_t data_block_num[1023]; // 数据块索引数组
} inode_t;
```

#### 4. 文件系统函数接口

**底层函数**:

- `file_system_init(uint32_t* fs_start)`: 初始化文件系统
    - 保存boot block指针
    - 计算inode起始地址
    - 计算数据块起始地址

- `read_dentry_by_name(const uint8_t* fname, dentry_t* dentry)`: 通过文件名读取目录项
    - 在boot block中搜索文件名
    - 复制匹配的目录项到dentry
    - 成功返回0，失败返回-1

- `read_dentry_by_index(uint32_t index, dentry_t* dentry)`: 通过索引读取目录项
    - 验证索引有效性
    - 复制目录项到dentry
    - 成功返回0，失败返回-1

- `read_data(uint32_t inode, uint32_t offset, uint8_t* buf, uint32_t length)`: 读取文件数据
    - 验证inode号有效性
    - 从指定偏移量读取数据
    - 处理跨数据块读取
    - 返回实际读取的字节数

**文件操作函数表**:

```c
// 普通文件操作
int32_t file_open(const uint8_t* filename);
int32_t file_close(int32_t fd);
int32_t file_read(int32_t fd, void* buf, int32_t nbytes);
int32_t file_write(int32_t fd, const void* buf, int32_t nbytes); // 返回-1（只读）

// 目录操作
int32_t dir_open(const uint8_t* filename);
int32_t dir_close(int32_t fd);
int32_t dir_read(int32_t fd, void* buf, int32_t nbytes);
  // 每次调用读取一个文件名（最多32字节）
  // 遍历所有目录项
  // 末尾返回0
int32_t dir_write(int32_t fd, const void* buf, int32_t nbytes); // 返回-1（只读）
```

#### 5. 文件系统内容

文件系统镜像包含以下文件：

- `frame0.txt` - 鱼动画第一帧
- `frame1.txt` - 鱼动画第二帧
- `cat` - cat程序
- `counter` - 计数器程序
- `fish` - 鱼动画程序
- `grep` - grep程序
- `hello` - Hello World程序
- `ls` - 列出文件程序
- `shell` - Shell程序
- `testprint` - 测试打印程序
- 其他测试程序

### 测试要求

必须通过以下测试：

1. **file_system_initial_test()**:
    - 验证boot block指针非NULL
    - 验证dir_number初始化为0

2. **file_system_dir_read_test()**:
    - 打开根目录
    - 遍历所有文件
    - 打印文件名、类型、大小
    - 验证返回值正确

3. **file_system_file_read_test1-4()**:
    - 测试读取小文件（如frame0.txt）
    - 测试读取大文件（超过一个数据块）
    - 测试读取可执行文件
    - 验证数据正确性
    - 测试边界条件

4. **file_system_write_test()**:
    - 尝试写入应返回-1

### 交付物

- 完整的文件系统读取实现
- 所有文件和目录操作函数
- 测试通过
- 能够列出文件系统中的所有文件
- 能够正确读取文本和二进制文件

---

## Checkpoint 4: 系统调用与进程管理

### 截止日期

2017年11月27日（周二）下午6点

### 核心目标

实现系统调用接口和进程管理，使用户程序能够运行。

### 实现要求

#### 1. 系统调用机制

- **文件**: `syscall_handler.c`, `syscall.S`, `syscall.h`
- **中断号**: 0x80
- **调用约定**:
    - EAX: 系统调用号
    - EBX: 第一个参数
    - ECX: 第二个参数
    - EDX: 第三个参数
    - 返回值: EAX

#### 2. 进程控制块 (PCB)

- **文件**: `syscall_handler.h`
- **结构定义**:

```c
typedef struct pcb {
    uint32_t pid;                 // 进程ID (0-5)
    uint32_t parent_pid;          // 父进程ID
    uint32_t esp;                 // 保存的栈指针
    uint32_t ebp;                 // 保存的基址指针
    uint32_t eip;                 // 程序入口点
    file_descriptor_t fd_table[8]; // 文件描述符表
    uint8_t args[128];            // 命令行参数
    uint32_t active;              // 进程是否活跃
} pcb_t;
```

**文件描述符结构**:

```c
typedef struct file_descriptor {
    file_operations_t* fops;  // 函数操作表指针
    uint32_t inode;           // inode号（文件）
    uint32_t file_position;   // 文件读取位置
    uint32_t flags;           // 使用标志（0=空闲, 1=使用中）
} file_descriptor_t;
```

**函数操作表**:

```c
typedef struct file_operations {
    int32_t (*open)(const uint8_t* filename);
    int32_t (*close)(int32_t fd);
    int32_t (*read)(int32_t fd, void* buf, int32_t nbytes);
    int32_t (*write)(int32_t fd, const void* buf, int32_t nbytes);
} file_operations_t;
```

#### 3. 进程内存布局

**用户空间 (虚拟地址)**:

```
128MB (0x08000000) ┌─────────────────┐
                   │   用户栈        │ ← 向下增长
                   │   (4MB)         │
                   ├─────────────────┤
                   │                 │
                   │   堆/数据       │
                   │                 │
                   ├─────────────────┤
132MB (0x08048000) │   程序代码      │ ← 入口点
                   │   (.text)       │
128MB (0x08000000) └─────────────────┘
```

**物理内存分配**:

- 进程0: 8MB (0x800000)
- 进程1: 12MB (0xC00000)
- 进程2: 16MB (0x1000000)
- 进程3: 20MB (0x1400000)
- 进程4: 24MB (0x1800000)
- 进程5: 28MB (0x1C00000)

**内核栈**:

- 每个进程8KB内核栈
- PCB位于内核栈底部
- 内核栈位于8MB内核空间顶部

#### 4. 必须实现的8个系统调用

**1. halt (系统调用号1)**

```c
int32_t halt(uint8_t status);
```

- 终止当前进程
- 关闭所有打开的文件描述符（除了stdin/stdout）
- 恢复父进程的页表映射
- 恢复父进程的TSS
- 跳转回父进程（从execute返回）
- 返回值：256表示异常终止，否则返回status

**2. execute (系统调用号2)**

```c
int32_t execute(const uint8_t* command);
```

执行流程：

1. 解析命令（程序名 + 参数）
2. 检查文件是否存在
3. 检查可执行文件魔数：`0x7f 0x45 0x4c 0x46` ("\x7fELF")
4. 分配进程ID（0-5）
5. 设置分页：128MB虚拟 → 对应物理地址
6. 加载程序到物理内存：
    - 从ELF文件字节24-27读取入口点地址
    - 将整个程序复制到物理内存
7. 创建PCB：
    - 分配8KB内核栈
    - 初始化文件描述符表
        - fd[0] = stdin (terminal)
        - fd[1] = stdout (terminal)
        - fd[2-7] = 空闲
    - 保存参数
    - 记录父进程PID
8. 设置用户栈：
    - 用户栈顶 = 128MB + 4MB = 132MB (0x8400000)
9. 使用IRET切换到用户态：
    - 压入USER_DS（用户数据段）
    - 压入用户ESP
    - 压入EFLAGS（IF=1，IOPL=0）
    - 压入USER_CS（用户代码段）
    - 压入EIP（程序入口点）
    - 执行IRET
10. 子进程运行...
11. 子进程调用halt返回时，返回到此处
12. 返回halt的status

**3. read (系统调用号3)**

```c
int32_t read(int32_t fd, void* buf, int32_t nbytes);
```

- 检查fd有效性（0-7）
- 检查文件描述符是否打开
- 调用对应的read函数：
    - fd=0: terminal_read
    - 文件: file_read
    - 目录: dir_read
    - RTC: rtc_read
- 更新file_position
- 返回读取的字节数，失败返回-1

**4. write (系统调用号4)**

```c
int32_t write(int32_t fd, const void* buf, int32_t nbytes);
```

- 检查fd有效性（0-7）
- 检查文件描述符是否打开
- 调用对应的write函数：
    - fd=1: terminal_write
    - 其他: 返回-1（只读文件系统）
- 返回写入的字节数，失败返回-1

**5. open (系统调用号5)**

```c
int32_t open(const uint8_t* filename);
```

- 在当前PCB的文件描述符表中找到空闲项
- 根据文件名/设备名确定类型：
    - "stdin" → terminal (只读)
    - "stdout" → terminal (只写)
    - "rtc" → RTC设备
    - 其他 → 查找文件系统
- 初始化文件描述符：
    - 设置函数操作表指针
    - 设置inode（文件）
    - 设置file_position = 0
    - 设置flags = 1（使用中）
- 调用对应的open函数
- 返回文件描述符（2-7），失败返回-1

**6. close (系统调用号6)**

```c
int32_t close(int32_t fd);
```

- 检查fd有效性（2-7，不能关闭stdin/stdout）
- 检查文件描述符是否打开
- 调用对应的close函数
- 清空文件描述符：
    - flags = 0
    - file_position = 0
    - fops = NULL
- 成功返回0，失败返回-1

**7. getargs (系统调用号7)**

```c
int32_t getargs(uint8_t* buf, int32_t nbytes);
```

- 将PCB中保存的命令行参数复制到buf
- 检查是否有参数
- 检查缓冲区大小
- 返回0成功，-1失败

**8. vidmap (系统调用号8)**

```c
int32_t vidmap(uint8_t** screen_start);
```

- 将视频内存映射到用户空间
- 虚拟地址：132MB + 4MB = 136MB (0x8800000)
- 物理地址：0xB8000
- 使用4KB页表映射
- 用户权限 (us=1)
- 返回虚拟地址给用户程序
- 返回0成功，-1失败

#### 5. 用户程序加载器

**ELF文件格式**：

- 魔数（字节0-3）：0x7f, 'E', 'L', 'F'
- 入口点地址（字节24-27）：小端序32位地址

**加载步骤**：

1. 读取文件到临时缓冲区
2. 验证魔数
3. 提取入口点地址
4. 复制到进程的物理内存（128MB虚拟地址对应的物理地址）

#### 6. 上下文切换

**进入系统调用**（用户态→内核态）：

1. 用户程序执行 `int 0x80`
2. CPU自动：
    - 切换到内核栈（TSS中的ESP0）
    - 压入SS, ESP, EFLAGS, CS, EIP
3. 跳转到系统调用处理程序
4. 保存所有寄存器
5. 调用对应的系统调用函数

**返回用户态**（内核态→用户态）：

1. 恢复所有寄存器
2. 执行IRET
3. CPU自动：
    - 弹出EIP, CS, EFLAGS, ESP, SS
    - 切换回用户栈
    - 继续执行用户程序

### 测试要求

必须通过以下测试：

1. **shell_test()**:
    - 执行shell程序
    - 能够接收命令
    - 能够运行其他程序

2. **terminal_read_write_test()**:
    - 使用系统调用读写终端
    - 验证open/close影响fd_table
    - 验证读写返回值正确

3. **open_close_test()**:
    - 测试打开stdin, stdout
    - 测试打开文件（hello, frame0.txt）
    - 验证fd_table的flags字段
    - 测试关闭文件

4. **sys_read_test1()**:
    - 系统调用读取文件
    - 系统调用读取目录
    - 验证返回值和数据正确性

5. **sys_rtc_test()**:
    - 通过系统调用使用RTC
    - 测试open/read/write/close

### 必须能够运行的程序

1. **shell** - 命令行解释器
    - 接收用户输入
    - 解析命令
    - 执行程序
    - 等待程序结束

2. **ls** - 列出文件
    - 读取目录
    - 显示所有文件名

3. **cat** - 显示文件内容
    - 接收文件名参数（getargs）
    - 读取并显示文件

4. **grep** - 搜索文件
    - 接收搜索词和文件名
    - 显示匹配行

5. **hello** - Hello World
    - 简单的打印程序

6. **testprint** - 测试程序
    - 验证基本功能

### 交付物

- 完整的8个系统调用实现
- PCB和进程管理代码
- 程序加载器
- 能够运行所有提供的用户程序
- Shell能够正常工作
- 所有测试通过

---

## Checkpoint 5: 多终端与调度器

### 截止日期

2017年12月10日（周一）下午6点

### 核心目标

实现多个虚拟终端和进程调度，支持多任务。

### 实现要求

#### 1. 多终端支持

- **文件**: `terminal.c`, `terminal.h`
- **要求**:
    - 支持3个独立的虚拟终端
    - 每个终端维护独立状态：
      ```c
      typedef struct terminal {
          char kb_buffer[128];      // 键盘缓冲区
          int buffer_index;         // 缓冲区位置
          uint32_t screen_x;        // 光标X坐标
          uint32_t screen_y;        // 光标Y坐标
          uint8_t video_mem[4096];  // 视频内存备份（4KB）
          uint32_t active_pid;      // 当前运行的进程PID
          uint32_t read_flag;       // 终端读取完成标志
      } terminal_t;
      ```
    - 全局数组：`terminal_t terminals[3]`
    - 全局变量：`int current_terminal` (0-2)

#### 2. 终端切换

- **快捷键**:
    - Alt + F1 → 终端0
    - Alt + F2 → 终端1
    - Alt + F3 → 终端2
- **实现**: 在键盘中断处理程序中检测
- **切换流程**:
  ```c
  switch_terminal(int old_term, int new_term) {
      // 1. 保存旧终端视频内存
      memcpy(terminals[old_term].video_mem, VIDEO_MEM, 4096);

      // 2. 保存旧终端光标位置
      terminals[old_term].screen_x = screen_x;
      terminals[old_term].screen_y = screen_y;

      // 3. 恢复新终端视频内存
      memcpy(VIDEO_MEM, terminals[new_term].video_mem, 4096);

      // 4. 恢复新终端光标位置
      screen_x = terminals[new_term].screen_x;
      screen_y = terminals[new_term].screen_y;
      update_cursor(screen_x, screen_y);

      // 5. 更新当前终端
      current_terminal = new_term;
  }
  ```

#### 3. 视频内存映射

- **物理视频内存**: 0xB8000 (VGA文本模式缓冲区)
- **屏幕备份**: 每个终端3个4KB缓冲区
- **显示规则**:
    - 只有当前终端写到物理视频内存 (0xB8000)
    - 其他终端写到自己的备份缓冲区
    - 切换时交换内存内容

#### 4. 进程调度器

- **文件**: `pit.c`, `pit.h`
- **使用**: PIT (Programmable Interval Timer)
- **IRQ**: IRQ 0 (IDT入口0x20)

**PIT配置**:

- 设置频率：约100Hz（每10ms一次中断）
- 端口0x40：计数器0数据
- 端口0x43：命令寄存器
- 模式：方波生成器（模式3）

**调度算法**: Round-Robin（轮转调度）

```c
void schedule() {
    // 1. 保存当前进程上下文
    pcb_t* current_pcb = get_pcb(current_pid);
    // ESP和EBP已在中断时保存

    // 2. 选择下一个进程（Round-Robin）
    int next_pid = (current_pid + 1) % 6;
    while (process_array[next_pid].active == 0) {
        next_pid = (next_pid + 1) % 6;
    }

    // 3. 切换页表
    remap(0x08000000, 0x800000 + next_pid * 0x400000);

    // 4. 切换TSS（内核栈）
    tss.esp0 = 0x800000 - next_pid * 0x2000 - 4;

    // 5. 更新当前PID
    current_pid = next_pid;

    // 6. 恢复新进程上下文
    // ESP和EBP在返回时恢复
}
```

#### 5. 进程与终端关系

- 每个终端可以运行一个shell进程
- Shell可以启动子进程
- 进程属于创建它的终端
- 终端切换不影响进程执行（后台继续运行）

#### 6. 启动时行为

- 系统启动时：
    1. 初始化3个终端
    2. 在终端0启动第一个shell
    3. 用户可以切换到终端1/2
    4. 在终端1/2按Enter自动启动shell

#### 7. 信号处理（可选/额外学分）

- **系统调用**:
  ```c
  int32_t set_handler(int32_t signum, void* handler_address);
  int32_t sigreturn(void);
  ```

- **支持的信号**:
    - SIGINT (Ctrl+C): 中断进程
    - SIGALRM: 定时器信号
    - SIGSEGV: 段错误
    - 等等

- **信号处理流程**:
    1. 信号产生
    2. 保存用户上下文到内核栈
    3. 设置返回地址为信号处理函数
    4. 执行用户信号处理函数
    5. 调用sigreturn
    6. 恢复原始上下文

### 测试要求

1. **多终端测试**:
    - 启动系统，在终端0运行shell
    - 按Alt+F2切换到终端1，应该看到空白屏幕
    - 按Enter启动终端1的shell
    - 在终端1运行程序（如cat frame0.txt）
    - 按Alt+F1切换回终端0，应该看到之前的内容
    - 按Alt+F3测试终端2
    - 验证每个终端独立工作

2. **调度测试**:
    - 在终端0运行counter程序（持续计数）
    - 切换到终端1运行另一个counter
    - 切换回终端0，验证计数继续增加
    - 证明两个进程同时运行

3. **并发测试**:
    - 在3个终端同时运行不同程序
    - 验证所有程序都在执行
    - 测试终端切换的流畅性

4. **Fish程序测试**:
    - Fish程序使用vidmap直接写屏幕
    - 在一个终端运行fish
    - 切换到其他终端
    - 切换回来应该看到fish继续动画

### 额外功能（可选）

1. **信号支持**:
    - Ctrl+C杀死前台进程
    - 信号处理函数

2. **更多终端**:
    - 支持超过3个终端

3. **优先级调度**:
    - 替代简单的Round-Robin

4. **后台进程**:
    - 支持 `program &` 语法

### 交付物

- 完整的多终端实现
- PIT驱动和调度器
- 终端切换功能
- 视频内存管理
- 能够同时运行多个进程
- 所有测试通过
- 演示视频展示多任务功能

---

## 项目总结

### 学习目标

通过完成这5个checkpoints，学生将深入理解：

1. 操作系统启动过程
2. 中断和异常处理机制
3. 虚拟内存和分页
4. 设备驱动开发
5. 文件系统设计
6. 系统调用实现
7. 进程管理
8. 多任务调度
9. 用户态与内核态切换

### 关键技术点

- **x86汇编编程**
- **C语言系统编程**
- **硬件接口编程**（PIC, RTC, 键盘, PIT）
- **内存管理**（分页、虚拟内存）
- **并发控制**（调度、上下文切换）
- **底层调试技术**（QEMU, GDB）

### 代码规模

- 总代码量：约8,000-10,000行
- C代码：约6,000-7,000行
- 汇编代码：约1,000行
- 头文件：约1,000-2,000行

### 评分标准（典型）

- Checkpoint 1: 10%
- Checkpoint 2: 12%
- Checkpoint 3: 15%
- Checkpoint 4: 25%
- Checkpoint 5: 23%
- 代码质量和文档: 15%

### 注意事项

1. **每个checkpoint建立在前一个基础上** - 不能跳过
2. **调试困难** - 底层bug难以追踪，需要使用QEMU+GDB
3. **时间管理** - 每个checkpoint需要20-40小时工作量
4. **团队协作** - 需要良好的代码协作和版本控制
5. **及早开始** - 不要等到截止日期前才开始

### 推荐学习资源

- Intel x86架构手册
- OSDev Wiki
- Linux源代码
- QEMU文档
- GDB调试手册

---

## 附录：重要数据结构和常量

### 内存映射

```
0x00000000 - 0x003FFFFF (0-4MB):    4KB页表映射
  0x000B8000:                       视频内存
0x00400000 - 0x007FFFFF (4-8MB):    内核 (4MB页)
0x00800000 - 0x00BFFFFF (8-12MB):   进程0
0x00C00000 - 0x00FFFFFF (12-16MB):  进程1
0x01000000 - 0x013FFFFF (16-20MB):  进程2
0x01400000 - 0x017FFFFF (20-24MB):  进程3
0x01800000 - 0x01BFFFFF (24-28MB):  进程4
0x01C00000 - 0x01FFFFFF (28-32MB):  进程5
0x08000000 (128MB):                 用户程序虚拟地址起始
0x08048000:                         用户程序入口点
0x08400000 (132MB):                 用户栈顶
```

### 重要常量

```c
#define KERNEL_CS       0x0010
#define KERNEL_DS       0x0018
#define USER_CS         0x0023
#define USER_DS         0x002B
#define KERNEL_TSS      0x0030
#define KERNEL_LDT      0x0038

#define VIDEO           0xB8000
#define NUM_COLS        80
#define NUM_ROWS        25
#define ATTRIB          0x7

#define KEYBOARD_IRQ    1
#define RTC_IRQ         8
#define PIT_IRQ         0

#define KEYBOARD_PORT   0x60
#define RTC_PORT        0x70
#define RTC_DATA        0x71
```

### 设备端口

```c
// PIC
#define MASTER_8259_PORT    0x20
#define MASTER_8259_DATA    0x21
#define SLAVE_8259_PORT     0xA0
#define SLAVE_8259_DATA     0xA1

// 键盘
#define KEYBOARD_DATA_PORT  0x60
#define KEYBOARD_STATUS_PORT 0x64

// RTC
#define RTC_INDEX           0x70
#define RTC_DATA            0x71

// PIT
#define PIT_CHANNEL_0       0x40
#define PIT_COMMAND         0x43
```

---

**文档创建日期**: 2025-11-21
**基于**: UIUC ECE 391 Fall 2017 MP3
**参考**: 课程材料、学生代码库、测试文件
