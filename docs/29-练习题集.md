# ECE 391 练习题集

> 本文档包含各模块的练习题，帮助巩固理解。每道题都有参考答案。

---

## 使用说明

- 先独立思考，再看答案
- 代码题建议实际编写并测试
- 思考题没有标准答案，重点是思考过程

---

## 一、Checkpoint 1 - 基础设施

### 1.1 IDT 相关

#### 概念题

**Q1**: IDT 表共有多少项？每项占多少字节？

<details>
<summary>答案</summary>

- 256 项
- 每项 8 字节
- 总大小：256 × 8 = 2048 字节

</details>

---

**Q2**: 中断门和陷阱门的区别是什么？分别在什么场景使用？

<details>
<summary>答案</summary>

| 类型 | 进入时 IF 标志 | 使用场景 |
|------|--------------|---------|
| 中断门 (0xE) | 自动清除（关中断） | 硬件中断处理 |
| 陷阱门 (0xF) | 保持不变 | 异常处理、系统调用 |

- 中断门：防止中断嵌套，用于键盘、RTC 等硬件中断
- 陷阱门：允许被中断，用于异常和系统调用

</details>

---

**Q3**: DPL 字段的作用是什么？系统调用的 IDT 表项 DPL 应该设为多少？

<details>
<summary>答案</summary>

- DPL (Descriptor Privilege Level)：描述符特权级
- 决定谁可以触发这个中断
- DPL=0：只有内核代码能触发
- DPL=3：用户代码也能触发

系统调用 (int 0x80) 的 DPL 必须设为 **3**，否则用户程序无法调用。

</details>

---

#### 代码题

**Q4**: 补全以下 IDT 表项设置代码：

```c
void set_idt_entry(int index, uint32_t handler) {
    idt[index].offset_15_00 = _____________;
    idt[index].offset_31_16 = _____________;
    idt[index].seg_selector = KERNEL_CS;
    idt[index].present = _____;
    idt[index].dpl = 0;
    idt[index].type = 0xF;  // 陷阱门
}
```

<details>
<summary>答案</summary>

```c
void set_idt_entry(int index, uint32_t handler) {
    idt[index].offset_15_00 = handler & 0xFFFF;        // 低 16 位
    idt[index].offset_31_16 = (handler >> 16) & 0xFFFF; // 高 16 位
    idt[index].seg_selector = KERNEL_CS;
    idt[index].present = 1;                             // 必须为 1
    idt[index].dpl = 0;
    idt[index].type = 0xF;
}
```

</details>

---

**Q5**: 以下代码有什么问题？

```c
// 设置系统调用入口
set_idt_entry(0x80, (uint32_t)syscall_handler, KERNEL_CS, 0xE, 0);
```

<details>
<summary>答案</summary>

两个问题：

1. **类型错误**：系统调用应该用陷阱门 (0xF)，不是中断门 (0xE)
   - 中断门会关中断，系统调用期间无法响应其他中断

2. **DPL 错误**：DPL 应该是 3，不是 0
   - DPL=0 会导致用户程序无法触发 int 0x80

正确代码：
```c
set_idt_entry(0x80, (uint32_t)syscall_handler, KERNEL_CS, 0xF, 3);
```

</details>

---

### 1.2 分页相关

#### 概念题

**Q6**: 32 位虚拟地址如何分解？各部分的作用是什么？

<details>
<summary>答案</summary>

```
31                22 21                12 11                 0
┌──────────────────┬──────────────────┬──────────────────────┐
│   页目录索引      │    页表索引       │      页内偏移        │
│    (10 位)       │    (10 位)       │      (12 位)         │
└──────────────────┴──────────────────┴──────────────────────┘
```

- 页目录索引 (10位)：在页目录中找到对应的页目录项 (PDE)
- 页表索引 (10位)：在页表中找到对应的页表项 (PTE)
- 页内偏移 (12位)：在 4KB 页内的偏移量

</details>

---

**Q7**: 4KB 页和 4MB 页的区别？本项目中分别用在哪里？

<details>
<summary>答案</summary>

| 类型 | 映射级数 | 用途 |
|------|---------|------|
| 4KB 页 | 两级（页目录 + 页表） | 视频内存 (0xB8000) |
| 4MB 页 | 一级（只用页目录） | 内核 (4-8MB)、用户程序 |

4MB 页优点：
- 减少 TLB miss
- 简化大块连续内存映射
- 页目录项的 PS 位 = 1

</details>

---

**Q8**: 发生 Page Fault 时，故障地址存在哪个寄存器？错误码各位的含义？

<details>
<summary>答案</summary>

故障地址存在 **CR2** 寄存器。

错误码各位含义：
```
Bit 0 (P):    0 = 页不存在，1 = 保护违规
Bit 1 (W/R):  0 = 读操作，1 = 写操作
Bit 2 (U/S):  0 = 内核态访问，1 = 用户态访问
```

例如：错误码 = 0x05 (二进制 101)
- P=1：页存在（保护违规）
- W/R=0：读操作
- U/S=1：用户态访问

解读：用户态读取了一个没有用户权限的页。

</details>

---

#### 代码题

**Q9**: 补全页目录初始化代码：

```c
void paging_init() {
    // 第一个页目录项：指向页表，4KB 页映射
    page_directory[0] = (uint32_t)page_table | _____;

    // 第二个页目录项：4MB 大页映射内核
    page_directory[1] = 0x400000 | _____;

    // 映射视频内存
    page_table[_____] = 0xB8000 | 0x03;

    // 加载页目录
    asm volatile("movl %0, %%cr3" : : "r"(_____));
}
```

<details>
<summary>答案</summary>

```c
void paging_init() {
    // 0x03 = Present + R/W
    page_directory[0] = (uint32_t)page_table | 0x03;

    // 0x83 = Present + R/W + PS (4MB 页)
    page_directory[1] = 0x400000 | 0x83;

    // 0xB8000 >> 12 = 0xB8 = 184
    page_table[0xB8000 >> 12] = 0xB8000 | 0x03;
    // 或者 page_table[184] = 0xB8000 | 0x03;

    // 加载页目录地址
    asm volatile("movl %0, %%cr3" : : "r"(page_directory));
}
```

</details>

---

**Q10**: 用户进程的页表设置，补全代码：

```c
// 将 128MB 虚拟地址映射到进程 pid 的物理内存
void setup_user_page(uint32_t pid) {
    uint32_t phys_addr = _____________;
    page_directory[_____] = phys_addr | _____;
    flush_tlb();
}
```

<details>
<summary>答案</summary>

```c
void setup_user_page(uint32_t pid) {
    // 进程物理地址 = 8MB + pid * 4MB
    uint32_t phys_addr = 0x800000 + pid * 0x400000;

    // 128MB / 4MB = 32，所以是页目录第 32 项
    // 0x87 = Present + R/W + User + PS (4MB页)
    page_directory[32] = phys_addr | 0x87;

    flush_tlb();
}
```

</details>

---

### 1.3 异常处理

#### 概念题

**Q11**: 为什么异常处理需要汇编包装函数？不能直接用 C 函数吗？

<details>
<summary>答案</summary>

不能直接用 C 函数，原因：

1. **寄存器保存**：CPU 只自动保存 CS/EIP/EFLAGS/SS/ESP，通用寄存器需要手动保存
2. **返回指令不同**：C 函数用 `ret`，中断返回用 `iret`
3. **错误码处理**：有些异常有错误码，需要手动处理
4. **栈平衡**：需要确保返回时栈正确

汇编包装的作用：
```asm
wrapper:
    pushal          # 保存通用寄存器
    call c_handler  # 调用 C 函数
    popal           # 恢复寄存器
    iret            # 中断返回
```

</details>

---

**Q12**: 哪些异常有错误码？列举 3 个。

<details>
<summary>答案</summary>

有错误码的异常：
- **8**: Double Fault
- **10**: Invalid TSS
- **11**: Segment Not Present
- **12**: Stack-Segment Fault
- **13**: General Protection Fault
- **14**: Page Fault
- **17**: Alignment Check

无错误码的异常（如除零、断点等）需要手动对齐栈。

</details>

---

#### 代码题

**Q13**: 补全异常处理的汇编包装：

```c
// 无错误码的异常（如除零）
divide_error_wrapper:
    _______         # 保存寄存器
    call divide_error_handler
    _______         # 恢复寄存器
    _______         # 返回

// 有错误码的异常（如 Page Fault）
page_fault_wrapper:
    _______
    call page_fault_handler
    _______
    addl $4, %esp   # 为什么需要这行？
    _______
```

<details>
<summary>答案</summary>

```asm
divide_error_wrapper:
    pushal
    call divide_error_handler
    popal
    iret

page_fault_wrapper:
    pushal
    call page_fault_handler
    popal
    addl $4, %esp   # 跳过错误码（CPU 自动压入的）
    iret
```

`addl $4, %esp` 的原因：
- CPU 在进入异常时自动压入了错误码
- `iret` 期望栈顶是 EIP，不是错误码
- 所以需要手动跳过这 4 字节

</details>

---

### 1.4 思考题

**Q14**: 如果不初始化 IDT 就开中断会发生什么？

<details>
<summary>答案</summary>

会发生 **Triple Fault**，系统重启。

原因：
1. 开中断后，任何硬件中断都会触发
2. CPU 查 IDT 表，发现表项无效（present=0 或地址为 0）
3. 触发 General Protection Fault (#GP)
4. 处理 #GP 时，IDT[13] 也无效
5. 触发 Double Fault (#DF)
6. 处理 #DF 时，IDT[8] 也无效
7. Triple Fault，CPU 复位

</details>

---

**Q15**: 为什么内核用 4MB 大页而不是 4KB 页？

<details>
<summary>答案</summary>

原因：

1. **减少 TLB miss**：
   - 4KB 页需要更多 TLB 条目
   - 4MB 页覆盖范围大，TLB 命中率高

2. **简化映射**：
   - 4KB 需要维护页表
   - 4MB 只需页目录项

3. **内核内存连续**：
   - 内核代码和数据是连续的 4MB
   - 正好适合一个 4MB 大页

4. **性能**：
   - 地址转换少一级查表
   - 减少内存访问

</details>

---

## 二、Checkpoint 2 - 设备驱动

### 2.1 键盘驱动

#### 概念题

**Q16**: 键盘中断是 IRQ 几？对应 IDT 表的哪一项？

<details>
<summary>答案</summary>

- IRQ 1
- IDT 表项 = 0x20 + 1 = **0x21** (33)

因为主 PIC 的 IRQ 0-7 映射到 IDT 0x20-0x27。

</details>

---

**Q17**: 扫描码的最高位表示什么？

<details>
<summary>答案</summary>

最高位 (bit 7) 表示按键状态：
- **0**：按下 (make code)
- **1**：释放 (break code)

例如：
- 'A' 按下：0x1E
- 'A' 释放：0x9E (0x1E | 0x80)

</details>

---

#### 代码题

**Q18**: 补全键盘中断处理函数：

```c
void keyboard_handler() {
    // 1. 读取扫描码
    uint8_t scancode = _____________;

    // 2. 判断是按下还是释放
    if (scancode & _____) {
        // 释放
        scancode &= _____;
        if (scancode == LEFT_SHIFT || scancode == RIGHT_SHIFT)
            shift_pressed = 0;
    } else {
        // 按下
        if (scancode == LEFT_SHIFT || scancode == RIGHT_SHIFT) {
            shift_pressed = 1;
        } else {
            char c = scancode_table[scancode];
            if (c) {
                // 处理大小写
                if (c >= 'a' && c <= 'z' && (shift_pressed ^ caps_lock))
                    c = c - 'a' + 'A';
                add_to_buffer(c);
                putc(c);
            }
        }
    }

    // 3. 发送 EOI
    _____________;
}
```

<details>
<summary>答案</summary>

```c
void keyboard_handler() {
    uint8_t scancode = inb(0x60);       // 从端口 0x60 读取

    if (scancode & 0x80) {              // 检查最高位
        scancode &= 0x7F;               // 清除最高位得到原始扫描码
        if (scancode == LEFT_SHIFT || scancode == RIGHT_SHIFT)
            shift_pressed = 0;
    } else {
        if (scancode == LEFT_SHIFT || scancode == RIGHT_SHIFT) {
            shift_pressed = 1;
        } else {
            char c = scancode_table[scancode];
            if (c) {
                if (c >= 'a' && c <= 'z' && (shift_pressed ^ caps_lock))
                    c = c - 'a' + 'A';
                add_to_buffer(c);
                putc(c);
            }
        }
    }

    send_eoi(KEYBOARD_IRQ);             // 或 send_eoi(1)
}
```

</details>

---

### 2.2 终端驱动

#### 概念题

**Q19**: VGA 文本模式下，每个字符在显存中占几个字节？分别是什么？

<details>
<summary>答案</summary>

每个字符占 **2 字节**：
- 字节 0：ASCII 字符
- 字节 1：属性（颜色）

属性字节格式：
```
7   6   5   4   3   2   1   0
┌───┬───────────┬───────────┐
│ B │  背景色   │  前景色    │
└───┴───────────┴───────────┘
B = 闪烁位
```

默认属性 0x07 = 黑底白字

</details>

---

**Q20**: 视频内存地址如何计算？

<details>
<summary>答案</summary>

```c
地址 = VIDEO + (行 * 列数 + 列) * 2
     = 0xB8000 + (screen_y * 80 + screen_x) * 2
```

或者用位移：
```c
地址 = VIDEO + ((screen_y * NUM_COLS + screen_x) << 1)
```

乘以 2 是因为每个字符占 2 字节。

</details>

---

#### 代码题

**Q21**: 实现 putc 函数（处理普通字符和换行）：

```c
void putc(char c) {
    if (c == '\n') {
        screen_x = _____;
        screen_y_____;
    } else {
        // 计算显存地址并写入
        int offset = _____________;
        *(char*)(VIDEO + offset) = _____;
        *(char*)(VIDEO + offset + 1) = ATTRIB;
        screen_x_____;
    }

    // 检查是否需要换行
    if (screen_x >= NUM_COLS) {
        screen_x = _____;
        screen_y_____;
    }

    // 检查是否需要滚屏
    if (screen_y >= NUM_ROWS) {
        scroll();
        screen_y = _____________;
    }
}
```

<details>
<summary>答案</summary>

```c
void putc(char c) {
    if (c == '\n') {
        screen_x = 0;
        screen_y++;
    } else {
        int offset = (screen_y * NUM_COLS + screen_x) << 1;
        *(char*)(VIDEO + offset) = c;
        *(char*)(VIDEO + offset + 1) = ATTRIB;
        screen_x++;
    }

    if (screen_x >= NUM_COLS) {
        screen_x = 0;
        screen_y++;
    }

    if (screen_y >= NUM_ROWS) {
        scroll();
        screen_y = NUM_ROWS - 1;
    }
}
```

</details>

---

### 2.3 RTC 驱动

#### 概念题

**Q22**: RTC 中断是 IRQ 几？为什么要先使能 IRQ 2？

<details>
<summary>答案</summary>

- RTC 是 **IRQ 8**（从 PIC 的 IRQ 0）
- IDT 表项 = 0x28 + 0 = **0x28** (40)

需要先使能 IRQ 2 的原因：
- 从 PIC 通过 IRQ 2 连接到主 PIC
- IRQ 2 被用于级联
- 如果 IRQ 2 被屏蔽，所有从 PIC 的中断都无法到达 CPU

</details>

---

**Q23**: RTC 中断处理后必须做什么？不做会怎样？

<details>
<summary>答案</summary>

必须读取寄存器 C：
```c
outb(0x0C, 0x70);  // 选择寄存器 C
inb(0x71);         // 读取并丢弃
```

不读取的后果：
- RTC 不会产生下一次中断
- rtc_read() 永远阻塞

原因：读取寄存器 C 会清除中断标志，允许产生新的中断。

</details>

---

#### 代码题

**Q24**: 补全 RTC 初始化和中断处理：

```c
void rtc_init() {
    // 使能周期性中断
    outb(0x8B, _____);              // 选择寄存器 B，禁用 NMI
    char prev = inb(_____);          // 读取寄存器 B
    outb(0x8B, _____);
    outb(prev | _____, _____);       // 设置 PIE 位

    // 使能中断
    enable_irq(_____);               // 级联
    enable_irq(_____);               // RTC
}

void rtc_handler() {
    // 读取寄存器 C 清除中断
    outb(_____, 0x70);
    inb(_____);

    rtc_interrupt_occurred = 1;

    send_eoi(_____);
}
```

<details>
<summary>答案</summary>

```c
void rtc_init() {
    outb(0x8B, 0x70);           // 选择寄存器 B
    char prev = inb(0x71);      // 读取当前值
    outb(0x8B, 0x70);           // 再次选择（读取会重置索引）
    outb(prev | 0x40, 0x71);    // 设置 PIE 位 (bit 6)

    enable_irq(2);              // 级联
    enable_irq(8);              // RTC
}

void rtc_handler() {
    outb(0x0C, 0x70);           // 选择寄存器 C
    inb(0x71);                  // 读取清除中断

    rtc_interrupt_occurred = 1;

    send_eoi(8);                // RTC 是 IRQ 8
}
```

</details>

---

### 2.4 8259 PIC

#### 概念题

**Q25**: 主片和从片的端口地址分别是什么？

<details>
<summary>答案</summary>

| PIC | 命令端口 | 数据端口 |
|-----|---------|---------|
| 主片 | 0x20 | 0x21 |
| 从片 | 0xA0 | 0xA1 |

</details>

---

**Q26**: 从片的中断（IRQ 8-15）需要发送几次 EOI？发给谁？

<details>
<summary>答案</summary>

需要发送 **2 次** EOI：
1. 先发给从片 (0xA0)
2. 再发给主片 (0x20)

```c
void send_eoi(uint32_t irq_num) {
    if (irq_num >= 8) {
        outb(EOI, SLAVE_8259_PORT);   // 从片
    }
    outb(EOI, MASTER_8259_PORT);      // 主片
}
```

原因：从片通过 IRQ 2 连接主片，所以主片也要知道中断已处理。

</details>

---

### 2.5 思考题

**Q27**: 如果键盘缓冲区满了还继续输入会怎样？应该怎么处理？

<details>
<summary>答案</summary>

常见处理方式：

1. **忽略新输入**（本项目采用）：
   ```c
   if (buffer_index >= BUFFER_SIZE - 1) {
       send_eoi(KEYBOARD_IRQ);
       return;  // 直接返回，不处理
   }
   ```

2. **覆盖旧数据**：环形缓冲区

3. **发出提示音**：beep

本项目要求 128 字节缓冲区，满了就忽略，但仍然接受 Enter 键。

</details>

---

## 三、Checkpoint 3 - 系统调用与进程

### 3.1 文件系统

#### 概念题

**Q28**: 文件系统的三个主要区域是什么？各自的作用？

<details>
<summary>答案</summary>

```
┌─────────────────┐
│   Boot Block    │  目录项（最多 63 个文件）
├─────────────────┤
│   Inode 区域    │  每个文件的元信息（大小、数据块索引）
├─────────────────┤
│  Data Block 区域│  实际文件内容
└─────────────────┘
```

每个区域都是 4KB 的倍数。

</details>

---

**Q29**: 如何根据 inode 号计算 inode 的地址？

<details>
<summary>答案</summary>

```c
inode_t* get_inode(uint32_t inode_num) {
    // inode 区域从 boot_block 后面开始
    // 每个 inode 占 4KB
    return (inode_t*)((uint32_t)boot_block + (inode_num + 1) * 4096);
}
```

`+1` 是因为第一个 4KB 块是 boot_block。

</details>

---

#### 代码题

**Q30**: 实现 read_dentry_by_name：

```c
int32_t read_dentry_by_name(const uint8_t* fname, dentry_t* dentry) {
    int i;
    for (i = 0; i < _____________; i++) {
        if (strncmp((char*)fname,
                    _____________,
                    _____) == 0) {
            memcpy(dentry, _____________, sizeof(dentry_t));
            return _____;
        }
    }
    return _____;
}
```

<details>
<summary>答案</summary>

```c
int32_t read_dentry_by_name(const uint8_t* fname, dentry_t* dentry) {
    int i;
    for (i = 0; i < boot_block->dir_count; i++) {
        if (strncmp((char*)fname,
                    boot_block->direntries[i].filename,
                    32) == 0) {
            memcpy(dentry, &boot_block->direntries[i], sizeof(dentry_t));
            return 0;
        }
    }
    return -1;
}
```

注意：文件名最多 32 字节，不一定有 null 结尾。

</details>

---

### 3.2 系统调用

#### 概念题

**Q31**: 系统调用通过什么机制从用户态进入内核态？参数如何传递？

<details>
<summary>答案</summary>

机制：**int 0x80** 软中断

参数传递：
- EAX：系统调用号
- EBX：参数 1
- ECX：参数 2
- EDX：参数 3
- 返回值：EAX

</details>

---

**Q32**: 文件描述符 0 和 1 分别代表什么？

<details>
<summary>答案</summary>

- fd 0：**stdin**（标准输入，终端读取）
- fd 1：**stdout**（标准输出，终端写入）

每个进程创建时自动打开这两个描述符。

</details>

---

#### 代码题

**Q33**: 实现 read 系统调用：

```c
int32_t read(int32_t fd, void* buf, int32_t nbytes) {
    // 1. 检查 fd 有效性
    if (fd < _____ || fd > _____) return -1;

    // 2. 获取当前 PCB
    pcb_t* pcb = _____________;

    // 3. 检查文件是否打开
    if (pcb->fd_table[fd]._____ == 0) return -1;

    // 4. 调用对应的 read 函数
    return pcb->fd_table[fd]._____->read(fd, buf, nbytes);
}
```

<details>
<summary>答案</summary>

```c
int32_t read(int32_t fd, void* buf, int32_t nbytes) {
    if (fd < 0 || fd > 7) return -1;

    pcb_t* pcb = get_current_pcb();

    if (pcb->fd_table[fd].flags == 0) return -1;

    return pcb->fd_table[fd].fops->read(fd, buf, nbytes);
}
```

</details>

---

**Q34**: 实现 open 系统调用（简化版）：

```c
int32_t open(const uint8_t* filename) {
    pcb_t* pcb = get_current_pcb();
    dentry_t dentry;

    // 1. 查找文件
    if (read_dentry_by_name(filename, &dentry) == _____) {
        return _____;
    }

    // 2. 找到空闲的 fd（从 2 开始，0 和 1 是 stdin/stdout）
    int fd;
    for (fd = _____; fd < _____; fd++) {
        if (pcb->fd_table[fd].flags == _____) break;
    }
    if (fd == 8) return _____;  // 没有空闲 fd

    // 3. 根据文件类型设置 fops
    if (dentry.filetype == 2) {  // 普通文件
        pcb->fd_table[fd].fops = &_____________;
    } else if (dentry.filetype == 0) {  // RTC
        pcb->fd_table[fd].fops = &_____________;
    }

    // 4. 初始化其他字段
    pcb->fd_table[fd].inode = dentry._____________;
    pcb->fd_table[fd].file_position = _____;
    pcb->fd_table[fd].flags = _____;

    // 5. 调用设备的 open 函数
    pcb->fd_table[fd].fops->open(filename);

    return _____;
}
```

<details>
<summary>答案</summary>

```c
int32_t open(const uint8_t* filename) {
    pcb_t* pcb = get_current_pcb();
    dentry_t dentry;

    if (read_dentry_by_name(filename, &dentry) == -1) {
        return -1;
    }

    int fd;
    for (fd = 2; fd < 8; fd++) {
        if (pcb->fd_table[fd].flags == 0) break;
    }
    if (fd == 8) return -1;

    if (dentry.filetype == 2) {
        pcb->fd_table[fd].fops = &file_fops;
    } else if (dentry.filetype == 0) {
        pcb->fd_table[fd].fops = &rtc_fops;
    }

    pcb->fd_table[fd].inode = dentry.inode_num;
    pcb->fd_table[fd].file_position = 0;
    pcb->fd_table[fd].flags = 1;

    pcb->fd_table[fd].fops->open(filename);

    return fd;
}
```

</details>

---

### 3.3 进程管理

#### 概念题

**Q35**: execute 系统调用的主要步骤是什么？

<details>
<summary>答案</summary>

1. 解析命令（程序名 + 参数）
2. 检查文件存在
3. 验证 ELF 魔数 (0x7f 'E' 'L' 'F')
4. 分配 PID
5. 设置用户空间页表 (128MB)
6. 加载程序到内存
7. 创建 PCB，初始化 fd 表
8. 设置 TSS (内核栈)
9. IRET 切换到用户态

</details>

---

**Q36**: halt 如何返回到父进程？

<details>
<summary>答案</summary>

1. 关闭所有打开的文件
2. 恢复父进程的页表
3. 恢复父进程的 TSS
4. 恢复父进程的 ESP/EBP
5. 返回到父进程 execute() 调用处

关键是保存和恢复上下文：
```c
// execute 中保存
pcb->parent_esp = current_esp;
pcb->parent_ebp = current_ebp;

// halt 中恢复
asm volatile("movl %0, %%esp; movl %1, %%ebp"
             : : "r"(pcb->parent_esp), "r"(pcb->parent_ebp));
```

</details>

---

#### 代码题

**Q37**: 补全 IRET 切换到用户态的代码：

```c
// 切换到用户态执行程序
// entry_point: 程序入口地址
// user_esp: 用户栈顶 (0x8400000)
void switch_to_user_mode(uint32_t entry_point, uint32_t user_esp) {
    asm volatile(
        "cli;"
        "movw %0, %%ax;"
        "movw %%ax, %%ds;"
        "movw %%ax, %%es;"
        "movw %%ax, %%fs;"
        "movw %%ax, %%gs;"

        "pushl %0;"        // 压入 _____
        "pushl %1;"        // 压入 _____
        "pushfl;"
        "popl %%eax;"
        "orl $0x200, %%eax;"  // 设置 _____ 位
        "pushl %%eax;"     // 压入 _____
        "pushl %2;"        // 压入 _____
        "pushl %3;"        // 压入 _____
        "iret;"
        :
        : "r"(USER_DS), "r"(user_esp), "r"(USER_CS), "r"(entry_point)
        : "eax"
    );
}
```

<details>
<summary>答案</summary>

```c
void switch_to_user_mode(uint32_t entry_point, uint32_t user_esp) {
    asm volatile(
        "cli;"
        "movw %0, %%ax;"
        "movw %%ax, %%ds;"
        "movw %%ax, %%es;"
        "movw %%ax, %%fs;"
        "movw %%ax, %%gs;"

        "pushl %0;"        // 压入 SS (USER_DS)
        "pushl %1;"        // 压入 ESP (用户栈)
        "pushfl;"
        "popl %%eax;"
        "orl $0x200, %%eax;"  // 设置 IF 位（开中断）
        "pushl %%eax;"     // 压入 EFLAGS
        "pushl %2;"        // 压入 CS (USER_CS)
        "pushl %3;"        // 压入 EIP (入口点)
        "iret;"
        :
        : "r"(USER_DS), "r"(user_esp), "r"(USER_CS), "r"(entry_point)
        : "eax"
    );
}
```

IRET 期望的栈布局（从栈顶到栈底）：
```
EIP
CS
EFLAGS
ESP
SS
```

</details>

---

### 3.4 思考题

**Q38**: 为什么 stdin (fd=0) 不能 write，stdout (fd=1) 不能 read？

<details>
<summary>答案</summary>

这是 Unix 的设计约定：
- stdin 是输入流，只能读取
- stdout 是输出流，只能写入

实现方式：
```c
// stdin 的 fops
file_operations_t stdin_fops = {
    .read = terminal_read,
    .write = invalid_write,  // 返回 -1
};

// stdout 的 fops
file_operations_t stdout_fops = {
    .read = invalid_read,    // 返回 -1
    .write = terminal_write,
};
```

</details>

---

## 四、Checkpoint 4/5 - 多终端与调度

### 4.1 多终端

#### 概念题

**Q39**: 每个终端需要维护哪些独立状态？

<details>
<summary>答案</summary>

```c
typedef struct terminal {
    char kb_buffer[128];     // 键盘缓冲区
    int buffer_index;        // 缓冲区索引
    int screen_x, screen_y;  // 光标位置
    char video_backup[4096]; // 视频内存备份
    int active_pid;          // 当前运行的进程
    int enter_pressed;       // Enter 标志
} terminal_t;
```

</details>

---

**Q40**: 终端切换时需要做什么？

<details>
<summary>答案</summary>

1. 保存当前终端的视频内存到备份
2. 保存当前终端的光标位置
3. 恢复新终端的视频内存
4. 恢复新终端的光标位置
5. 更新硬件光标
6. 更新 current_terminal 变量

注意：终端切换不影响进程执行，后台进程继续运行。

</details>

---

### 4.2 调度器

#### 概念题

**Q41**: PIT 的作用是什么？频率设为多少？

<details>
<summary>答案</summary>

PIT (Programmable Interval Timer) 的作用：
- 产生周期性的时钟中断
- 驱动进程调度器

频率：通常设为 **100Hz**（每 10ms 一次中断）

计算：
```c
uint16_t divisor = 1193180 / 100;  // ≈ 11932
```

</details>

---

**Q42**: Round-Robin 调度如何选择下一个进程？

<details>
<summary>答案</summary>

```c
void schedule() {
    int next_pid = current_pid;
    do {
        next_pid = (next_pid + 1) % MAX_PROCESSES;
    } while (!process_active[next_pid]);

    if (next_pid != current_pid) {
        switch_to(next_pid);
    }
}
```

特点：
- 按 PID 顺序轮转
- 跳过不活跃的进程
- 所有进程获得相同的时间片

</details>

---

#### 代码题

**Q43**: 补全调度器的上下文切换：

```c
void switch_to(int next_pid) {
    pcb_t* current = get_pcb(current_pid);
    pcb_t* next = get_pcb(next_pid);

    // 1. 保存当前进程的栈指针
    asm volatile("movl %%esp, %0" : "=m"(_____________));
    asm volatile("movl %%ebp, %0" : "=m"(_____________));

    // 2. 切换页表
    _____________(next_pid);

    // 3. 切换 TSS（内核栈）
    tss.esp0 = _____________;

    // 4. 更新当前 PID
    current_pid = _____________;

    // 5. 恢复新进程的栈指针
    asm volatile("movl %0, %%esp" : : "m"(_____________));
    asm volatile("movl %0, %%ebp" : : "m"(_____________));
}
```

<details>
<summary>答案</summary>

```c
void switch_to(int next_pid) {
    pcb_t* current = get_pcb(current_pid);
    pcb_t* next = get_pcb(next_pid);

    asm volatile("movl %%esp, %0" : "=m"(current->esp));
    asm volatile("movl %%ebp, %0" : "=m"(current->ebp));

    setup_user_page(next_pid);

    tss.esp0 = get_kernel_stack_top(next_pid);

    current_pid = next_pid;

    asm volatile("movl %0, %%esp" : : "m"(next->esp));
    asm volatile("movl %0, %%ebp" : : "m"(next->ebp));
}
```

</details>

---

### 4.3 思考题

**Q44**: 如果调度器中不切换页表会发生什么？

<details>
<summary>答案</summary>

会导致进程访问错误的内存：
- 128MB 虚拟地址仍然映射到旧进程的物理内存
- 新进程会读/写旧进程的数据
- 可能导致数据损坏或崩溃

所以必须在切换进程时更新页表。

</details>

---

**Q45**: 终端切换和进程切换有什么区别？

<details>
<summary>答案</summary>

| 方面 | 终端切换 | 进程切换 |
|------|---------|---------|
| 触发 | Alt+Fx | PIT 中断 |
| 影响 | 显示和输入 | CPU 执行 |
| 后台行为 | 进程继续运行 | 进程暂停 |
| 保存内容 | 视频内存、光标 | 寄存器、栈、页表 |

终端切换只改变"看到什么"，进程切换改变"谁在运行"。

</details>

---

## 五、综合题

**Q46**: 从按下 Enter 到 shell 执行命令，完整描述这个过程。

<details>
<summary>答案</summary>

1. **键盘中断**：
   - 键盘产生 IRQ 1
   - CPU 跳转到 keyboard_handler
   - 读取扫描码 0x1C (Enter)
   - 设置 enter_pressed = 1
   - 发送 EOI

2. **terminal_read 返回**：
   - shell 之前调用 read(0, buf, n) 阻塞
   - terminal_read 检测到 enter_pressed
   - 复制缓冲区内容到 buf
   - 返回读取的字节数

3. **shell 解析命令**：
   - 解析用户输入（如 "ls"）
   - 调用 execute("ls")

4. **execute 系统调用**：
   - int 0x80 进入内核
   - 查找文件、检查 ELF
   - 分配 PID、设置页表
   - 加载程序
   - IRET 到 ls 程序

5. **ls 执行**：
   - ls 调用 open(".")、read、write
   - 显示文件列表

6. **ls 退出**：
   - ls 调用 halt(0)
   - 恢复 shell 的上下文
   - 返回到 shell 的 execute() 调用

7. **shell 继续**：
   - 打印提示符
   - 再次调用 read() 等待输入

</details>

---

**Q47**: 设计题：如果要支持更多进程（比如 100 个），需要修改哪些地方？

<details>
<summary>答案</summary>

需要修改：

1. **内存管理**：
   - 当前每个进程固定 4MB 物理内存
   - 需要实现动态内存分配
   - 或者实现页面交换（swap）

2. **PID 管理**：
   - 当前是固定数组 process_active[6]
   - 需要改成动态分配或位图管理

3. **内核栈**：
   - 当前每个进程 8KB 内核栈
   - 100 个进程需要 800KB
   - 可能需要减小栈大小或动态分配

4. **调度器**：
   - 当前 O(n) 遍历
   - 100 个进程性能可能下降
   - 可以改用优先队列或运行队列

5. **PCB 存储**：
   - 当前 PCB 在内核栈底部
   - 可能需要单独的 PCB 数组

</details>

---

## 六、答题统计

完成以下表格检验学习效果：

| 章节 | 题目数 | 正确数 | 正确率 |
|------|--------|--------|--------|
| CP1 基础设施 | 15 | | |
| CP2 设备驱动 | 12 | | |
| CP3 系统调用 | 10 | | |
| CP4/5 调度 | 7 | | |
| 综合题 | 2 | | |
| **总计** | **46** | | |

---

> 建议：错题重新看对应的深度解析文档，理解原理后再做一遍。
