# ECE 391 项目面试题集

> 本文档整理了基于 ECE 391 项目可以回答的面试题，帮助你在面试中展示项目经验。

---

## 一、如何在简历中描述这个项目

### 推荐写法

```
操作系统内核开发项目
- 从零实现 x86 操作系统内核，包含中断处理、内存管理、进程调度等核心模块
- 实现分页机制，支持 4KB/4MB 页面，完成虚拟地址到物理地址的映射
- 开发键盘、终端、RTC 设备驱动，实现中断处理和缓冲区管理
- 实现 8 个系统调用（execute/halt/read/write/open/close/getargs/vidmap）
- 实现 Round-Robin 进程调度器，支持多终端和多进程并发执行
- 技术栈：C, x86 汇编, GDB, QEMU
```

### 面试时如何介绍

> "这是一个从零开始实现的操作系统内核项目。我负责实现了 [具体模块]。这个项目让我深入理解了 [具体知识点]，比如 [举例说明]..."

---

## 二、按模块整理的面试题

### 2.1 中断与异常处理

#### Q1: 什么是中断？中断和异常有什么区别？

**答案要点**：
- **中断**：外部硬件产生的异步事件（如键盘按键、定时器）
- **异常**：CPU 执行指令时产生的同步事件（如除零、缺页）
- **区别**：
  - 中断是异步的，异常是同步的
  - 中断来自外部设备，异常来自 CPU 内部
  - 中断可以被屏蔽，某些异常不能

**项目中的体现**：
```c
// 异常处理 - exception_handler.c
void divide_error_handler() {
    printf("Exception: Divide Error\n");
    while(1);  // 停机
}

// 中断处理 - keyboard.c
void keyboard_handler() {
    uint8_t scancode = inb(KEYBOARD_PORT);
    // 处理按键...
    send_eoi(KEYBOARD_IRQ);
}
```

---

#### Q2: 描述一下中断处理的完整流程？

**答案要点**：

```
1. 硬件中断发生（如键盘按键）
2. 中断控制器（8259 PIC）接收中断请求
3. PIC 向 CPU 发送中断信号
4. CPU 完成当前指令，检查 IF 标志
5. CPU 自动保存 EFLAGS, CS, EIP 到栈
6. CPU 从 IDT 查找中断处理程序入口
7. 跳转到中断处理程序
8. 执行中断处理（保存寄存器、处理、恢复寄存器）
9. 发送 EOI 给 PIC
10. 执行 IRET 返回
```

**项目代码示例**：
```asm
# interrupt_handler.S
keyboard_handler_wrapper:
    pushal              # 保存所有寄存器
    call keyboard_handler  # 调用 C 处理函数
    popal               # 恢复寄存器
    iret                # 返回
```

---

#### Q3: 什么是 IDT？如何设置 IDT 表项？

**答案要点**：
- IDT（Interrupt Descriptor Table）：中断描述符表
- 256 个表项，每个表项 8 字节
- 包含：中断处理程序地址、段选择子、类型（中断门/陷阱门）、DPL

**项目代码**：
```c
// idt_init.c
void set_idt_entry(int index, uint32_t handler, uint16_t selector,
                   uint8_t type, uint8_t dpl) {
    idt[index].offset_15_00 = handler & 0xFFFF;
    idt[index].offset_31_16 = (handler >> 16) & 0xFFFF;
    idt[index].seg_selector = selector;
    idt[index].dpl = dpl;
    idt[index].type = type;
    idt[index].present = 1;
}
```

---

#### Q4: 中断门和陷阱门有什么区别？

**答案要点**：
- **中断门**：进入时自动清除 IF 标志（关中断）
- **陷阱门**：进入时不改变 IF 标志
- **使用场景**：
  - 中断门：硬件中断处理（防止中断嵌套）
  - 陷阱门：异常处理、系统调用

---

#### Q5: 什么是 8259 PIC？如何使用？

**答案要点**：
- 可编程中断控制器，管理硬件中断
- 主片 + 从片，共 15 个 IRQ（IRQ2 用于级联）
- 关键操作：
  - 初始化（ICW1-ICW4）
  - 使能/禁用中断（IMR 寄存器）
  - 发送 EOI

**项目代码**：
```c
// i8259.c
void send_eoi(uint32_t irq_num) {
    if (irq_num >= 8) {
        outb(EOI, SLAVE_8259_PORT);  // 从片 EOI
    }
    outb(EOI, MASTER_8259_PORT);     // 主片 EOI
}
```

---

### 2.2 内存管理

#### Q6: 什么是分页？为什么需要分页？

**答案要点**：
- **分页**：将物理内存和虚拟内存划分为固定大小的页（通常 4KB）
- **作用**：
  - 内存保护：进程间隔离
  - 虚拟内存：程序可以使用比物理内存更大的地址空间
  - 内存共享：多个进程共享同一物理页

**项目中的体现**：
```c
// paging.c - 内存布局
// 0-4MB:   4KB 页表映射（视频内存 0xB8000）
// 4-8MB:   4MB 大页映射（内核）
// 128MB:   用户程序虚拟地址
```

---

#### Q7: 描述虚拟地址到物理地址的转换过程？

**答案要点**：

```
32位虚拟地址：
┌────────────┬────────────┬────────────┐
│ 页目录索引  │  页表索引   │  页内偏移   │
│  (10位)    │  (10位)    │  (12位)    │
└────────────┴────────────┴────────────┘

转换过程：
1. CR3 寄存器指向页目录基址
2. 用页目录索引找到页目录项（PDE）
3. PDE 指向页表基址
4. 用页表索引找到页表项（PTE）
5. PTE 指向物理页基址
6. 物理页基址 + 页内偏移 = 物理地址
```

**项目代码**：
```c
// paging.c
void init_paging() {
    // 设置页目录项
    page_directory[0] = (uint32_t)page_table | 0x03;  // P=1, R/W=1
    page_directory[1] = 0x400000 | 0x83;  // 4MB 大页，内核

    // 设置视频内存页表项
    page_table[VIDEO >> 12] = VIDEO | 0x03;

    // 加载 CR3，启用分页
    load_page_directory(page_directory);
    enable_paging();
}
```

---

#### Q8: 什么是 Page Fault？如何处理？

**答案要点**：
- **触发条件**：
  - 访问不存在的页（Present=0）
  - 权限不足（用户态访问内核页）
  - 写只读页
- **处理**：
  - 检查错误码确定原因
  - 合法访问：分配物理页，更新页表
  - 非法访问：终止进程或发送信号

**项目代码**：
```c
// exception_handler.c
void page_fault_handler(uint32_t error_code) {
    uint32_t fault_addr;
    asm volatile("mov %%cr2, %0" : "=r"(fault_addr));
    printf("Page Fault at 0x%x, error code: %d\n", fault_addr, error_code);
    // 在教学项目中简单处理：停机
    while(1);
}
```

---

#### Q9: 4KB 页和 4MB 大页有什么区别？各自的使用场景？

**答案要点**：
- **4KB 页**：
  - 需要两级页表（页目录 + 页表）
  - 粒度细，适合小内存分配
  - 页表本身占用内存
- **4MB 大页**：
  - 只需页目录
  - 减少 TLB miss
  - 适合连续大块内存（如内核）

**项目中的使用**：
```c
// 4KB 页：视频内存映射
page_table[0xB8] = 0xB8000 | 0x03;

// 4MB 大页：内核映射
page_directory[1] = 0x400000 | 0x83;  // PS=1 表示大页
```

---

### 2.3 进程管理

#### Q10: 什么是 PCB？包含哪些信息？

**答案要点**：
- PCB（Process Control Block）：进程控制块
- 内核用于管理进程的数据结构

**项目中的 PCB**：
```c
typedef struct pcb {
    uint32_t pid;           // 进程 ID
    uint32_t parent_pid;    // 父进程 ID
    uint32_t esp;           // 内核栈指针
    uint32_t ebp;           // 基址指针
    file_descriptor_t fd_table[8];  // 文件描述符表
    uint8_t args[128];      // 命令行参数
    uint32_t active;        // 是否活跃
} pcb_t;
```

---

#### Q11: 描述 execute 系统调用的实现流程？

**答案要点**：

```
1. 解析命令（程序名 + 参数）
2. 检查文件是否存在
3. 验证 ELF 魔数（0x7f 'E' 'L' 'F'）
4. 分配进程 ID
5. 设置分页（128MB 虚拟地址映射到物理内存）
6. 加载程序到内存
7. 创建 PCB：
   - 初始化文件描述符表（stdin=0, stdout=1）
   - 保存命令行参数
   - 记录父进程 PID
8. 设置 TSS（内核栈指针）
9. 使用 IRET 切换到用户态：
   - 压入 USER_DS, 用户 ESP, EFLAGS, USER_CS, EIP
   - 执行 IRET
```

**项目代码**（简化）：
```c
int32_t execute(const uint8_t* command) {
    // 1. 解析命令
    parse_command(command, program, args);

    // 2-3. 检查文件和魔数
    if (read_dentry_by_name(program, &dentry) == -1) return -1;
    if (!check_elf_magic(program)) return -1;

    // 4-5. 分配 PID，设置分页
    pid = allocate_pid();
    setup_paging(pid);

    // 6. 加载程序
    load_program(program, PROGRAM_LOAD_ADDR);

    // 7. 创建 PCB
    pcb = get_pcb(pid);
    init_pcb(pcb, pid, args);

    // 8. 设置 TSS
    tss.esp0 = get_kernel_stack(pid);

    // 9. IRET 到用户态
    switch_to_user_mode(entry_point, user_esp);

    return 0;
}
```

---

#### Q12: 用户态和内核态有什么区别？如何切换？

**答案要点**：

| 特性 | 用户态 | 内核态 |
|------|--------|--------|
| 权限级别 | Ring 3 | Ring 0 |
| 可执行指令 | 受限 | 全部 |
| 可访问内存 | 用户空间 | 全部 |
| 中断 | 可被中断 | 可控制中断 |

**切换方式**：
- **用户态 → 内核态**：中断、异常、系统调用（int 0x80）
- **内核态 → 用户态**：IRET 指令

**项目代码**：
```asm
# 内核态 → 用户态
push USER_DS      # SS
push user_esp     # ESP
pushf             # EFLAGS
push USER_CS      # CS
push entry_point  # EIP
iret
```

---

#### Q13: 什么是上下文切换？需要保存哪些内容？

**答案要点**：
- **定义**：从一个进程切换到另一个进程，保存/恢复执行状态
- **需要保存**：
  - 通用寄存器（EAX, EBX, ECX, EDX, ESI, EDI）
  - 栈指针（ESP, EBP）
  - 指令指针（EIP，通过返回地址）
  - 段寄存器（CS, DS, SS）
  - 页表（CR3）

**项目代码**：
```c
// pit.c - 调度器
void schedule() {
    // 保存当前进程上下文
    current_pcb->esp = esp;
    current_pcb->ebp = ebp;

    // 选择下一个进程
    next_pid = get_next_process();

    // 切换页表
    set_page_directory(next_pid);

    // 切换 TSS
    tss.esp0 = get_kernel_stack(next_pid);

    // 恢复新进程上下文
    esp = next_pcb->esp;
    ebp = next_pcb->ebp;
}
```

---

### 2.4 系统调用

#### Q14: 系统调用是如何实现的？

**答案要点**：

```
用户程序:
    mov eax, syscall_number
    mov ebx, arg1
    mov ecx, arg2
    mov edx, arg3
    int 0x80              # 触发系统调用
    # 返回值在 eax

内核处理:
    1. int 0x80 触发，CPU 切换到内核态
    2. 从 IDT 找到系统调用处理程序
    3. 保存用户态寄存器
    4. 根据 eax 调用对应的系统调用函数
    5. 返回值放入 eax
    6. 恢复寄存器，IRET 返回用户态
```

**项目代码**：
```asm
# syscall.S
syscall_handler:
    pushal
    push edx    # arg3
    push ecx    # arg2
    push ebx    # arg1
    call *syscall_table(, %eax, 4)  # 调用系统调用
    add esp, 12
    mov eax_offset(%esp), eax  # 保存返回值
    popal
    iret
```

---

#### Q15: 文件描述符是什么？如何实现？

**答案要点**：
- **定义**：内核用于跟踪打开文件的索引
- **标准 fd**：0=stdin, 1=stdout, 2=stderr
- **实现**：每个进程维护一个文件描述符表

**项目代码**：
```c
typedef struct file_descriptor {
    file_operations_t* fops;    // 操作函数表
    uint32_t inode;             // inode 号
    uint32_t file_position;     // 当前读取位置
    uint32_t flags;             // 0=空闲, 1=使用中
} file_descriptor_t;

// open 系统调用
int32_t open(const uint8_t* filename) {
    // 找到空闲 fd
    for (fd = 2; fd < 8; fd++) {
        if (pcb->fd_table[fd].flags == 0) break;
    }
    // 初始化 fd
    pcb->fd_table[fd].fops = get_fops(filetype);
    pcb->fd_table[fd].flags = 1;
    pcb->fd_table[fd].file_position = 0;
    return fd;
}
```

---

### 2.5 设备驱动

#### Q16: 键盘驱动是如何实现的？

**答案要点**：

```
1. 注册 IRQ 1 中断处理程序
2. 键盘按键 → 键盘控制器产生中断
3. 中断处理程序：
   - 从端口 0x60 读取扫描码
   - 扫描码转换为 ASCII
   - 处理特殊键（Shift, Ctrl, Caps Lock）
   - 存入键盘缓冲区
   - 发送 EOI
4. terminal_read 从缓冲区读取
```

**项目代码**：
```c
// keyboard.c
void keyboard_handler() {
    uint8_t scancode = inb(KEYBOARD_PORT);

    // 处理 make/break code
    if (scancode & 0x80) {
        // 释放键
        handle_key_release(scancode & 0x7F);
    } else {
        // 按下键
        char c = scancode_to_ascii(scancode);
        if (c) {
            keyboard_buffer[buffer_index++] = c;
            putc(c);  // 回显
        }
    }

    send_eoi(KEYBOARD_IRQ);
}
```

---

#### Q17: 终端驱动的 read 和 write 是如何实现的？

**答案要点**：

**terminal_read**：
- 阻塞等待用户按 Enter
- 从键盘缓冲区复制数据到用户缓冲区
- 返回读取的字节数

**terminal_write**：
- 将数据写入视频内存
- 处理特殊字符（\n, \t）
- 处理滚屏

**项目代码**：
```c
int32_t terminal_read(int32_t fd, void* buf, int32_t nbytes) {
    // 等待 Enter
    while (!enter_pressed) { }

    // 复制数据
    int count = min(nbytes, buffer_index);
    memcpy(buf, keyboard_buffer, count);

    // 清空缓冲区
    buffer_index = 0;
    enter_pressed = 0;

    return count;
}

int32_t terminal_write(int32_t fd, const void* buf, int32_t nbytes) {
    int i;
    for (i = 0; i < nbytes; i++) {
        putc(((char*)buf)[i]);
    }
    return nbytes;
}
```

---

### 2.6 调度器

#### Q18: Round-Robin 调度算法是如何实现的？

**答案要点**：
- 每个进程分配固定时间片
- 时间片用完，切换到下一个就绪进程
- 使用 PIT 定时器产生时钟中断

**项目代码**：
```c
// pit.c
void pit_handler() {
    send_eoi(PIT_IRQ);
    schedule();
}

void schedule() {
    // 保存当前进程状态
    save_context(current_pid);

    // Round-Robin: 选择下一个进程
    do {
        next_pid = (current_pid + 1) % MAX_PROCESSES;
    } while (!process_active[next_pid]);

    // 切换到新进程
    switch_to_process(next_pid);
}
```

---

#### Q19: 如何实现多终端？

**答案要点**：

```
1. 每个终端维护独立状态：
   - 键盘缓冲区
   - 光标位置
   - 视频内存备份

2. 终端切换（Alt+Fx）：
   - 保存当前终端视频内存
   - 恢复新终端视频内存
   - 切换键盘输入目标

3. 进程与终端关系：
   - 每个进程属于一个终端
   - 终端切换不影响进程执行
```

**项目代码**：
```c
void switch_terminal(int new_term) {
    if (new_term == current_terminal) return;

    // 保存当前终端
    memcpy(terminals[current_terminal].video_mem, VIDEO_MEM, 4096);
    terminals[current_terminal].cursor_x = screen_x;
    terminals[current_terminal].cursor_y = screen_y;

    // 恢复新终端
    memcpy(VIDEO_MEM, terminals[new_term].video_mem, 4096);
    screen_x = terminals[new_term].cursor_x;
    screen_y = terminals[new_term].cursor_y;
    update_cursor();

    current_terminal = new_term;
}
```

---

## 三、综合性面试题

### Q20: 从按下键盘到屏幕显示字符，完整描述这个过程？

**完整流程**：

```
1. 硬件层：
   - 用户按下键盘按键
   - 键盘控制器产生扫描码
   - 键盘控制器向 8259 PIC 发送 IRQ 1

2. 中断处理：
   - PIC 向 CPU 发送中断信号
   - CPU 保存当前状态，查 IDT 表
   - 跳转到键盘中断处理程序

3. 键盘驱动：
   - 从端口 0x60 读取扫描码
   - 扫描码转换为 ASCII 字符
   - 字符存入键盘缓冲区
   - 调用 putc() 回显字符
   - 发送 EOI 给 PIC

4. 显示输出：
   - putc() 计算视频内存地址
   - 写入字符和属性到 0xB8000 + offset
   - 更新光标位置

5. 返回：
   - 中断处理程序执行 IRET
   - CPU 恢复之前的状态
   - 继续执行被中断的程序
```

---

### Q21: 描述一个进程从创建到终止的完整生命周期？

**完整流程**：

```
1. 创建（execute）：
   - Shell 调用 execute("program args")
   - 系统调用进入内核态
   - 解析命令，检查可执行文件
   - 分配 PID，创建 PCB
   - 设置页表，映射用户空间
   - 加载程序到内存
   - 初始化文件描述符表（stdin=0, stdout=1）
   - 设置 TSS 内核栈
   - IRET 切换到用户态，开始执行

2. 运行：
   - 进程在用户态执行
   - 系统调用（read/write/open/close）与内核交互
   - 时钟中断触发调度，可能被切换出去
   - 被调度回来继续执行

3. 终止（halt）：
   - 进程调用 halt(status)
   - 系统调用进入内核态
   - 关闭所有打开的文件
   - 释放资源（页表、PCB）
   - 恢复父进程的上下文
   - 返回到父进程的 execute 调用处
   - 父进程继续执行
```

---

### Q22: 如果让你改进这个操作系统，你会怎么做？

**可能的改进方向**：

1. **内存管理**：
   - 实现动态内存分配（malloc/free）
   - 实现写时复制（COW）
   - 实现页面置换算法

2. **进程管理**：
   - 支持更多进程（当前只支持 6 个）
   - 实现进程优先级调度
   - 实现进程间通信（管道、共享内存）

3. **文件系统**：
   - 支持写操作
   - 实现更复杂的文件系统（类似 ext2）

4. **设备驱动**：
   - 添加更多设备支持（鼠标、磁盘）
   - 实现 DMA 传输

5. **其他**：
   - 支持动态链接库
   - 实现网络协议栈
   - 实现图形界面

---

## 四、延伸问题（与 Linux 内核对比）

### Q23: 你的项目和 Linux 内核有什么不同？

| 方面 | ECE 391 项目 | Linux 内核 |
|------|-------------|-----------|
| 内存管理 | 简单分页 | 伙伴系统 + Slab |
| 调度器 | Round-Robin | CFS（完全公平调度） |
| 文件系统 | 只读、单一 | VFS + 多种文件系统 |
| 进程数 | 最多 6 个 | 理论无限 |
| 同步机制 | 几乎没有 | spinlock/mutex/RCU |
| 设备驱动 | 直接编写 | 设备模型 + 设备树 |

---

### Q24: 学完这个项目，如何过渡到 Linux 内核开发？

**建议路径**：

1. **补充同步机制**：spinlock, mutex, RCU
2. **学习 Linux 驱动框架**：platform_driver, 设备树
3. **深入内存管理**：伙伴系统, slab 分配器
4. **理解 VFS 层**：inode, dentry, file_operations
5. **阅读内核源码**：从 drivers/staging/ 开始
6. **实践**：买开发板，写真实驱动

---

## 五、常见追问及应对

### "这个项目你遇到过什么困难？"

**示例回答**：
> "在实现 execute 系统调用时，我遇到了用户态切换失败的问题。最后发现是 IRET 时栈布局不正确。我通过 GDB 单步调试，对照 Intel 手册中的栈帧格式，最终定位并解决了问题。这让我深刻理解了用户态/内核态切换的机制。"

### "你在项目中学到了什么？"

**示例回答**：
> "通过这个项目，我深入理解了操作系统的核心概念：中断处理、内存管理、进程调度。更重要的是，我学会了底层调试技巧——当 printf 都不能用时，如何用 GDB 和硬件调试。这些经验对我理解 Linux 内核很有帮助。"

### "你是怎么测试的？"

**示例回答**：
> "我们采用分层测试策略。首先对每个模块进行单元测试，比如分页测试会验证地址转换是否正确。然后进行集成测试，确保各模块协同工作。最后运行用户程序（shell、ls、cat）进行系统测试。遇到问题时，使用 QEMU + GDB 进行调试。"

---

## 六、速查表

### 关键数据结构

```c
// IDT 表项
struct idt_entry {
    uint16_t offset_15_00;
    uint16_t seg_selector;
    uint8_t  reserved;
    uint8_t  type:4;
    uint8_t  s:1;
    uint8_t  dpl:2;
    uint8_t  present:1;
    uint16_t offset_31_16;
};

// PCB
struct pcb {
    uint32_t pid, parent_pid;
    uint32_t esp, ebp;
    file_descriptor_t fd_table[8];
    uint8_t args[128];
    uint32_t active;
};

// 文件描述符
struct file_descriptor {
    file_operations_t* fops;
    uint32_t inode;
    uint32_t file_position;
    uint32_t flags;
};
```

### 关键常量

```c
#define KERNEL_CS   0x0010
#define KERNEL_DS   0x0018
#define USER_CS     0x0023
#define USER_DS     0x002B

#define VIDEO       0xB8000
#define KERNEL_BASE 0x400000
#define USER_BASE   0x08000000
```

### 系统调用号

```c
#define SYS_HALT    1
#define SYS_EXECUTE 2
#define SYS_READ    3
#define SYS_WRITE   4
#define SYS_OPEN    5
#define SYS_CLOSE   6
#define SYS_GETARGS 7
#define SYS_VIDMAP  8
```

---

> **提示**：面试时不需要背诵所有细节，重点是展示你理解原理，并能结合项目代码说明。
