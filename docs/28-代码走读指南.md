# ECE 391 代码走读指南

> 本文档指导如何系统地阅读和理解项目源代码，包括推荐阅读顺序、核心函数解析和代码风格说明。

---

## 一、推荐阅读顺序

### 1.1 总体顺序

```
阶段 1: 启动和初始化
    boot.S → kernel.c → x86_desc.h

阶段 2: 中断系统
    i8259.c → idt_init.c → interrupt_handler.S → exception_handler.c

阶段 3: 内存管理
    paging.h → paging.c

阶段 4: 设备驱动
    keyboard.c → terminal.c → rtc_handler.c

阶段 5: 文件系统
    file_system.h → file_system.c

阶段 6: 系统调用和进程
    global.h → syscall.h → syscall.S → syscall_handler.c

阶段 7: 调度器
    pit.c
```

### 1.2 按功能模块阅读

```
如果只想了解某个功能：

键盘输入 → keyboard.c + terminal.c
屏幕输出 → terminal.c + lib.c (putc/printf)
中断处理 → i8259.c + idt_init.c + interrupt_handler.S
分页机制 → paging.c
文件读取 → file_system.c
程序执行 → syscall_handler.c (execute/halt)
进程调度 → pit.c
```

---

## 二、核心文件详解

### 2.1 boot.S - 汇编入口

**位置**: `student-distrib/boot.S`

**作用**: 系统启动的第一段代码

**关键部分**:

```asm
# Multiboot 头 - GRUB 识别内核的标志
.long MULTIBOOT_HEADER_MAGIC    # 魔数
.long MULTIBOOT_HEADER_FLAGS    # 标志
.long CHECKSUM                  # 校验和

# 入口点
.globl start
start:
    # 设置栈指针
    movl $stack_top, %esp

    # 调用 C 入口
    pushl %ebx      # Multiboot 信息结构指针
    pushl %eax      # Multiboot 魔数
    call entry      # 调用 kernel.c 中的 entry()
```

**阅读要点**:
- 理解 Multiboot 协议
- 了解从汇编到 C 的过渡

---

### 2.2 kernel.c - C 语言入口

**位置**: `student-distrib/kernel.c`

**作用**: 初始化所有子系统

**关键函数**:

```c
void entry(unsigned long magic, unsigned long addr) {
    multiboot_info_t *mbi = (multiboot_info_t *)addr;

    // 清屏
    clear();

    // 1. 初始化 IDT
    idt_init();

    // 2. 初始化 PIC
    i8259_init();

    // 3. 初始化分页
    paging_init();

    // 4. 初始化设备
    keyboard_init();
    rtc_init();
    pit_init();

    // 5. 初始化文件系统
    module_t* mod = (module_t*)mbi->mods_addr;
    file_system_init((uint32_t*)mod->mod_start);

    // 6. 初始化终端
    terminal_init();

    // 7. 开中断
    sti();

    // 8. 启动 shell
    execute((uint8_t*)"shell");

    // 不应该到达这里
    while(1);
}
```

**阅读要点**:
- 初始化顺序很重要
- 理解各子系统的依赖关系

---

### 2.3 idt_init.c - IDT 初始化

**位置**: `student-distrib/idt_init.c`

**核心数据结构**:

```c
// IDT 表 (256 项)
idt_desc_t idt[NUM_VEC];

// IDT 描述符 (用于 lidt 指令)
idt_desc_ptr_t idt_desc_ptr;
```

**关键函数**:

```c
// 设置单个 IDT 表项
void set_idt_entry(int index, uint32_t handler,
                   uint16_t selector, uint8_t type, uint8_t dpl) {
    idt[index].offset_15_00 = handler & 0xFFFF;
    idt[index].offset_31_16 = (handler >> 16) & 0xFFFF;
    idt[index].seg_selector = selector;
    idt[index].reserved4 = 0;
    idt[index].reserved3 = 0;
    idt[index].reserved2 = 1;
    idt[index].reserved1 = 1;
    idt[index].size = 1;         // 32位门
    idt[index].reserved0 = 0;
    idt[index].type = type;      // 0xE=中断门, 0xF=陷阱门
    idt[index].dpl = dpl;        // 0=内核, 3=用户
    idt[index].present = 1;
}

// 初始化整个 IDT
void idt_init() {
    int i;

    // 设置异常处理 (0-19)
    set_idt_entry(0, (uint32_t)divide_error_wrapper, KERNEL_CS, 0xF, 0);
    set_idt_entry(1, (uint32_t)debug_wrapper, KERNEL_CS, 0xF, 0);
    // ... 其他异常

    // 设置硬件中断
    set_idt_entry(0x21, (uint32_t)keyboard_wrapper, KERNEL_CS, 0xE, 0);
    set_idt_entry(0x28, (uint32_t)rtc_wrapper, KERNEL_CS, 0xE, 0);
    set_idt_entry(0x20, (uint32_t)pit_wrapper, KERNEL_CS, 0xE, 0);

    // 设置系统调用 (用户可调用，DPL=3)
    set_idt_entry(0x80, (uint32_t)syscall_wrapper, KERNEL_CS, 0xF, 3);

    // 加载 IDT
    idt_desc_ptr.size = sizeof(idt) - 1;
    idt_desc_ptr.base = (uint32_t)idt;
    lidt(idt_desc_ptr);
}
```

**阅读要点**:
- 中断门 (0xE) vs 陷阱门 (0xF) 的区别
- DPL 决定谁能触发这个中断
- 中断向量号的分配规则

---

### 2.4 interrupt_handler.S - 汇编中断入口

**位置**: `student-distrib/interrupt_handler.S`

**模板结构**:

```asm
# 无错误码的异常
.macro EXCEPTION_WRAPPER name handler
.globl \name
\name:
    pushal              # 保存所有通用寄存器
    call \handler       # 调用 C 处理函数
    popal               # 恢复寄存器
    iret                # 返回
.endm

# 有错误码的异常
.macro EXCEPTION_WRAPPER_ERR name handler
.globl \name
\name:
    pushal
    call \handler
    popal
    addl $4, %esp       # 跳过错误码
    iret
.endm

# 使用宏定义所有异常处理入口
EXCEPTION_WRAPPER divide_error_wrapper divide_error_handler
EXCEPTION_WRAPPER debug_wrapper debug_handler
EXCEPTION_WRAPPER_ERR page_fault_wrapper page_fault_handler
# ... 其他异常
```

**阅读要点**:
- 有些异常有错误码，有些没有
- pushal/popal 保存和恢复寄存器
- iret 返回被中断的代码

---

### 2.5 paging.c - 分页系统

**位置**: `student-distrib/paging.c`

**核心数据结构**:

```c
// 页目录 (1024 项，每项 4 字节)
uint32_t page_directory[1024] __attribute__((aligned(4096)));

// 页表 (1024 项，每项 4 字节)
uint32_t page_table[1024] __attribute__((aligned(4096)));
```

**关键函数**:

```c
void paging_init() {
    int i;

    // 清空页目录
    for (i = 0; i < 1024; i++) {
        page_directory[i] = 0;
    }

    // 设置第一个页目录项 (0-4MB，使用 4KB 页表)
    page_directory[0] = (uint32_t)page_table | 0x03;  // P=1, R/W=1

    // 设置第二个页目录项 (4-8MB，4MB 大页，内核)
    page_directory[1] = 0x400000 | 0x83;  // P=1, R/W=1, PS=1 (4MB页)

    // 初始化页表
    for (i = 0; i < 1024; i++) {
        page_table[i] = 0;  // 默认不存在
    }

    // 映射视频内存 (0xB8000)
    page_table[0xB8000 >> 12] = 0xB8000 | 0x03;

    // 加载 CR3
    asm volatile("movl %0, %%cr3" : : "r"(page_directory));

    // 启用分页
    uint32_t cr0;
    asm volatile("movl %%cr0, %0" : "=r"(cr0));
    cr0 |= 0x80000000;  // 设置 PG 位
    asm volatile("movl %0, %%cr0" : : "r"(cr0));
}

// 为用户进程设置页表
void setup_user_page(uint32_t pid) {
    // 128MB 虚拟地址映射到进程的物理内存
    uint32_t phys_addr = 0x800000 + pid * 0x400000;
    page_directory[32] = phys_addr | 0x87;  // P=1, R/W=1, U/S=1, PS=1
    flush_tlb();
}
```

**阅读要点**:
- 页目录和页表必须 4KB 对齐
- 4MB 大页用于内核，简化映射
- 用户空间页表 U/S 位必须为 1

---

### 2.6 keyboard.c - 键盘驱动

**位置**: `student-distrib/keyboard.c`

**核心数据结构**:

```c
// 扫描码到 ASCII 映射表
static char scancode_table[128] = {
    0,  27, '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', '\b',
    '\t', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']', '\n',
    0, 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', '\'', '`',
    0, '\\', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/', 0,
    '*', 0, ' ', 0, // ... 更多
};

// 键盘状态
static int shift_pressed = 0;
static int caps_lock = 0;
static int ctrl_pressed = 0;
static int alt_pressed = 0;
```

**关键函数**:

```c
void keyboard_handler() {
    uint8_t scancode = inb(KEYBOARD_PORT);

    // 处理按键释放 (最高位为 1)
    if (scancode & 0x80) {
        scancode &= 0x7F;
        if (scancode == LEFT_SHIFT || scancode == RIGHT_SHIFT)
            shift_pressed = 0;
        else if (scancode == CTRL)
            ctrl_pressed = 0;
        else if (scancode == ALT)
            alt_pressed = 0;
        send_eoi(KEYBOARD_IRQ);
        return;
    }

    // 处理按键按下
    if (scancode == LEFT_SHIFT || scancode == RIGHT_SHIFT) {
        shift_pressed = 1;
    } else if (scancode == CAPS_LOCK) {
        caps_lock = !caps_lock;
    } else if (scancode == CTRL) {
        ctrl_pressed = 1;
    } else if (scancode == ALT) {
        alt_pressed = 1;
    } else {
        // 普通字符
        char c = scancode_to_char(scancode);
        if (c) {
            // 存入缓冲区并回显
            add_to_buffer(c);
            putc(c);
        }
    }

    send_eoi(KEYBOARD_IRQ);
}

char scancode_to_char(uint8_t scancode) {
    char c = scancode_table[scancode];

    // 处理大小写
    if (c >= 'a' && c <= 'z') {
        if (shift_pressed ^ caps_lock) {
            c = c - 'a' + 'A';
        }
    } else if (shift_pressed) {
        // 处理 shift + 数字/符号
        c = get_shift_char(c);
    }

    return c;
}
```

**阅读要点**:
- 扫描码 vs ASCII 码
- 按键按下 vs 释放的区分
- 修饰键 (Shift, Ctrl, Alt) 的处理

---

### 2.7 terminal.c - 终端驱动

**位置**: `student-distrib/terminal.c`

**核心数据结构**:

```c
// 视频内存
#define VIDEO 0xB8000
static char* video_mem = (char*)VIDEO;

// 光标位置
static int screen_x = 0;
static int screen_y = 0;

// 屏幕尺寸
#define NUM_COLS 80
#define NUM_ROWS 25
```

**关键函数**:

```c
// 输出单个字符
void putc(uint8_t c) {
    if (c == '\n' || c == '\r') {
        screen_y++;
        screen_x = 0;
    } else if (c == '\b') {
        if (screen_x > 0) {
            screen_x--;
            *(uint8_t*)(video_mem + ((NUM_COLS * screen_y + screen_x) << 1)) = ' ';
        }
    } else {
        *(uint8_t*)(video_mem + ((NUM_COLS * screen_y + screen_x) << 1)) = c;
        *(uint8_t*)(video_mem + ((NUM_COLS * screen_y + screen_x) << 1) + 1) = ATTRIB;
        screen_x++;
    }

    // 换行检查
    if (screen_x >= NUM_COLS) {
        screen_x = 0;
        screen_y++;
    }

    // 滚屏检查
    if (screen_y >= NUM_ROWS) {
        scroll();
        screen_y = NUM_ROWS - 1;
    }

    update_cursor();
}

// 终端读取
int32_t terminal_read(int32_t fd, void* buf, int32_t nbytes) {
    // 等待用户按 Enter
    while (!enter_pressed) {
        // 等待
    }

    // 复制数据
    int count = (nbytes < buffer_index) ? nbytes : buffer_index;
    memcpy(buf, keyboard_buffer, count);

    // 重置缓冲区
    buffer_index = 0;
    enter_pressed = 0;

    return count;
}

// 终端写入
int32_t terminal_write(int32_t fd, const void* buf, int32_t nbytes) {
    int i;
    char* str = (char*)buf;
    for (i = 0; i < nbytes; i++) {
        putc(str[i]);
    }
    return nbytes;
}
```

**阅读要点**:
- VGA 文本模式：每个字符占 2 字节（字符 + 属性）
- 视频内存地址计算
- 滚屏实现

---

### 2.8 file_system.c - 文件系统

**位置**: `student-distrib/file_system.c`

**核心数据结构**:

```c
// 目录项结构 (64 字节)
typedef struct dentry {
    char filename[32];      // 文件名
    uint32_t filetype;      // 0=RTC, 1=目录, 2=文件
    uint32_t inode_num;     // inode 号
    uint8_t reserved[24];
} dentry_t;

// Boot Block 结构 (4KB)
typedef struct boot_block {
    uint32_t dir_count;     // 目录项数量
    uint32_t inode_count;   // inode 数量
    uint32_t data_count;    // 数据块数量
    uint8_t reserved[52];
    dentry_t direntries[63];
} boot_block_t;

// Inode 结构 (4KB)
typedef struct inode {
    uint32_t length;            // 文件长度
    uint32_t data_blocks[1023]; // 数据块索引
} inode_t;

// 全局指针
static boot_block_t* boot_block;
```

**关键函数**:

```c
// 初始化
void file_system_init(uint32_t* fs_start) {
    boot_block = (boot_block_t*)fs_start;
}

// 通过文件名查找
int32_t read_dentry_by_name(const uint8_t* fname, dentry_t* dentry) {
    int i;
    for (i = 0; i < boot_block->dir_count; i++) {
        if (strncmp((char*)fname, boot_block->direntries[i].filename, 32) == 0) {
            memcpy(dentry, &boot_block->direntries[i], sizeof(dentry_t));
            return 0;
        }
    }
    return -1;  // 未找到
}

// 读取文件数据
int32_t read_data(uint32_t inode_num, uint32_t offset, uint8_t* buf, uint32_t length) {
    inode_t* inode = get_inode(inode_num);

    // 检查边界
    if (offset >= inode->length) return 0;
    if (offset + length > inode->length) {
        length = inode->length - offset;
    }

    // 计算起始数据块和偏移
    uint32_t start_block = offset / 4096;
    uint32_t block_offset = offset % 4096;
    uint32_t bytes_read = 0;

    while (bytes_read < length) {
        uint32_t block_idx = inode->data_blocks[start_block];
        uint8_t* data_block = get_data_block(block_idx);

        uint32_t to_read = 4096 - block_offset;
        if (bytes_read + to_read > length) {
            to_read = length - bytes_read;
        }

        memcpy(buf + bytes_read, data_block + block_offset, to_read);

        bytes_read += to_read;
        start_block++;
        block_offset = 0;
    }

    return bytes_read;
}
```

**阅读要点**:
- 文件系统布局：Boot Block → Inodes → Data Blocks
- 地址计算：每个块 4KB
- 文件名最多 32 字节

---

### 2.9 syscall_handler.c - 系统调用

**位置**: `student-distrib/syscall_handler.c`

**核心数据结构**:

```c
// PCB 结构
typedef struct pcb {
    uint32_t pid;
    uint32_t parent_pid;
    uint32_t esp;
    uint32_t ebp;
    file_descriptor_t fd_table[8];
    uint8_t args[128];
    uint32_t active;
} pcb_t;

// 文件描述符
typedef struct file_descriptor {
    file_operations_t* fops;
    uint32_t inode;
    uint32_t file_position;
    uint32_t flags;
} file_descriptor_t;

// 操作函数表
typedef struct file_operations {
    int32_t (*open)(const uint8_t*);
    int32_t (*close)(int32_t);
    int32_t (*read)(int32_t, void*, int32_t);
    int32_t (*write)(int32_t, const void*, int32_t);
} file_operations_t;
```

**关键函数 - execute**:

```c
int32_t execute(const uint8_t* command) {
    uint8_t program[32], args[128];

    // 1. 解析命令
    parse_command(command, program, args);

    // 2. 检查文件
    dentry_t dentry;
    if (read_dentry_by_name(program, &dentry) == -1) return -1;

    // 3. 读取文件头，检查 ELF 魔数
    uint8_t header[40];
    read_data(dentry.inode_num, 0, header, 40);
    if (header[0] != 0x7f || header[1] != 'E' ||
        header[2] != 'L' || header[3] != 'F') {
        return -1;
    }

    // 4. 获取入口点
    uint32_t entry_point = *(uint32_t*)(header + 24);

    // 5. 分配 PID
    int pid = allocate_pid();
    if (pid == -1) return -1;

    // 6. 设置用户空间页表
    setup_user_page(pid);

    // 7. 加载程序
    inode_t* inode = get_inode(dentry.inode_num);
    read_data(dentry.inode_num, 0, (uint8_t*)PROGRAM_LOAD_ADDR, inode->length);

    // 8. 创建 PCB
    pcb_t* pcb = get_pcb(pid);
    pcb->pid = pid;
    pcb->parent_pid = current_pid;
    strncpy((char*)pcb->args, (char*)args, 128);
    pcb->active = 1;

    // 初始化文件描述符表
    pcb->fd_table[0].fops = &terminal_fops;
    pcb->fd_table[0].flags = 1;  // stdin
    pcb->fd_table[1].fops = &terminal_fops;
    pcb->fd_table[1].flags = 1;  // stdout

    // 保存当前上下文
    asm volatile("movl %%esp, %0" : "=m"(pcb->parent_esp));
    asm volatile("movl %%ebp, %0" : "=m"(pcb->parent_ebp));

    // 9. 设置 TSS
    tss.esp0 = get_kernel_stack_top(pid);

    // 10. 更新当前 PID
    current_pid = pid;

    // 11. 切换到用户态
    uint32_t user_esp = USER_STACK_TOP;  // 0x8400000
    asm volatile(
        "cli;"
        "movw %0, %%ax;"
        "movw %%ax, %%ds;"
        "movw %%ax, %%es;"
        "movw %%ax, %%fs;"
        "movw %%ax, %%gs;"
        "pushl %0;"        // SS
        "pushl %1;"        // ESP
        "pushfl;"
        "popl %%eax;"
        "orl $0x200, %%eax;"
        "pushl %%eax;"     // EFLAGS (IF=1)
        "pushl %2;"        // CS
        "pushl %3;"        // EIP
        "iret;"
        :
        : "r"(USER_DS), "r"(user_esp), "r"(USER_CS), "r"(entry_point)
        : "eax"
    );

    return 0;  // 不会执行到这里
}
```

**关键函数 - halt**:

```c
int32_t halt(uint8_t status) {
    pcb_t* pcb = get_current_pcb();

    // 关闭所有文件
    int i;
    for (i = 2; i < 8; i++) {
        if (pcb->fd_table[i].flags) {
            close(i);
        }
    }

    // 标记进程为不活跃
    pcb->active = 0;

    // 恢复父进程
    uint32_t parent_pid = pcb->parent_pid;
    current_pid = parent_pid;

    // 恢复父进程页表
    setup_user_page(parent_pid);

    // 恢复父进程 TSS
    tss.esp0 = get_kernel_stack_top(parent_pid);

    // 恢复父进程上下文并返回
    asm volatile(
        "movl %0, %%esp;"
        "movl %1, %%ebp;"
        "movl %2, %%eax;"
        "leave;"
        "ret;"
        :
        : "r"(pcb->parent_esp), "r"(pcb->parent_ebp), "r"((uint32_t)status)
    );

    return 0;  // 不会执行到这里
}
```

**阅读要点**:
- execute 是最复杂的系统调用
- 理解用户态/内核态切换
- PCB 和文件描述符的管理

---

### 2.10 pit.c - 定时器和调度

**位置**: `student-distrib/pit.c`

**关键函数**:

```c
// PIT 初始化
void pit_init() {
    // 设置 100Hz
    uint16_t divisor = 1193180 / 100;

    outb(0x36, 0x43);  // 命令端口
    outb(divisor & 0xFF, 0x40);
    outb((divisor >> 8) & 0xFF, 0x40);

    enable_irq(PIT_IRQ);
}

// PIT 中断处理
void pit_handler() {
    send_eoi(PIT_IRQ);
    schedule();
}

// 调度器
void schedule() {
    // 如果只有一个进程，不切换
    if (get_active_process_count() <= 1) return;

    pcb_t* current = get_current_pcb();

    // 保存当前上下文
    asm volatile("movl %%esp, %0" : "=m"(current->esp));
    asm volatile("movl %%ebp, %0" : "=m"(current->ebp));

    // 选择下一个进程 (Round-Robin)
    int next_pid = current_pid;
    do {
        next_pid = (next_pid + 1) % MAX_PROCESSES;
    } while (!process_active[next_pid]);

    if (next_pid == current_pid) return;

    pcb_t* next = get_pcb(next_pid);

    // 切换页表
    setup_user_page(next_pid);

    // 切换 TSS
    tss.esp0 = get_kernel_stack_top(next_pid);

    // 更新当前 PID
    current_pid = next_pid;

    // 恢复新进程上下文
    asm volatile("movl %0, %%esp" : : "m"(next->esp));
    asm volatile("movl %0, %%ebp" : : "m"(next->ebp));
}
```

**阅读要点**:
- PIT 配置频率计算
- Round-Robin 算法实现
- 上下文切换的细节

---

## 三、函数调用链

### 3.1 系统调用链

```
用户程序调用 read(fd, buf, n)
    │
    ▼
int 0x80 (syscall.S: syscall_wrapper)
    │
    ▼
syscall_handler.c: syscall_handler
    │
    ├─► read() ──► pcb->fd_table[fd].fops->read()
    │              ├─► terminal_read()
    │              ├─► file_read()
    │              └─► rtc_read()
    │
    └─► 返回用户程序
```

### 3.2 中断处理链

```
键盘按键
    │
    ▼
IRQ 1 → 8259 PIC → CPU
    │
    ▼
IDT[0x21] → keyboard_wrapper (interrupt_handler.S)
    │
    ▼
keyboard_handler (keyboard.c)
    │
    ├─► inb(0x60) 读取扫描码
    ├─► 扫描码转 ASCII
    ├─► 存入缓冲区
    ├─► 回显 (putc)
    └─► send_eoi(1)
    │
    ▼
iret → 返回被中断的程序
```

### 3.3 进程执行链

```
shell 调用 execute("ls")
    │
    ▼
execute() (syscall_handler.c)
    │
    ├─► 解析命令
    ├─► 检查 ELF 文件
    ├─► 分配 PID
    ├─► 设置页表
    ├─► 加载程序
    ├─► 创建 PCB
    ├─► 设置 TSS
    └─► IRET → ls 程序开始执行
           │
           ▼
        ls 调用 halt(0)
           │
           ▼
        halt() (syscall_handler.c)
           │
           ├─► 关闭文件
           ├─► 恢复父进程页表
           ├─► 恢复父进程 TSS
           └─► 恢复 ESP/EBP → 返回 shell 的 execute()
                  │
                  ▼
               shell 继续执行
```

---

## 四、代码风格说明

### 4.1 命名规范

```c
// 函数名：小写下划线
void keyboard_handler();
int32_t terminal_read();

// 宏定义：大写下划线
#define KEYBOARD_IRQ  1
#define NUM_COLS      80

// 类型定义：小写下划线 + _t
typedef struct pcb pcb_t;
typedef struct dentry dentry_t;

// 全局变量：小写下划线
static int current_pid;
static boot_block_t* boot_block;
```

### 4.2 文件组织

```c
// 1. 头文件保护
#ifndef _FILE_NAME_H
#define _FILE_NAME_H

// 2. 包含其他头文件
#include "types.h"
#include "lib.h"

// 3. 宏定义
#define BUFFER_SIZE 128

// 4. 类型定义
typedef struct {...} my_struct_t;

// 5. 函数声明
void my_function();

#endif /* _FILE_NAME_H */
```

### 4.3 注释风格

```c
/*
 * 多行注释用于函数说明
 * 参数: xxx - 描述
 * 返回: xxx
 */
int32_t my_function(int32_t param) {
    // 单行注释用于代码说明
    do_something();

    /* 也可以用这种 */
    do_another_thing();

    return 0;
}
```

---

## 五、快速参考

### 5.1 重要常量

```c
// 段选择子
KERNEL_CS = 0x0010
KERNEL_DS = 0x0018
USER_CS   = 0x0023
USER_DS   = 0x002B

// 内存地址
VIDEO     = 0xB8000
KERNEL    = 0x400000 (4MB)
USER_PROG = 0x08000000 (128MB)
USER_STACK = 0x08400000 (132MB)

// 中断号
KEYBOARD_IRQ = 1
RTC_IRQ      = 8
PIT_IRQ      = 0
SYSCALL_VEC  = 0x80

// 系统调用号
SYS_HALT    = 1
SYS_EXECUTE = 2
SYS_READ    = 3
SYS_WRITE   = 4
SYS_OPEN    = 5
SYS_CLOSE   = 6
SYS_GETARGS = 7
SYS_VIDMAP  = 8
```

### 5.2 常用函数

```c
// lib.c
void printf(char* fmt, ...);
void putc(char c);
void clear();
void* memcpy(void* dest, const void* src, uint32_t n);
void* memset(void* s, int c, uint32_t n);
int32_t strlen(const char* s);
int32_t strncmp(const char* s1, const char* s2, uint32_t n);
uint8_t inb(uint16_t port);
void outb(uint8_t data, uint16_t port);

// paging.c
void paging_init();
void setup_user_page(uint32_t pid);
void flush_tlb();

// i8259.c
void i8259_init();
void enable_irq(uint32_t irq_num);
void disable_irq(uint32_t irq_num);
void send_eoi(uint32_t irq_num);
```

---

## 六、调试时常看的位置

```
出问题时优先检查：

1. 系统启动崩溃 → boot.S, kernel.c, idt_init.c
2. 键盘不响应 → keyboard.c, i8259.c
3. Page Fault → paging.c, 检查页表设置
4. 程序无法执行 → syscall_handler.c (execute)
5. 程序无法退出 → syscall_handler.c (halt)
6. 调度不工作 → pit.c
7. 文件读取错误 → file_system.c
```

---

> 阅读代码是理解系统的最好方式。建议边读代码边画图，特别是内存布局和函数调用关系。
