# ECE 391 调试实战案例集

> 本文档收集了项目开发过程中常见的 bug 和调试方法，帮助你快速定位和解决问题。

---

## 一、调试环境搭建

### 1.1 QEMU + GDB 调试

```bash
# 终端 1: 启动 QEMU（调试模式）
qemu-system-i386 -hda mp3.img -m 256 -s -S

# 终端 2: 启动 GDB
gdb
(gdb) target remote localhost:1234
(gdb) symbol-file student-distrib/kernel
(gdb) break kernel_main
(gdb) continue
```

### 1.2 常用 GDB 命令

```bash
# 断点
break function_name      # 函数断点
break file.c:123         # 行断点
break *0x401000          # 地址断点
info breakpoints         # 查看断点
delete 1                 # 删除断点

# 执行控制
continue (c)             # 继续执行
step (s)                 # 单步进入
next (n)                 # 单步跳过
finish                   # 执行到函数返回
stepi                    # 单步执行一条指令

# 查看信息
print variable           # 打印变量
print/x variable         # 十六进制打印
x/10x $esp               # 查看栈内容
info registers           # 查看寄存器
backtrace (bt)           # 查看调用栈

# 内存查看
x/10i $eip               # 查看当前指令
x/10x address            # 查看内存
x/s address              # 查看字符串
```

### 1.3 printf 调试

```c
// 在 lib.c 中有 printf 实现
// 可以在任何地方添加调试输出

// 调试宏（可选）
#define DEBUG 1

#if DEBUG
#define DBG_PRINT(fmt, ...) printf("[DEBUG] " fmt, ##__VA_ARGS__)
#else
#define DBG_PRINT(fmt, ...)
#endif

// 使用示例
DBG_PRINT("keyboard scancode: 0x%x\n", scancode);
```

---

## 二、Checkpoint 1 常见问题

### 案例 1: 系统启动后立即三重故障 (Triple Fault)

**现象**：QEMU 不断重启

**原因分析**：
1. IDT 没有正确初始化
2. 分页配置错误
3. GDT 配置错误

**调试步骤**：

```bash
# 1. 在 kernel.c 入口处打断点
(gdb) break entry
(gdb) continue

# 2. 单步执行，观察在哪一步崩溃
(gdb) next
(gdb) next
...

# 3. 检查 IDT 是否正确加载
(gdb) x/2x &idt_desc_ptr
# 应该看到: 基址和限制

# 4. 检查 CR3（页目录地址）
(gdb) print/x $cr3
# 应该是页目录的物理地址
```

**常见错误**：

```c
// 错误 1: IDT 表项偏移地址设置错误
idt[i].offset_15_00 = handler;           // 错误：只取了低 16 位
idt[i].offset_15_00 = handler & 0xFFFF;  // 正确

// 错误 2: 页目录没有对齐到 4KB
uint32_t page_directory[1024];            // 可能没对齐
uint32_t page_directory[1024] __attribute__((aligned(4096)));  // 正确

// 错误 3: 没有启用分页
// 确保设置 CR0 的 PG 位
asm volatile(
    "movl %%cr0, %%eax;"
    "orl $0x80000000, %%eax;"  // 设置 PG 位
    "movl %%eax, %%cr0;"
    ::: "eax"
);
```

---

### 案例 2: Page Fault (页错误)

**现象**：打印 "Page Fault" 后停机

**调试步骤**：

```bash
# 1. 在 page_fault_handler 打断点
(gdb) break page_fault_handler

# 2. 查看 CR2（故障地址）
(gdb) print/x $cr2

# 3. 查看错误码
(gdb) x/x $esp+4
# 错误码解释:
#   bit 0: P (0=不存在, 1=保护违规)
#   bit 1: W/R (0=读, 1=写)
#   bit 2: U/S (0=内核, 1=用户)
```

**常见错误**：

```c
// 错误 1: 视频内存没有映射
// CR2 = 0xB8000
// 解决: 确保页表中映射了视频内存
page_table[0xB8000 >> 12] = 0xB8000 | 0x03;

// 错误 2: 访问了未映射的地址
// 解决: 检查是哪个指针为空或越界

// 错误 3: 权限问题（用户访问内核页）
// 解决: 检查页表项的 U/S 位
```

**分页验证代码**：

```c
// 在 paging.c 中添加验证函数
void verify_paging() {
    // 测试视频内存访问
    char* video = (char*)0xB8000;
    char old = *video;
    *video = 'X';       // 如果没 Page Fault 说明映射正确
    *video = old;

    // 测试内核地址访问
    char* kernel = (char*)0x400000;
    old = *kernel;
    printf("Paging verification passed!\n");
}
```

---

### 案例 3: 除零异常处理不工作

**现象**：执行除零后没有打印异常信息，或系统崩溃

**调试步骤**：

```bash
# 1. 检查 IDT[0] 是否设置
(gdb) x/2x &idt[0]
# 检查 offset 是否指向正确的处理函数

# 2. 在异常处理函数打断点
(gdb) break divide_error_handler

# 3. 触发除零
# 在代码中添加: int x = 1 / 0;
```

**常见错误**：

```c
// 错误 1: IDT 表项类型设置错误
idt[0].type = 0xE;  // 中断门，会关中断
idt[0].type = 0xF;  // 陷阱门，推荐用于异常

// 错误 2: 汇编包装没有正确调用 C 函数
// interrupt_handler.S 中检查:
divide_error_wrapper:
    pushal                  # 保存寄存器
    call divide_error_handler  # 调用 C 函数
    popal                   # 恢复寄存器
    iret                    # 返回

// 错误 3: C 函数名不匹配
// 确保汇编中调用的函数名和 C 中定义的一致
```

---

## 三、Checkpoint 2 常见问题

### 案例 4: 键盘输入无响应

**现象**：按键后屏幕无输出

**调试步骤**：

```bash
# 1. 确认键盘中断是否触发
(gdb) break keyboard_handler
# 按键，看是否断在这里

# 2. 如果没触发，检查 PIC 配置
(gdb) break i8259_init
# 单步检查 ICW1-ICW4 发送

# 3. 检查 IRQ 1 是否使能
# 在 enable_irq 后打印 IMR
```

**常见错误**：

```c
// 错误 1: 没有使能 IRQ 1
enable_irq(KEYBOARD_IRQ);  // 确保调用了这个

// 错误 2: 没有发送 EOI
void keyboard_handler() {
    uint8_t scancode = inb(0x60);
    // 处理按键...
    send_eoi(KEYBOARD_IRQ);  // 必须发送 EOI！
}

// 错误 3: PIC 初始化错误
// 检查 ICW1-ICW4 的值
void i8259_init() {
    // ICW1: 边沿触发，级联，需要 ICW4
    outb(ICW1, MASTER_8259_PORT);
    outb(ICW1, SLAVE_8259_PORT);

    // ICW2: 中断向量偏移
    outb(ICW2_MASTER, MASTER_8259_DATA);  // 主片从 0x20 开始
    outb(ICW2_SLAVE, SLAVE_8259_DATA);    // 从片从 0x28 开始

    // ICW3: 级联配置
    outb(ICW3_MASTER, MASTER_8259_DATA);  // 主片 IRQ2 连从片
    outb(ICW3_SLAVE, SLAVE_8259_DATA);    // 从片连到主片 IRQ2

    // ICW4: 8086 模式
    outb(ICW4, MASTER_8259_DATA);
    outb(ICW4, SLAVE_8259_DATA);
}

// 错误 4: 扫描码转换错误
// 打印扫描码检查
printf("scancode: 0x%x\n", scancode);
```

---

### 案例 5: RTC 中断不触发

**现象**：rtc_read() 永远阻塞

**调试步骤**：

```bash
# 1. 检查 RTC 中断处理函数是否被调用
(gdb) break rtc_handler

# 2. 如果没调用，检查 IRQ 8 是否使能
# 注意 RTC 是从片的 IRQ 0，即 IRQ 8

# 3. 检查 RTC 寄存器配置
```

**常见错误**：

```c
// 错误 1: 没有使能从片和 IRQ 8
enable_irq(2);           // 必须先使能级联 (IRQ 2)
enable_irq(RTC_IRQ);     // 然后使能 RTC (IRQ 8)

// 错误 2: 没有正确配置 RTC 寄存器
void rtc_init() {
    outb(0x8B, 0x70);              // 选择寄存器 B，禁用 NMI
    char prev = inb(0x71);          // 读取当前值
    outb(0x8B, 0x70);
    outb(prev | 0x40, 0x71);        // 设置 PIE 位
}

// 错误 3: 没有读取寄存器 C
// RTC 中断后必须读取寄存器 C，否则不会产生下一次中断
void rtc_handler() {
    outb(0x0C, 0x70);       // 选择寄存器 C
    inb(0x71);              // 读取并丢弃（清除中断标志）
    rtc_interrupt_flag = 1;
    send_eoi(RTC_IRQ);
}
```

---

### 案例 6: terminal_read 读取异常

**现象**：读取的数据不正确或读取字节数错误

**调试步骤**：

```c
// 添加调试输出
int32_t terminal_read(int32_t fd, void* buf, int32_t nbytes) {
    printf("[DEBUG] terminal_read: nbytes=%d, buffer_index=%d\n",
           nbytes, buffer_index);

    // 等待 Enter
    while (!enter_pressed) {}

    int count = (nbytes < buffer_index) ? nbytes : buffer_index;
    printf("[DEBUG] copying %d bytes\n", count);

    memcpy(buf, keyboard_buffer, count);

    // 重置
    buffer_index = 0;
    enter_pressed = 0;

    return count;
}
```

**常见错误**：

```c
// 错误 1: 换行符处理
// 注意：换行符也要计入读取的字节数

// 错误 2: 128 字节限制
// 缓冲区最多 128 字节，包括换行符
if (buffer_index >= 127) {
    // 缓冲区满，忽略新输入（但可以接受 Enter）
}

// 错误 3: 并发问题
// 键盘中断可能在读取过程中修改缓冲区
// 简单解决：关中断
cli();
memcpy(buf, keyboard_buffer, count);
sti();
```

---

## 四、Checkpoint 3 常见问题

### 案例 7: 文件系统读取失败

**现象**：读取文件返回 -1 或数据错误

**调试步骤**：

```c
// 打印文件系统初始化信息
void file_system_init(uint32_t* fs_start) {
    boot_block = (boot_block_t*)fs_start;
    printf("[DEBUG] boot_block at 0x%x\n", (uint32_t)boot_block);
    printf("[DEBUG] dir_count: %d\n", boot_block->dir_count);
    printf("[DEBUG] inode_count: %d\n", boot_block->inode_count);
    printf("[DEBUG] data_count: %d\n", boot_block->data_count);
}

// 打印目录项
void debug_list_files() {
    int i;
    for (i = 0; i < boot_block->dir_count; i++) {
        dentry_t* d = &boot_block->direntries[i];
        printf("[%d] name=%.32s type=%d inode=%d\n",
               i, d->filename, d->filetype, d->inode_num);
    }
}
```

**常见错误**：

```c
// 错误 1: 文件系统基址错误
// 文件系统镜像是作为 Multiboot 模块加载的
// 在 kernel.c 中正确获取地址:
void entry(uint32_t magic, multiboot_info_t* mbi) {
    module_t* mod = (module_t*)mbi->mods_addr;
    uint32_t fs_start = mod->mod_start;
    file_system_init((uint32_t*)fs_start);
}

// 错误 2: inode 地址计算错误
inode_t* get_inode(uint32_t index) {
    // inode 区域从 boot_block 后面开始，每个 inode 4KB
    return (inode_t*)((uint32_t)boot_block + (index + 1) * 4096);
}

// 错误 3: 数据块地址计算错误
uint8_t* get_data_block(uint32_t index) {
    // 数据块在所有 inode 之后
    uint32_t inode_count = boot_block->inode_count;
    return (uint8_t*)((uint32_t)boot_block +
                      (1 + inode_count + index) * 4096);
}

// 错误 4: 文件名比较问题
// 文件名最多 32 字节，不一定有 null 结尾
int filename_match(const char* name1, const char* name2) {
    return strncmp(name1, name2, 32) == 0;
}
```

---

### 案例 8: execute 系统调用失败

**现象**：shell 无法启动程序，或程序启动后崩溃

**调试步骤**：

```bash
# 1. 在 execute 函数打断点
(gdb) break execute

# 2. 检查 ELF 魔数
(gdb) x/4xb program_data
# 应该看到: 0x7f 0x45 0x4c 0x46 ("\x7fELF")

# 3. 检查入口点
(gdb) x/x program_data+24
# 这是程序的入口地址

# 4. 检查页表设置
(gdb) x/x &page_directory[32]
# 128MB 对应页目录项 32 (128/4 = 32)
```

**常见错误**：

```c
// 错误 1: ELF 魔数检查
uint8_t magic[4] = {0x7f, 'E', 'L', 'F'};
if (memcmp(program_data, magic, 4) != 0) {
    return -1;  // 不是有效的可执行文件
}

// 错误 2: 入口点读取（小端序）
uint32_t entry_point = *(uint32_t*)(program_data + 24);

// 错误 3: 用户空间页表设置
// 128MB 虚拟地址映射到进程的物理内存
void setup_user_page(uint32_t pid) {
    uint32_t phys_addr = 0x800000 + pid * 0x400000;  // 8MB + pid*4MB
    page_directory[32] = phys_addr | 0x87;
    // 0x87 = Present | R/W | User | 4MB page
    flush_tlb();
}

// 错误 4: 程序加载地址
// 程序应该加载到虚拟地址 0x08048000
#define PROGRAM_LOAD_ADDR 0x08048000
memcpy((void*)PROGRAM_LOAD_ADDR, program_data, program_size);

// 错误 5: IRET 栈设置错误
void switch_to_user_mode(uint32_t entry, uint32_t user_esp) {
    asm volatile(
        "cli;"
        "mov %0, %%eax;"
        "mov %%ax, %%ds;"
        "mov %%ax, %%es;"
        "mov %%ax, %%fs;"
        "mov %%ax, %%gs;"
        "pushl %0;"      // USER_DS (SS)
        "pushl %1;"      // user_esp (ESP)
        "pushfl;"        // EFLAGS
        "popl %%eax;"
        "orl $0x200, %%eax;"  // 设置 IF 位
        "pushl %%eax;"
        "pushl %2;"      // USER_CS (CS)
        "pushl %3;"      // entry (EIP)
        "iret;"
        :
        : "r"(USER_DS), "r"(user_esp), "r"(USER_CS), "r"(entry)
        : "eax"
    );
}
```

---

### 案例 9: halt 返回父进程失败

**现象**：halt 后系统崩溃或返回值错误

**调试步骤**：

```bash
# 1. 检查 PCB 中保存的父进程信息
(gdb) print *current_pcb

# 2. 检查返回时的栈状态
(gdb) x/10x $esp

# 3. 在 halt 返回点设置断点
```

**常见错误**：

```c
// 错误 1: 没有正确保存父进程上下文
// 在 execute 中，切换到子进程前保存
int32_t execute(...) {
    // 保存当前 ESP/EBP，供 halt 时恢复
    asm volatile("movl %%esp, %0" : "=r"(parent_esp));
    asm volatile("movl %%ebp, %0" : "=r"(parent_ebp));
    child_pcb->parent_esp = parent_esp;
    child_pcb->parent_ebp = parent_ebp;
    ...
}

// 错误 2: 没有恢复父进程页表
int32_t halt(uint8_t status) {
    pcb_t* pcb = get_current_pcb();

    // 恢复父进程页表
    setup_user_page(pcb->parent_pid);

    // 恢复父进程 TSS
    tss.esp0 = get_kernel_stack_top(pcb->parent_pid);

    // 恢复父进程上下文并返回
    asm volatile(
        "movl %0, %%esp;"
        "movl %1, %%ebp;"
        "movl %2, %%eax;"
        "leave;"
        "ret;"
        :
        : "r"(pcb->parent_esp), "r"(pcb->parent_ebp), "r"((uint32_t)status)
    );
    return 0;  // 不会执行到这里
}
```

---

## 五、Checkpoint 4/5 常见问题

### 案例 10: 终端切换显示错误

**现象**：切换终端后显示内容混乱

**调试步骤**：

```c
// 添加调试输出
void switch_terminal(int new_term) {
    printf("[DEBUG] switch from %d to %d\n", current_terminal, new_term);

    // 保存前打印当前终端状态
    printf("[DEBUG] saving term %d: cursor=(%d,%d)\n",
           current_terminal,
           terminals[current_terminal].cursor_x,
           terminals[current_terminal].cursor_y);

    // ...切换逻辑...

    // 恢复后打印新终端状态
    printf("[DEBUG] restored term %d: cursor=(%d,%d)\n",
           new_term, screen_x, screen_y);
}
```

**常见错误**：

```c
// 错误 1: 视频内存备份大小错误
// VGA 文本模式: 80 * 25 * 2 = 4000 字节
// 但通常分配 4KB (4096 字节) 以便对齐
memcpy(terminals[old].video_backup, (void*)VIDEO, 4096);
memcpy((void*)VIDEO, terminals[new].video_backup, 4096);

// 错误 2: 键盘缓冲区没有隔离
// 每个终端需要独立的键盘缓冲区
void keyboard_handler() {
    // 将字符存入当前终端的缓冲区
    terminals[current_terminal].kb_buffer[
        terminals[current_terminal].buffer_index++
    ] = c;
}

// 错误 3: 切换时没有更新光标
void switch_terminal(int new_term) {
    ...
    screen_x = terminals[new_term].cursor_x;
    screen_y = terminals[new_term].cursor_y;
    update_cursor();  // 别忘了更新硬件光标
}
```

---

### 案例 11: 调度器死锁

**现象**：系统停止响应，或只有一个进程运行

**调试步骤**：

```bash
# 1. 检查 PIT 中断是否触发
(gdb) break pit_handler

# 2. 检查调度函数
(gdb) break schedule

# 3. 打印进程状态
```

**常见错误**：

```c
// 错误 1: 没有就绪进程
void schedule() {
    int next_pid = current_pid;
    int count = 0;

    do {
        next_pid = (next_pid + 1) % MAX_PROCESSES;
        count++;
        if (count > MAX_PROCESSES) {
            // 没有就绪进程，保持当前进程
            return;
        }
    } while (!process_active[next_pid]);

    if (next_pid == current_pid) return;  // 只有一个进程

    switch_to(next_pid);
}

// 错误 2: 上下文切换不完整
void switch_to(int next_pid) {
    pcb_t* current = get_pcb(current_pid);
    pcb_t* next = get_pcb(next_pid);

    // 保存当前上下文
    asm volatile("movl %%esp, %0" : "=m"(current->esp));
    asm volatile("movl %%ebp, %0" : "=m"(current->ebp));

    // 切换页表
    setup_user_page(next_pid);

    // 切换 TSS
    tss.esp0 = get_kernel_stack_top(next_pid);

    current_pid = next_pid;

    // 恢复新上下文
    asm volatile("movl %0, %%esp" : : "m"(next->esp));
    asm volatile("movl %0, %%ebp" : : "m"(next->ebp));
}

// 错误 3: PIT 频率设置错误
void pit_init() {
    // 设置 100Hz (每 10ms 一次中断)
    uint16_t divisor = 1193180 / 100;  // ≈ 11932

    outb(0x36, 0x43);                   // 命令: 通道0, 方波
    outb(divisor & 0xFF, 0x40);         // 低字节
    outb((divisor >> 8) & 0xFF, 0x40);  // 高字节

    enable_irq(PIT_IRQ);
}
```

---

## 六、通用调试技巧

### 6.1 栈追踪

```c
// 手动栈追踪
void print_stack_trace() {
    uint32_t* ebp;
    asm volatile("movl %%ebp, %0" : "=r"(ebp));

    printf("Stack trace:\n");
    int i;
    for (i = 0; i < 10 && ebp != NULL; i++) {
        uint32_t eip = *(ebp + 1);  // 返回地址
        printf("  [%d] EIP: 0x%x\n", i, eip);
        ebp = (uint32_t*)*ebp;      // 上一个帧的 EBP
    }
}
```

### 6.2 寄存器转储

```c
void dump_registers() {
    uint32_t eax, ebx, ecx, edx, esi, edi, ebp, esp, eflags;

    asm volatile(
        "movl %%eax, %0;"
        "movl %%ebx, %1;"
        "movl %%ecx, %2;"
        "movl %%edx, %3;"
        "movl %%esi, %4;"
        "movl %%edi, %5;"
        "movl %%ebp, %6;"
        "movl %%esp, %7;"
        "pushfl; popl %8;"
        : "=m"(eax), "=m"(ebx), "=m"(ecx), "=m"(edx),
          "=m"(esi), "=m"(edi), "=m"(ebp), "=m"(esp), "=m"(eflags)
    );

    printf("EAX=%08x EBX=%08x ECX=%08x EDX=%08x\n", eax, ebx, ecx, edx);
    printf("ESI=%08x EDI=%08x EBP=%08x ESP=%08x\n", esi, edi, ebp, esp);
    printf("EFLAGS=%08x\n", eflags);
}
```

### 6.3 内存转储

```c
void hex_dump(void* addr, int len) {
    uint8_t* p = (uint8_t*)addr;
    int i;
    for (i = 0; i < len; i++) {
        if (i % 16 == 0) printf("%08x: ", (uint32_t)(p + i));
        printf("%02x ", p[i]);
        if (i % 16 == 15) printf("\n");
    }
    if (len % 16 != 0) printf("\n");
}
```

### 6.4 断言

```c
#define ASSERT(condition) do { \
    if (!(condition)) { \
        printf("ASSERT FAILED: %s\n", #condition); \
        printf("  File: %s, Line: %d\n", __FILE__, __LINE__); \
        while(1); \
    } \
} while(0)

// 使用示例
ASSERT(fd >= 0 && fd < 8);
ASSERT(pcb != NULL);
```

---

## 七、常见错误检查清单

### 7.1 Checkpoint 1 检查清单

- [ ] IDT 256 个表项都初始化了吗？
- [ ] 异常处理程序都注册了吗（0-19，跳过15）？
- [ ] 系统调用入口 (0x80) DPL 设为 3 了吗？
- [ ] 页目录和页表 4KB 对齐了吗？
- [ ] 视频内存 (0xB8000) 映射了吗？
- [ ] 内核 (4-8MB) 映射了吗？
- [ ] CR3 加载了页目录地址吗？
- [ ] CR0 的 PG 位设置了吗？

### 7.2 Checkpoint 2 检查清单

- [ ] PIC ICW1-ICW4 都正确发送了吗？
- [ ] IRQ 1 (键盘) 和 IRQ 8 (RTC) 使能了吗？
- [ ] IRQ 2 (级联) 使能了吗？
- [ ] 中断处理后发送 EOI 了吗？
- [ ] RTC 中断后读取寄存器 C 了吗？
- [ ] terminal_read 正确处理换行符了吗？
- [ ] 键盘缓冲区 128 字节限制处理了吗？

### 7.3 Checkpoint 3 检查清单

- [ ] 文件系统基址正确获取了吗？
- [ ] inode 和数据块地址计算正确吗？
- [ ] ELF 魔数正确检查了吗？
- [ ] 用户空间页表 (128MB) 设置了吗？
- [ ] 程序加载到正确地址 (0x08048000) 了吗？
- [ ] IRET 栈正确设置了吗？
- [ ] PCB 文件描述符表初始化了吗（stdin/stdout）？
- [ ] halt 正确恢复父进程了吗？

### 7.4 Checkpoint 4/5 检查清单

- [ ] 每个终端有独立的缓冲区吗？
- [ ] 视频内存备份/恢复正确吗？
- [ ] 光标位置保存/恢复了吗？
- [ ] PIT 频率设置正确吗？
- [ ] 调度器处理了无就绪进程的情况吗？
- [ ] 上下文切换保存/恢复了所有必要状态吗？

---

> **调试的关键**：缩小问题范围，二分法定位，打印关键状态。当 printf 都不能用时，用 GDB 单步执行。
