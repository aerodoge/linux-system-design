# 终端驱动深度解析

## 概述

终端驱动是连接用户和操作系统的桥梁。它负责：

1. 从键盘读取用户输入 (`terminal_read`)
2. 将程序输出显示到屏幕 (`terminal_write`)
3. 管理多个终端的切换

## 终端架构

### 单终端模型

```
┌─────────────┐      ┌─────────────┐      ┌─────────────┐
│   用户程序   │      │   终端驱动   │      │    显存     │
│   (shell)   │ ──── │  terminal.c │ ──── │  0xB8000   │
└─────────────┘      └─────────────┘      └─────────────┘
       │                    │
       │   terminal_read    │   keyboard_buffer
       │◄───────────────────┤◄───────────────────────────┐
       │                    │                            │
       │   terminal_write   │                      ┌─────────────┐
       │────────────────────┤                      │   键盘驱动   │
       │                    ▼                      │ keyboard.c  │
                       putc()/puts()               └─────────────┘
```

### 多终端模型

```
                ┌─────────────────────────────────────────────────────┐
                │                    物理显存                          │
                │                   0xB8000                           │
                └─────────────────────────────────────────────────────┘
                              ▲
                              │ (只有当前终端直接写入)
                              │
    ┌─────────────────────────┼─────────────────────────┐
    │                         │                         │
    ▼                         ▼                         ▼
┌─────────┐             ┌─────────┐             ┌─────────┐
│ 终端 0   │             │ 终端 1   │             │ 终端 2   │
│ 0xB9000 │◄── backup   │ 0xBA000 │◄── backup   │ 0xBB000 │◄── backup
│ (shell) │             │ (shell) │             │ (shell) │
└─────────┘             └─────────┘             └─────────┘
```

## 核心数据结构

### term_info 结构体

```c
typedef struct {
    uint32_t term_id;           // 终端 ID (0, 1, 2)
    int32_t running_pid;        // 该终端运行的进程 PID
    uint32_t cursor_x;          // 光标 X 坐标 (0-79)
    uint32_t cursor_y;          // 光标 Y 坐标 (0-24)
    int cursor_location;        // 显存中的光标位置 (字节偏移)

    uint8_t* vid_backup;        // 显存备份地址
    unsigned int len_key_buf;   // 键盘缓冲区长度
    int has_enter;              // 是否按下了 Enter
    char term_key_buf[128];     // 键盘缓冲区备份
    char term_last_buf[128];    // 上一条命令备份

    uint16_t ss0;               // 内核栈段选择子
    uint32_t esp0;              // 内核栈指针
    uint32_t rtc_freq;          // RTC 虚拟频率
} term_info;

term_info term[3];  // 三个终端实例
```

### 全局变量

```c
int current_location = 0;                    // 当前光标在显存中的位置
uint8_t* video_pointer = (uint8_t*) VIDEO;   // 显存指针 (0xB8000)
char keyboard_buffer[128];                   // 键盘缓冲区
volatile unsigned int length_key = 0;        // 缓冲区长度

uint32_t curr_term;    // 当前显示的终端 (用户看到的)
uint32_t running_term; // 当前运行的终端 (CPU 执行的)
```

### curr_term vs running_term

这是多终端设计中的关键概念：

| 变量           | 含义        | 例子             |
|--------------|-----------|----------------|
| curr_term    | 用户看到的终端   | 屏幕显示终端 1 的内容   |
| running_term | CPU 执行的终端 | 时间片轮转到终端 2 的进程 |

```
场景：用户在终端 1，但调度器切换到终端 2 的进程

curr_term = 1      (屏幕显示终端 1)
running_term = 2   (CPU 执行终端 2 的进程)

这时终端 2 的输出应该写到 0xBA000 (备份区)，
而不是 0xB8000 (物理显存)，否则会干扰终端 1 的显示！
```

## 终端读写操作

### terminal_open / terminal_close

```c
int32_t terminal_open(const uint8_t* filename) {
    clear();                           // 清屏
    update_cursor(current_location/2); // 设置光标
    return 0;
}

int32_t terminal_close(int32_t fd) {
    clear();
    return 0;
}
```

### terminal_read - 行缓冲读取

```c
int32_t terminal_read(int32_t fd, void* buf, int32_t nbytes) {
    if (buf == NULL) return -1;

    // 1. 阻塞等待用户按下 Enter
    read_buffer();  // 内部: while(has_enter == 0) {}

    // 2. 复制键盘缓冲区到用户缓冲区
    int8_t* buffer = (int8_t*) buf;
    int i;
    for(i = 0; i < nbytes; i++) {
        if(i < length_key)
            buffer[i] = keyboard_buffer[i];
    }

    // 3. 返回实际读取的字节数
    if(length_key < nbytes) {
        i = length_key;
    }

    // 4. 清空键盘缓冲区
    clear_keyboard_buffer();

    return (int32_t)i;
}
```

**行缓冲机制**：

```
用户输入: l s Enter
         ↓ ↓   ↓
键盘缓冲: ['l', 's', '\n', ...]
                    │
                    └── Enter 触发 has_enter = 1
                              │
                              ▼
terminal_read() 解除阻塞，返回 "ls\n"
```

### terminal_write - 屏幕输出

```c
int32_t terminal_write(int32_t fd, const void* buf, int32_t nbytes) {
    if (buf == NULL) return -1;

    int8_t* buffer = (int8_t*) buf;

    // 关键判断：当前运行的终端是否是显示的终端？
    if (running_term == curr_term) {
        // 直接写入物理显存
        for(int i = 0; i < nbytes; i++) {
            putc(buffer[i]);
        }
    } else {
        // 写入该终端的备份区
        for(int i = 0; i < nbytes; i++) {
            putc_term(buffer[i], running_term);
        }
    }

    return i + 1;
}
```

**为什么需要区分？**

```
用户看终端1，但 CPU 执行终端2 的程序

如果终端2的输出直接写 0xB8000：
┌──────────────────────────────────────┐
│ 391OS> ls                            │ ← 终端1的内容
│ hello  world  test                   │ ← 终端2的输出覆盖了！
│ 391OS>                               │
└──────────────────────────────────────┘

正确做法：终端2写到 0xBA000 备份区：
┌──────────────────────────────────────┐
│ 391OS> cat readme.txt                │ ← 终端1不受干扰
│ This is terminal 1                   │
│ 391OS>                               │
└──────────────────────────────────────┘
```

## 多终端实现

### 显存布局

```
物理内存布局:
┌─────────────────────┐ 0xB8000
│  物理显存 (4KB)      │ ← 用户实际看到的
├─────────────────────┤ 0xB9000
│  终端0 备份 (4KB)    │ VIDEOA
├─────────────────────┤ 0xBA000
│  终端1 备份 (4KB)    │ VIDEOB
├─────────────────────┤ 0xBB000
│  终端2 备份 (4KB)    │ VIDEOC
└─────────────────────┘ 0xBC000

每个备份区大小: 80 × 25 × 2 = 4000 字节 < 4KB
```

### 终端初始化

```c
int32_t init_term() {
    // 1. 设置终端 ID
    term[0].term_id = 0;
    term[1].term_id = 1;
    term[2].term_id = 2;

    // 2. 分配显存备份地址
    term[0].vid_backup = (uint8_t*) VIDEOA;  // 0xB9000
    term[1].vid_backup = (uint8_t*) VIDEOB;  // 0xBA000
    term[2].vid_backup = (uint8_t*) VIDEOC;  // 0xBB000

    // 3. 初始化每个终端的状态
    for (int i = 0; i < 3; i++) {
        term[i].cursor_location = 0;
        term[i].cursor_x = 0;
        term[i].cursor_y = 0;
        clear_backup(i);                      // 清空显存备份
        term[i].len_key_buf = 0;
        clear_keyboard_backup(i);             // 清空键盘缓冲区
        term[i].has_enter = 0;
        term[i].rtc_freq = MAX_RTC_FREQ;
    }

    // 4. 启动第一个终端
    curr_term = 0;
    restore_term_info(0);
    return execute((uint8_t*) "shell");       // 启动 shell
}
```

### 终端切换 - launch_term

```c
int32_t launch_term(uint32_t term_id) {
    cli();  // 关中断，防止切换过程被打断

    // 1. 已经在目标终端？
    if (term_id == curr_term) {
        sti();
        return 0;
    }

    // 2. 目标终端是否是第一次启动？
    if (term[term_id].running_pid == -1) {
        // 第一次启动，需要创建新 shell
        switch_terminal(curr_term, term_id);

        // 保存当前进程的 ESP/EBP
        pcb_t* old_pcb = get_specific_pcb(term[running_term].running_pid);
        curr_term = term_id;
        asm volatile(
            "movl %%ebp, %%eax \n\
             movl %%esp, %%ebx"
            : "=a"(old_pcb->curr_ebp), "=b"(old_pcb->curr_esp)
        );

        sti();
        execute((uint8_t*) "shell");  // 启动新 shell

    } else {
        // 已有进程，只需切换显示
        if (switch_terminal(curr_term, term_id) != 0) {
            sti();
            return -1;
        }
        curr_term = term_id;

        // 重新映射视频内存
        uint8_t* screen_start;
        vidmap(&screen_start);
        if (running_term != curr_term) {
            remap_vid((int32_t)screen_start, (int32_t)term[running_term].vid_backup);
        }

        sti();
    }
    return 0;
}
```

### 保存终端状态 - save_term_info

```c
int32_t save_term_info(uint32_t old_term) {
    // 保存光标位置
    term[old_term].cursor_x = screen_x;
    term[old_term].cursor_y = screen_y;
    term[old_term].cursor_location = current_location;

    // 保存键盘缓冲区
    term[old_term].len_key_buf = length_key;
    clear_keyboard_backup(old_term);
    memcpy(term[old_term].term_key_buf, keyboard_buffer, KEYBOARD_BUFFER_SIZE);
    clear_keyboard_buffer();

    // 保存显存内容
    memcpy(term[old_term].vid_backup, (uint8_t*) VIDEO, SCREEN_SIZE);

    return 0;
}
```

### 恢复终端状态 - restore_term_info

```c
int32_t restore_term_info(uint32_t new_term) {
    // 恢复光标位置
    screen_x = term[new_term].cursor_x;
    screen_y = term[new_term].cursor_y;
    current_location = term[new_term].cursor_location;
    update_cursor(current_location/2);

    // 恢复键盘缓冲区
    length_key = term[new_term].len_key_buf;
    memcpy(keyboard_buffer, term[new_term].term_key_buf, KEYBOARD_BUFFER_SIZE);

    // 恢复显存内容
    memcpy((uint8_t*) VIDEO, term[new_term].vid_backup, SCREEN_SIZE);

    return 0;
}
```

## 终端切换流程图

```
用户按下 Alt+F2
        │
        ▼
keyboard_interrupt_handler()
        │
        ├── 检测 Alt+F2
        │
        └── 返回 2 ──────────> launch_term(1)  // F2 对应终端 1
                                    │
                                    ▼
                          ┌─────────────────────┐
                          │ term_id == curr_term? │
                          └─────────────────────┘
                                    │
                    ┌───────────────┴───────────────┐
                    │ No                            │ Yes
                    ▼                               ▼
          ┌─────────────────┐              直接返回 (无需切换)
          │ running_pid == -1? │
          └─────────────────┘
                    │
        ┌───────────┴───────────┐
        │ Yes                   │ No
        ▼                       ▼
   首次启动终端            switch_terminal()
        │                       │
        ├── save_term_info()    ├── save_term_info()
        │                       │
        ├── 保存当前 ESP/EBP    ├── restore_term_info()
        │                       │
        ├── execute("shell")    └── 重新映射视频内存
        │
        └── restore_term_info()
```

## 视频内存管理

### 显存结构

```c
#define VIDEO       0xB8000   // 物理显存起始地址
#define SCREEN_SIZE 4000      // 80 × 25 × 2 字节

// 每个字符占 2 字节
// [字符][属性] [字符][属性] ...
//   偶数位置     奇数位置
```

### 视频内存映射 (vidmap)

用户程序可能需要直接访问显存（如 fish 演示程序）：

```c
// 系统调用: vidmap
// 将显存映射到用户空间的虚拟地址

用户程序视角:
┌─────────────────────────────────────────┐
│ 虚拟地址空间                             │
│                                         │
│ 0x08000000  程序代码/数据                │
│ ...                                     │
│ 0x08400000  用户栈                       │
│ ...                                     │
│ 0x08800000  视频内存 ← vidmap 返回这里   │
└─────────────────────────────────────────┘
        │
        │ 页表映射
        ▼
┌─────────────────────────────────────────┐
│ 物理地址                                 │
│ 0xB8000  物理显存                        │
└─────────────────────────────────────────┘
```

### 多终端视频内存重映射

当 `running_term != curr_term` 时：

```c
// running_term 的输出应该写到备份区，而不是物理显存
if (running_term != curr_term) {
    // 将用户程序的虚拟显存地址重新映射到备份区
    remap_vid((int32_t)screen_start, (int32_t)term[running_term].vid_backup);
}
```

```
重映射前 (running_term == curr_term):
用户虚拟地址 0x08800000 → 物理地址 0xB8000 (直接显示)

重映射后 (running_term != curr_term):
用户虚拟地址 0x08800000 → 物理地址 0xBA000 (写入备份区)
```

## 与其他组件的交互

### 与键盘驱动的交互

```
keyboard.c                          terminal.c
    │                                   │
    │  keyboard_buffer[128]             │
    │  length_key                       │
    │  has_enter                        │
    │◄──────────────────────────────────┤
    │                                   │
    │  keyboard_interrupt_handler()     │
    │        │                          │
    │        ▼                          │
    │  process_char()                   │
    │        │                          │
    │        ├── Enter: has_enter = 1   │
    │        │              │           │
    │        │              ▼           │
    │        │     terminal_read() ─────┤
    │        │     解除阻塞              │
    │        │                          │
    │        └── 普通字符:              │
    │            keyboard_buffer[i] = c │
```

### 与进程调度的交互

```
调度器 (scheduler)                   终端驱动
    │                                   │
    │  时间片到期                        │
    │  切换到另一个终端的进程             │
    │        │                          │
    │        ▼                          │
    │  running_term = new_term          │
    │        │                          │
    │        │  terminal_write() 检查:  │
    │        │  if (running_term !=     │
    │        │      curr_term)          │
    │        │        │                 │
    │        │        ▼                 │
    │        │  写入 vid_backup         │
    │        │  而不是 VIDEO            │
```

## 常见问题解答

### Q1: 为什么 terminal_read 要用 while 循环等待？

```c
void read_buffer() {
    while(term[running_term].has_enter == 0) {}
    term[running_term].has_enter = 0;
}
```

这是**轮询 (polling)** 方式实现的阻塞。更好的实现是使用**睡眠/唤醒**机制，但这个简单版本足够教学使用。

### Q2: 为什么 terminal_write 返回 i+1 而不是 i？

```c
return i + 1;  // 应该是 return i; 或 return nbytes;
```

这可能是一个 bug。正确的实现应该返回实际写入的字节数。

### Q3: 三个终端能同时运行程序吗？

**可以！** 这就是 `curr_term` 和 `running_term` 分离的意义：

- 用户只能看一个终端 (`curr_term`)
- 但三个终端的进程都在被调度执行 (`running_term` 在三个终端间轮转)

### Q4: 切换终端时，原来终端的程序会暂停吗？

**不会暂停！** 切换终端只是切换显示，不影响进程调度。调度器继续轮流执行三个终端的进程。

### Q5: 为什么保存/恢复时要用 memcpy？

```c
memcpy(term[old_term].vid_backup, (uint8_t*) VIDEO, SCREEN_SIZE);
```

显存是 4000 字节，使用 memcpy 进行整块复制比逐字节复制更高效。

## 终端驱动完整流程

```
系统启动
    │
    ▼
init_term()
    │
    ├── 初始化 term[0], term[1], term[2]
    │
    ├── curr_term = 0
    │
    └── execute("shell")  // 终端0启动shell
              │
              ▼
用户在终端0操作
    │
    ├── 输入命令: terminal_read() 等待 Enter
    │
    ├── 显示输出: terminal_write() 写入显存
    │
    └── 按 Alt+F2: launch_term(1)
              │
              ▼
切换到终端1
    │
    ├── save_term_info(0)    // 保存终端0状态
    │
    ├── restore_term_info(1) // 恢复终端1状态
    │
    ├── curr_term = 1
    │
    └── 如果终端1是首次启动:
            │
            └── execute("shell")  // 终端1启动shell
```

## 总结

终端驱动的核心职责：

| 功能     | 实现                                         |
|--------|--------------------------------------------|
| 读取用户输入 | `terminal_read()` 从 `keyboard_buffer` 读取   |
| 显示程序输出 | `terminal_write()` 调用 `putc()` 写入显存        |
| 行缓冲    | `has_enter` 标志 + `read_buffer()` 阻塞        |
| 多终端切换  | `launch_term()` + `switch_terminal()`      |
| 状态保存恢复 | `save_term_info()` / `restore_term_info()` |
| 显存隔离   | `vid_backup` + `curr_term/running_term` 判断 |
