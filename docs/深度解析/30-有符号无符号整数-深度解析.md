# 有符号与无符号整数 - 深度解析

## 核心问题

当我们在 C 语言中定义一个有符号整数 `int x = -1;`，从 CPU 角度看，寄存器和内存中只是一串二进制位 `0xFFFFFFFF`。那么，"有符号"还是"无符号"是由什么决定的？

**答案：由使用的机器指令决定。**

数据本身没有类型标记，类型是对二进制的**解释约定**，通过编译器选择不同的指令来实现这种解释。

---

## 1. 二进制补码表示法

现代计算机使用**补码（Two's Complement）** 表示有符号整数，这是一个精妙的设计。

### 1.1 为什么用补码？

**核心优势：加法器可以通用！**

无论有符号还是无符号，加法的电路逻辑完全相同：

```
  11111111 (-1 或 255)
+ 00000001 (1)
----------
 100000000 → 溢出丢弃高位 → 00000000 (0 或 256 mod 256 = 0)
```

这意味着 CPU 的加法单元（ALU）不需要知道操作数是否有符号。

### 1.2 8 位整数的表示范围

```
无符号范围：0 ~ 255
有符号范围：-128 ~ 127

二进制        无符号    有符号
00000000      0         0
00000001      1         1
01111111      127       127
10000000      128       -128    ← 分界点
10000001      129       -127
11111110      254       -2
11111111      255       -1
```

### 1.3 补码的计算方法

对于 n 位有符号整数，负数 `-x` 的补码表示：

```
方法1：取反加一
-x = ~x + 1

方法2：2^n - x
-1 的 8 位补码 = 2^8 - 1 = 256 - 1 = 255 = 0xFF
```

**验证：**
```
-1 的二进制：11111111
取反：       00000000
加一：       00000001 = 1

所以 11111111 确实代表 -1
```

---

## 2. CPU 指令层面的详细区别

### 2.1 加减法：指令相同

```asm
ADD  EAX, EBX    ; 有符号、无符号都用这条指令
SUB  EAX, EBX    ; 同上
```

因为补码的特性，加减法不需要区分。这是补码设计的精妙之处。

### 2.2 乘法：指令不同

```asm
; 无符号乘法
MUL  EBX         ; EDX:EAX = EAX * EBX (无符号)

; 有符号乘法
IMUL EBX         ; EDX:EAX = EAX * EBX (有符号)
```

**为什么乘法要区分？**

```
8位示例：0xFF × 0xFF

无符号：255 × 255 = 65025 = 0xFE01
有符号：(-1) × (-1) = 1 = 0x0001

结果完全不同！
```

**原因分析：**

乘法会产生更宽的结果（8位 × 8位 = 16位），符号位的处理方式不同：
- 无符号：直接按位乘，高位补零
- 有符号：需要考虑符号扩展

### 2.3 除法：指令不同

```asm
; 无符号除法
DIV  EBX         ; EAX = EDX:EAX / EBX, EDX = 余数

; 有符号除法
IDIV EBX         ; 同上，但按有符号处理
```

**实例对比：**

```
0xFFFFFFFE / 2

无符号：4294967294 / 2 = 2147483647 = 0x7FFFFFFF
有符号：(-2) / 2 = -1 = 0xFFFFFFFF
```

### 2.4 右移：指令不同

```asm
; 逻辑右移（无符号）：高位补 0
SHR  EAX, 4      ; 0xF0000000 >> 4 = 0x0F000000

; 算术右移（有符号）：高位补符号位
SAR  EAX, 4      ; 0xF0000000 >> 4 = 0xFF000000
```

**C 语言示例：**

```c
unsigned int u = 0xF0000000;
int s = 0xF0000000;  // 即 -268435456

u >> 4;  // 结果：0x0F000000 (251658240)  - 逻辑右移
s >> 4;  // 结果：0xFF000000 (-16777216)  - 算术右移，符号保持
```

**注意：** 左移（SHL/SAL）对有符号和无符号是相同的，因为低位都是补 0。

### 2.5 比较与条件跳转

比较指令 `CMP` 本身是通用的（实际上就是做减法并设置标志位），但**条件跳转指令**不同：

```asm
CMP  EAX, EBX    ; 计算 EAX - EBX，设置标志位

; 无符号条件跳转
JA   label       ; Jump if Above      (无符号 >)
JAE  label       ; Jump if Above or Equal
JB   label       ; Jump if Below      (无符号 <)
JBE  label       ; Jump if Below or Equal

; 有符号条件跳转
JG   label       ; Jump if Greater    (有符号 >)
JGE  label       ; Jump if Greater or Equal
JL   label       ; Jump if Less       (有符号 <)
JLE  label       ; Jump if Less or Equal

; 通用（相等/不相等）
JE   label       ; Jump if Equal      (ZF=1)
JNE  label       ; Jump if Not Equal  (ZF=0)
```

**实例分析：**

```
比较 0xFF 和 0x01

无符号视角：255 > 1   → JA 会跳转，JB 不跳转
有符号视角：-1 < 1    → JG 不跳转，JL 会跳转
```

---

## 3. 标志寄存器（FLAGS）的作用

CPU 执行运算后，会设置状态标志位，供后续条件判断使用。

### 3.1 关键标志位

```
EFLAGS 寄存器中的关键标志：

┌────┬─────────────────┬────────────────────────────────┐
│ 位 │ 标志            │ 含义                           │
├────┼─────────────────┼────────────────────────────────┤
│ 0  │ CF (Carry)      │ 进位标志，用于无符号溢出检测     │
│ 6  │ ZF (Zero)       │ 零标志，结果是否为 0            │
│ 7  │ SF (Sign)       │ 符号标志，结果的最高位          │
│ 11 │ OF (Overflow)   │ 溢出标志，用于有符号溢出检测     │
└────┴─────────────────┴────────────────────────────────┘
```

### 3.2 CF vs OF：无符号 vs 有符号溢出

这是理解有符号/无符号区别的关键！

**示例 1：无符号溢出，有符号不溢出**

```asm
MOV  AL, 0xFF    ; AL = 255 (无符号) 或 -1 (有符号)
ADD  AL, 0x01    ; 结果 0x00

; 此时标志位：
; CF = 1 （无符号角度：255 + 1 = 256，超出 8 位范围，溢出）
; OF = 0 （有符号角度：-1 + 1 = 0，结果正确，没溢出）
; ZF = 1 （结果为 0）
; SF = 0 （结果最高位为 0）
```

**示例 2：有符号溢出，无符号不溢出**

```asm
MOV  AL, 0x7F    ; AL = 127 (有符号最大正数)
ADD  AL, 0x01    ; 结果 0x80 = 128 (无符号) 或 -128 (有符号)

; 此时标志位：
; CF = 0 （无符号角度：127 + 1 = 128，在范围内，没溢出）
; OF = 1 （有符号角度：127 + 1 本应是 128，但变成了 -128，溢出）
; ZF = 0 （结果非 0）
; SF = 1 （结果最高位为 1）
```

### 3.3 条件跳转如何利用标志位

```
无符号比较（基于 CF 和 ZF）：
JA  (Above)          : CF=0 且 ZF=0
JAE (Above or Equal) : CF=0
JB  (Below)          : CF=1
JBE (Below or Equal) : CF=1 或 ZF=1

有符号比较（基于 SF、OF 和 ZF）：
JG  (Greater)           : ZF=0 且 SF=OF
JGE (Greater or Equal)  : SF=OF
JL  (Less)              : SF≠OF
JLE (Less or Equal)     : ZF=1 或 SF≠OF
```

**为什么 JG 检查 SF=OF？**

- 如果没有溢出（OF=0）：SF 直接反映大小关系
  - SF=0（正）表示 A-B > 0，即 A > B
  - SF=1（负）表示 A-B < 0，即 A < B

- 如果有溢出（OF=1）：SF 的含义反转
  - 正溢出变负：实际是大，但 SF=1
  - 负溢出变正：实际是小，但 SF=0

所以 `SF=OF` 等价于"实际大于"。

---

## 4. 类型扩展：零扩展 vs 符号扩展

当把小类型转换为大类型时，需要填充高位。

### 4.1 零扩展（无符号）

```asm
MOVZX EAX, AL    ; 8位 → 32位，高位补 0

; AL = 0xFF (255)
; 扩展后 EAX = 0x000000FF (255)
```

### 4.2 符号扩展（有符号）

```asm
MOVSX EAX, AL    ; 8位 → 32位，高位补符号位

; AL = 0xFF (-1)
; 扩展后 EAX = 0xFFFFFFFF (-1)
```

### 4.3 C 语言中的隐式转换

```c
unsigned char uc = 0xFF;
signed char sc = 0xFF;  // 即 -1

unsigned int u = uc;    // u = 255      (零扩展)
int s = sc;             // s = -1       (符号扩展)

printf("u = %u\n", u);  // 输出：255
printf("s = %d\n", s);  // 输出：-1
```

### 4.4 除法前的扩展

在执行 32 位除法前，被除数需要扩展到 64 位（EDX:EAX）：

```asm
; 无符号除法前：零扩展
XOR  EDX, EDX        ; EDX = 0
DIV  EBX

; 有符号除法前：符号扩展
CDQ                  ; 将 EAX 符号扩展到 EDX:EAX
IDIV EBX
```

---

## 5. 编译器的角色

编译器根据变量的类型声明，选择正确的机器指令。

### 5.1 除法编译示例

```c
// 源代码
int a = -6;
int b = 2;
int c = a / b;          // 有符号除法

unsigned int x = 0xFFFFFFFA;  // 4294967290
unsigned int y = 2;
unsigned int z = x / y;       // 无符号除法
```

**编译后（简化）：**

```asm
; 有符号除法
mov  eax, -6         ; eax = 0xFFFFFFFA
cdq                  ; 符号扩展到 edx:eax
mov  ebx, 2
idiv ebx             ; 有符号除法
; 结果：eax = -3 (0xFFFFFFFD)

; 无符号除法
mov  eax, 0xFFFFFFFA
xor  edx, edx        ; edx = 0（零扩展）
mov  ebx, 2
div  ebx             ; 无符号除法
; 结果：eax = 2147483645 (0x7FFFFFFD)
```

### 5.2 比较编译示例

```c
int a = -1;
unsigned int b = 1;

if (a < 0)   // 有符号比较
if (b > 0)   // 无符号比较
```

**编译后：**

```asm
; if (a < 0)  有符号
cmp  eax, 0
jl   true_branch     ; Jump if Less (有符号)

; if (b > 0)  无符号
cmp  ebx, 0
ja   true_branch     ; Jump if Above (无符号)
```

### 5.3 混合类型的危险

```c
int a = -1;
unsigned int b = 1;

if (a < b) {
    printf("a < b\n");
} else {
    printf("a >= b\n");  // 实际执行这个！
}
```

**为什么？**

当有符号和无符号混合比较时，C 语言会将有符号数转换为无符号数：

```
a = -1 转换为无符号 = 0xFFFFFFFF = 4294967295
比较：4294967295 > 1
所以 a >= b
```

这是一个常见的 bug 来源！

---

## 6. 实际验证程序

```c
#include <stdio.h>

int main() {
    // 相同的二进制位模式
    unsigned int u = 0xFFFFFFFF;
    int s = 0xFFFFFFFF;  // 或直接写 -1

    printf("=== 存储相同，解释不同 ===\n");
    printf("无符号: %u\n", u);      // 4294967295
    printf("有符号: %d\n", s);      // -1

    printf("\n=== 比较运算 ===\n");
    printf("u > 0: %d\n", u > 0);   // 1 (true)
    printf("s > 0: %d\n", s > 0);   // 0 (false)

    printf("\n=== 除法运算 ===\n");
    printf("u / 2 = %u\n", u / 2);  // 2147483647
    printf("s / 2 = %d\n", s / 2);  // 0 (即 -1 / 2，向零取整)

    printf("\n=== 右移运算 ===\n");
    printf("u >> 1 = 0x%08X (%u)\n", u >> 1, u >> 1);  // 0x7FFFFFFF
    printf("s >> 1 = 0x%08X (%d)\n", s >> 1, s >> 1);  // 0xFFFFFFFF (-1)

    printf("\n=== 类型转换 ===\n");
    signed char sc = 0xFF;  // -1
    unsigned char uc = 0xFF;  // 255
    printf("signed char 0xFF 扩展到 int: %d\n", (int)sc);   // -1
    printf("unsigned char 0xFF 扩展到 int: %d\n", (int)uc); // 255

    printf("\n=== 混合比较陷阱 ===\n");
    int neg = -1;
    unsigned int pos = 1;
    printf("-1 < 1u ? %d\n", neg < pos);  // 0 (false!)
    // 因为 -1 被转换为 unsigned: 0xFFFFFFFF > 1

    return 0;
}
```

---

## 7. x86 指令速查表

### 7.1 算术运算指令

| 操作 | 无符号指令 | 有符号指令 | 区别 |
|------|-----------|-----------|------|
| 加法 | ADD | ADD | 相同 |
| 减法 | SUB | SUB | 相同 |
| 乘法 | MUL | IMUL | 不同 |
| 除法 | DIV | IDIV | 不同 |
| 取模 | DIV (余数在 EDX) | IDIV (余数在 EDX) | 不同 |

### 7.2 移位指令

| 操作 | 无符号指令 | 有符号指令 | 区别 |
|------|-----------|-----------|------|
| 左移 | SHL | SAL | 相同（都补 0） |
| 右移 | SHR | SAR | 不同（补 0 vs 补符号位） |

### 7.3 比较跳转指令

| 关系 | 无符号 | 有符号 | 检查的标志 |
|------|--------|--------|-----------|
| > | JA | JG | CF=0,ZF=0 / SF=OF,ZF=0 |
| >= | JAE | JGE | CF=0 / SF=OF |
| < | JB | JL | CF=1 / SF≠OF |
| <= | JBE | JLE | CF=1或ZF=1 / SF≠OF或ZF=1 |
| = | JE | JE | ZF=1 |
| ≠ | JNE | JNE | ZF=0 |

### 7.4 扩展指令

| 操作 | 无符号 | 有符号 |
|------|--------|--------|
| 8→16/32 | MOVZX | MOVSX |
| 16→32 | MOVZX | MOVSX / CWDE |
| 32→64 (EDX:EAX) | XOR EDX,EDX | CDQ |

---

## 8. 总结

### 8.1 层次关系图

```
┌─────────────────────────────────────────────────────────────────┐
│                        高级语言层                                │
│                   int x;  vs  unsigned int x;                   │
└─────────────────────────────────┬───────────────────────────────┘
                                  │ 编译器根据类型选择指令
                                  ▼
┌─────────────────────────────────────────────────────────────────┐
│                        机器指令层                                │
│  ┌─────────────┐                    ┌─────────────┐             │
│  │  有符号指令  │                    │  无符号指令  │             │
│  │  IMUL, IDIV │                    │  MUL, DIV   │             │
│  │  SAR        │                    │  SHR        │             │
│  │  MOVSX      │                    │  MOVZX      │             │
│  │  JG, JL     │                    │  JA, JB     │             │
│  └─────────────┘                    └─────────────┘             │
└─────────────────────────────────┬───────────────────────────────┘
                                  │ 运算结果设置标志位
                                  ▼
┌─────────────────────────────────────────────────────────────────┐
│                       标志寄存器层                               │
│         CF (无符号溢出)    OF (有符号溢出)    SF    ZF           │
└─────────────────────────────────┬───────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────┐
│                     寄存器/内存层                                │
│                                                                 │
│              0xFFFFFFFF  ← 只是二进制，无类型概念                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 8.2 核心要点

| 方面 | 说明 |
|------|------|
| 存储 | 完全相同，都是二进制位 |
| 加减法 | 指令相同（补码的优势） |
| 乘除法 | 指令不同（MUL/IMUL, DIV/IDIV） |
| 右移 | 指令不同（SHR 补0 / SAR 补符号位） |
| 比较跳转 | 指令不同（JA/JB vs JG/JL） |
| 类型扩展 | 方式不同（MOVZX 零扩展 / MOVSX 符号扩展） |
| 溢出检测 | 标志不同（CF 无符号 / OF 有符号） |
| 决定者 | 编译器根据类型选择指令 |

### 8.3 核心理念

**数据本身没有类型，类型是对二进制的解释约定，通过选择不同的指令来实现这种解释。**

同一个二进制数 `0xFFFFFFFF`：
- 用 `DIV` 处理，它是 4294967295
- 用 `IDIV` 处理，它是 -1
- 用 `JA` 判断，它比 0 大
- 用 `JG` 判断，它比 0 小

CPU 不知道也不关心"类型"，它只是忠实地执行指令。类型系统是编译器和程序员之间的约定，编译器负责将这种约定翻译成正确的机器指令。

---

## 参考资料

- Intel 64 and IA-32 Architectures Software Developer's Manual
- Computer Systems: A Programmer's Perspective (CSAPP)
- x86 Assembly Language Reference Manual
