# 术语表与速查表

## 术语表 (Glossary)

### A

| 术语 | 英文 | 解释 |
|-----|------|------|
| 地址转换 | Address Translation | 将虚拟地址转换为物理地址的过程 |
| ASM | Assembly | 汇编语言 |

### B

| 术语 | 英文 | 解释 |
|-----|------|------|
| 引导加载程序 | Bootloader | 加载操作系统内核的程序，本项目使用 GRUB |
| BSS | Block Started by Symbol | 未初始化的全局变量段 |
| 缓冲区 | Buffer | 临时存储数据的内存区域 |

### C

| 术语 | 英文 | 解释 |
|-----|------|------|
| CLI | Clear Interrupt Flag | 关闭中断指令 |
| 上下文切换 | Context Switch | 保存当前进程状态，恢复另一进程状态 |
| CPL | Current Privilege Level | 当前代码的特权级 (0-3) |
| CR0/CR3/CR4 | Control Register | CPU 控制寄存器 |

### D

| 术语 | 英文 | 解释 |
|-----|------|------|
| Dentry | Directory Entry | 目录项，存储文件名和 inode 号 |
| 描述符 | Descriptor | 描述段或门的 8 字节数据结构 |
| DPL | Descriptor Privilege Level | 描述符中的特权级字段 |

### E

| 术语 | 英文 | 解释 |
|-----|------|------|
| EFLAGS | Extended Flags | 标志寄存器，包含 IF、PF 等标志 |
| EIP | Extended Instruction Pointer | 指令指针寄存器 |
| EOI | End of Interrupt | 中断结束信号，发送给 PIC |
| ESP | Extended Stack Pointer | 栈指针寄存器 |
| 异常 | Exception | CPU 内部产生的中断（除零、页错误等） |

### F

| 术语 | 英文 | 解释 |
|-----|------|------|
| 故障 | Fault | 可恢复的异常，返回时重新执行引发异常的指令 |
| FD | File Descriptor | 文件描述符，进程访问文件的句柄 |
| FS | File System | 文件系统 |

### G

| 术语 | 英文 | 解释 |
|-----|------|------|
| GDT | Global Descriptor Table | 全局描述符表，存储段描述符 |
| GDTR | GDT Register | 存储 GDT 基地址和限长的寄存器 |
| GPF | General Protection Fault | 通用保护错误，异常 13 |

### H

| 术语 | 英文 | 解释 |
|-----|------|------|
| 硬件中断 | Hardware Interrupt | 由外部设备触发的中断 (IRQ) |
| HLT | Halt | 停止 CPU 执行直到下一个中断 |

### I

| 术语 | 英文 | 解释 |
|-----|------|------|
| ICW | Initialization Command Word | PIC 初始化命令字 |
| IDT | Interrupt Descriptor Table | 中断描述符表 |
| IDTR | IDT Register | 存储 IDT 基地址和限长的寄存器 |
| IF | Interrupt Flag | 中断标志位，控制是否响应中断 |
| Inode | Index Node | 索引节点，存储文件元数据 |
| IRQ | Interrupt Request | 中断请求线 (0-15) |
| IRET | Interrupt Return | 中断返回指令 |

### K

| 术语 | 英文 | 解释 |
|-----|------|------|
| 内核 | Kernel | 操作系统核心，运行在 Ring 0 |
| 内核栈 | Kernel Stack | 进程在内核态使用的栈 |

### L

| 术语 | 英文 | 解释 |
|-----|------|------|
| LDT | Local Descriptor Table | 本地描述符表（本项目未使用） |
| LIDT | Load IDT | 加载 IDT 寄存器的指令 |
| 链接器 | Linker | 将目标文件链接成可执行文件的工具 |

### M

| 术语 | 英文 | 解释 |
|-----|------|------|
| 魔数 | Magic Number | 用于标识文件类型或检测内存损坏的特殊值 |
| MMU | Memory Management Unit | 内存管理单元，执行地址转换 |

### O

| 术语 | 英文 | 解释 |
|-----|------|------|
| OCW | Operation Command Word | PIC 操作命令字 |
| 操作表 | Operations Table | 函数指针表，实现多态文件操作 |

### P

| 术语 | 英文 | 解释 |
|-----|------|------|
| PCB | Process Control Block | 进程控制块，存储进程状态 |
| PDE | Page Directory Entry | 页目录项 |
| PIC | Programmable Interrupt Controller | 可编程中断控制器 (i8259) |
| PID | Process ID | 进程标识符 |
| PIT | Programmable Interval Timer | 可编程间隔定时器 (i8253/8254) |
| 分页 | Paging | 将内存分成固定大小页面的内存管理方式 |
| PTE | Page Table Entry | 页表项 |
| 特权级 | Privilege Level | CPU 保护级别 (Ring 0-3) |

### R

| 术语 | 英文 | 解释 |
|-----|------|------|
| Ring | Protection Ring | 保护环，Ring 0 最高权限 |
| RTC | Real-Time Clock | 实时时钟 |
| 轮转调度 | Round-Robin | 时间片轮转调度算法 |
| RPL | Requested Privilege Level | 请求特权级 |

### S

| 术语 | 英文 | 解释 |
|-----|------|------|
| 扫描码 | Scan Code | 键盘发送的按键编码 |
| 调度器 | Scheduler | 决定哪个进程运行的内核组件 |
| 段 | Segment | 内存的逻辑划分 |
| Shell | | 命令行解释器程序 |
| STI | Set Interrupt Flag | 开启中断指令 |
| 系统调用 | System Call | 用户程序请求内核服务的接口 |

### T

| 术语 | 英文 | 解释 |
|-----|------|------|
| TLB | Translation Lookaside Buffer | 页表缓存 |
| 陷阱 | Trap | 不可恢复的异常，返回到下一条指令 |
| 陷阱门 | Trap Gate | 不自动关中断的 IDT 门描述符 |
| TSS | Task State Segment | 任务状态段，存储 SS0:ESP0 |

### U

| 术语 | 英文 | 解释 |
|-----|------|------|
| 用户态 | User Mode | Ring 3 运行模式 |
| 用户栈 | User Stack | 进程在用户态使用的栈 |

### V

| 术语 | 英文 | 解释 |
|-----|------|------|
| 虚拟地址 | Virtual Address | 程序看到的地址，需转换为物理地址 |
| 显存 | Video Memory | 显示内存，0xB8000 |
| VGA | Video Graphics Array | 视频图形阵列 |

---

## 速查表 (Quick Reference)

### 内存地址速查

| 地址 | 用途 |
|-----|------|
| `0x00000000` - `0x003FFFFF` | 内核空间 (0-4MB) |
| `0x00400000` - `0x007FFFFF` | 内核空间 (4-8MB) |
| `0x000B8000` | 文本模式显存 |
| `0x000B9000` | 终端 0 视频备份 |
| `0x000BA000` | 终端 1 视频备份 |
| `0x000BB000` | 终端 2 视频备份 |
| `0x00800000` - `0x00BFFFFF` | 用户程序物理内存 (进程 0) |
| `0x08000000` | 用户程序虚拟地址起始 (128MB) |
| `0x08048000` | 用户程序加载地址 |
| `0x083FFFFC` | 用户栈底 (132MB - 4) |

### 进程内存布局

```
内核空间 (8MB):
┌─────────────────┐ 0x800000 (8MB)
│ 内核栈 0 (8KB)   │
│   PCB[0] 在底部  │
├─────────────────┤ 0x7FE000
│ 内核栈 1 (8KB)   │
│   PCB[1] 在底部  │
├─────────────────┤ 0x7FC000
│      ...        │
├─────────────────┤
│ 内核栈 5 (8KB)   │
│   PCB[5] 在底部  │
├─────────────────┤ 0x7F4000
│ 内核代码/数据    │
└─────────────────┘ 0x400000 (4MB)

用户空间 (虚拟地址):
┌─────────────────┐ 0x8400000 (132MB)
│ 用户栈 (向下增长) │
│                 │
├─────────────────┤ 0x8048000
│ 用户程序代码/数据 │
└─────────────────┘ 0x8000000 (128MB)
```

### PCB 地址计算

```c
// PCB 地址 = 8MB - (pid + 1) * 8KB
pcb_t* get_pcb(int pid) {
    return (pcb_t*)(0x800000 - (pid + 1) * 0x2000);
}

// 从 ESP 获取当前 PCB
pcb_t* get_current_pcb() {
    uint32_t esp;
    asm volatile("movl %%esp, %0" : "=r"(esp));
    return (pcb_t*)(esp & 0xFFFFE000);  // 按 8KB 对齐
}
```

### 中断向量号

| 向量号 | 类型 | 描述 |
|-------|------|------|
| 0x00 | 异常 | 除零错误 |
| 0x01 | 异常 | 调试异常 |
| 0x02 | 异常 | NMI |
| 0x03 | 异常 | 断点 |
| 0x04 | 异常 | 溢出 |
| 0x05 | 异常 | 边界检查 |
| 0x06 | 异常 | 无效操作码 |
| 0x07 | 异常 | 设备不可用 |
| 0x08 | 异常 | 双重故障 |
| 0x0A | 异常 | 无效 TSS |
| 0x0B | 异常 | 段不存在 |
| 0x0C | 异常 | 栈段错误 |
| 0x0D | 异常 | 通用保护错误 |
| 0x0E | 异常 | 页错误 |
| 0x10 | 异常 | x87 浮点异常 |
| 0x11 | 异常 | 对齐检查 |
| 0x12 | 异常 | 机器检查 |
| 0x13 | 异常 | SIMD 浮点异常 |
| 0x20 | IRQ0 | PIT 定时器 |
| 0x21 | IRQ1 | 键盘 |
| 0x28 | IRQ8 | RTC |
| 0x80 | 陷阱 | 系统调用 |

### IRQ 与 PIC

| IRQ | 向量号 | 设备 | PIC |
|-----|--------|-----|-----|
| 0 | 0x20 | PIT | Master |
| 1 | 0x21 | 键盘 | Master |
| 2 | 0x22 | 级联 | Master |
| 8 | 0x28 | RTC | Slave |

```c
// 启用 IRQ
enable_irq(1);   // 键盘
enable_irq(8);   // RTC
enable_irq(0);   // PIT

// 发送 EOI
send_eoi(irq_num);
```

### 系统调用号

| 编号 | 名称 | 参数 |
|-----|------|------|
| 1 | halt | status |
| 2 | execute | command |
| 3 | read | fd, buf, nbytes |
| 4 | write | fd, buf, nbytes |
| 5 | open | filename |
| 6 | close | fd |
| 7 | getargs | buf, nbytes |
| 8 | vidmap | screen_start |
| 9 | set_handler | signum, handler |
| 10 | sigreturn | - |

```c
// 用户态调用系统调用
int32_t result;
asm volatile(
    "int $0x80"
    : "=a"(result)
    : "a"(syscall_num), "b"(arg1), "c"(arg2), "d"(arg3)
    : "memory"
);
```

### 文件描述符

| FD | 用途 |
|----|------|
| 0 | stdin (键盘) |
| 1 | stdout (终端) |
| 2-7 | 普通文件 |

```c
// 文件描述符数组 (在 PCB 中)
typedef struct {
    file_ops_t* ops;    // 操作函数指针
    uint32_t inode;     // inode 号
    uint32_t pos;       // 文件位置
    uint32_t flags;     // 标志位
} fd_entry_t;

fd_entry_t fd_array[8];
```

### 文件操作表

| 设备类型 | open | read | write | close |
|---------|------|------|-------|-------|
| stdin | term_open | term_read | null | term_close |
| stdout | term_open | null | term_write | term_close |
| rtc | rtc_open | rtc_read | rtc_write | rtc_close |
| file | file_open | file_read | null | file_close |
| dir | dir_open | dir_read | null | dir_close |

### GDT 段选择子

| 名称 | 选择子 | 索引 | 描述 |
|-----|--------|-----|------|
| KERNEL_CS | 0x10 | 2 | 内核代码段 |
| KERNEL_DS | 0x18 | 3 | 内核数据段 |
| USER_CS | 0x23 | 4 | 用户代码段 (RPL=3) |
| USER_DS | 0x2B | 5 | 用户数据段 (RPL=3) |
| TSS | 0x30 | 6 | 任务状态段 |

### TSS 关键字段

```c
// 只需设置这两个字段
tss.ss0 = KERNEL_DS;          // 内核栈段选择子
tss.esp0 = kernel_stack_top;  // 内核栈顶
```

### 分页结构

```
PDE (4KB 页表):
┌────┬───┬───┬───┬───┬───┬───┬───┬────┐
│基地址│ G │ S │ 0 │ A │PCD│PWT│U/S│R/W │ P │
│(20位)│   │   │   │   │   │   │   │    │   │
└────┴───┴───┴───┴───┴───┴───┴───┴────┘
  31-12  8   7   6   5   4   3   2   1   0

PDE (4MB 页):
┌────┬───┬───┬───┬───┬───┬───┬───┬────┐
│基地址│ G │PS=1│ D │ A │PCD│PWT│U/S│R/W │ P │
│(10位)│   │    │   │   │   │   │   │    │   │
└────┴───┴────┴───┴───┴───┴───┴───┴────┘
  31-22  8   7    6   5   4   3   2   1   0

// 常用 PDE 值
#define PDE_4MB_KERNEL  0x00000083  // Present, R/W, 4MB
#define PDE_4MB_USER    0x00000087  // Present, R/W, User, 4MB
#define PDE_4KB         0x00000003  // Present, R/W, 指向页表
```

### 控制寄存器

```c
// CR0: 控制分页和保护模式
// bit 31: PG (分页使能)
// bit 0:  PE (保护模式使能)

// CR3: 页目录基地址
asm volatile("movl %0, %%cr3" : : "r"(page_directory));

// CR2: 页错误地址
uint32_t fault_addr;
asm volatile("movl %%cr2, %0" : "=r"(fault_addr));
```

### 栈操作

```
PUSH:
1. ESP = ESP - 4
2. [ESP] = value

POP:
1. value = [ESP]
2. ESP = ESP + 4

IRET 弹出 (Ring 3 → Ring 0 切换):
[ESP+0]  → EIP
[ESP+4]  → CS
[ESP+8]  → EFLAGS
[ESP+12] → ESP (用户)
[ESP+16] → SS (用户)
```

### 常用 GDB 命令

| 命令 | 缩写 | 功能 |
|-----|------|------|
| `break func` | `b` | 设断点 |
| `continue` | `c` | 继续 |
| `step` | `s` | 单步进入 |
| `next` | `n` | 单步跳过 |
| `stepi` | `si` | 单条指令 |
| `print var` | `p` | 打印变量 |
| `print/x var` | `p/x` | 十六进制打印 |
| `x/10x addr` | | 查看内存 |
| `x/10i addr` | | 反汇编 |
| `info registers` | `i r` | 查看寄存器 |
| `backtrace` | `bt` | 调用栈 |

### I/O 端口

| 端口 | 用途 |
|-----|------|
| 0x20 | PIC Master 命令 |
| 0x21 | PIC Master 数据/掩码 |
| 0xA0 | PIC Slave 命令 |
| 0xA1 | PIC Slave 数据/掩码 |
| 0x40 | PIT 通道 0 |
| 0x43 | PIT 命令 |
| 0x60 | 键盘数据 |
| 0x64 | 键盘状态/命令 |
| 0x70 | RTC 地址 |
| 0x71 | RTC 数据 |
| 0x3D4 | VGA CRT 地址 |
| 0x3D5 | VGA CRT 数据 |

### 常用魔数

| 魔数 | 用途 |
|-----|------|
| `0x7F 'E' 'L' 'F'` | ELF 文件头 |
| `0xDEADBEEF` | 调试标记 |
| `0xCAFEBABE` | 栈金丝雀 |
| `0x4F53 (OS)` | 文件系统魔数 |

### ELF 可执行文件

```c
// ELF 头部结构 (简化)
// 偏移 0:  魔数 0x7F 'E' 'L' 'F'
// 偏移 24: 入口点地址 (4字节)

// 读取入口点
uint32_t entry_point;
read_data(inode, 24, (uint8_t*)&entry_point, 4);
```

### 调度相关

```c
// 终端结构
typedef struct {
    int running_pid;      // 当前运行的进程
    int cursor_x, cursor_y;
    char* vid_backup;     // 视频内存备份
    // ...
} term_info_t;

// 全局变量
int curr_term;      // 当前显示的终端
int running_term;   // 当前运行的终端
int cur_pid;        // 当前进程 PID

// 调度时序
// PIT 中断 (100Hz) → schedule() → 切换到下一终端的进程
```

---

## 常见错误速查

| 症状 | 可能原因 | 检查方法 |
|-----|---------|---------|
| 三重故障重启 | IDT/GDT/分页错误 | `-d int,cpu_reset` |
| 页错误 | 未映射/权限错误 | 检查 CR2, error code |
| GPF | 段选择子/特权级 | 检查 CS, error code |
| 中断不触发 | PIC 掩码/IF 标志 | 检查掩码、EFLAGS |
| 系统调用失败 | 参数/FD 无效 | 打印 EAX, EBX, ECX, EDX |
| 进程切换崩溃 | TSS/栈/页表错误 | 打印 TSS.esp0, PCB |

---

## 快速调试清单

**启动失败**:
- [ ] GDT 是否加载？
- [ ] IDT 是否设置？
- [ ] 分页是否正确？
- [ ] PIC 是否初始化？

**中断问题**:
- [ ] IDT 入口正确？
- [ ] PIC 掩码正确？
- [ ] sti() 是否调用？
- [ ] EOI 是否发送？

**进程问题**:
- [ ] PCB 初始化？
- [ ] 页表映射？
- [ ] TSS.esp0 正确？
- [ ] 用户栈设置？

---

**文档数量**：19 篇
**最后更新**：2025-12-12
