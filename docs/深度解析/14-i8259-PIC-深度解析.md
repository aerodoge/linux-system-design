# i8259 PIC 深度解析

## 概述

i8259 PIC（Programmable Interrupt Controller，可编程中断控制器）是连接外部设备和 CPU 的桥梁。所有硬件中断（键盘、RTC、PIT 等）都必须经过 PIC 才能到达 CPU。

## 为什么需要 PIC？

CPU 只有一个中断引脚（INTR），但系统有多个中断源。PIC 的作用是：

1. **多路复用** - 将多个中断源汇聚到一个 CPU 引脚
2. **优先级仲裁** - 当多个中断同时发生时决定处理顺序
3. **中断屏蔽** - 允许暂时禁用某些中断
4. **中断向量** - 告诉 CPU 应该调用哪个中断处理程序

## 硬件架构

### 级联结构

PC 系统使用两片 8259A 芯片级联，支持 15 个外部中断：

```
                    ┌─────────────────────────────────────────────────┐
                    │                     CPU                         │
                    │                     INTR                        │
                    └───────────────────────┬─────────────────────────┘
                                            │
                    ┌───────────────────────┴─────────────────────────┐
                    │              Master PIC (8259A-1)                │
                    │              Port: 0x20 (cmd), 0x21 (data)       │
                    ├─────────────────────────────────────────────────┤
                    │  IRQ 0  │  PIT (定时器)              → IDT 0x20  │
                    │  IRQ 1  │  Keyboard (键盘)           → IDT 0x21  │
                    │  IRQ 2  │  Cascade (连接从PIC) ──┐   → (无)      │
                    │  IRQ 3  │  COM2 (串口2)            → IDT 0x23  │
                    │  IRQ 4  │  COM1 (串口1)            → IDT 0x24  │
                    │  IRQ 5  │  LPT2 (并口2)            → IDT 0x25  │
                    │  IRQ 6  │  Floppy (软盘)           → IDT 0x26  │
                    │  IRQ 7  │  LPT1 (并口1)            → IDT 0x27  │
                    └─────────────────────────┬───────────────────────┘
                                              │
                    ┌─────────────────────────┴───────────────────────┐
                    │              Slave PIC (8259A-2)                 │
                    │              Port: 0xA0 (cmd), 0xA1 (data)       │
                    ├─────────────────────────────────────────────────┤
                    │  IRQ 8  │  RTC (实时时钟)           → IDT 0x28  │
                    │  IRQ 9  │  (可用)                   → IDT 0x29  │
                    │  IRQ 10 │  (可用)                   → IDT 0x2A  │
                    │  IRQ 11 │  (可用)                   → IDT 0x2B  │
                    │  IRQ 12 │  PS/2 Mouse (鼠标)        → IDT 0x2C  │
                    │  IRQ 13 │  FPU (浮点异常)           → IDT 0x2D  │
                    │  IRQ 14 │  Primary ATA (主硬盘)     → IDT 0x2E  │
                    │  IRQ 15 │  Secondary ATA (从硬盘)   → IDT 0x2F  │
                    └─────────────────────────────────────────────────┘
```

### 本项目使用的 IRQ

| IRQ | 设备 | IDT 向量 | 处理函数 |
|-----|------|---------|---------|
| 0 | PIT (定时器) | 0x20 | `pit_interrupt_handler()` |
| 1 | Keyboard (键盘) | 0x21 | `keyboard_handler()` |
| 8 | RTC (实时时钟) | 0x28 | `rtc_interrupt_handler()` |

## 端口定义

```c
// i8259.h
#define MASTER_8259_PORT    0x20    // 主 PIC 命令端口
#define MASTER_8259_DATA    0x21    // 主 PIC 数据端口
#define SLAVE_8259_PORT     0xA0    // 从 PIC 命令端口
#define SLAVE_8259_DATA     0xA1    // 从 PIC 数据端口
```

**命令端口 vs 数据端口**：

| 端口类型 | 用途 |
|---------|------|
| 命令端口 (0x20/0xA0) | 发送 ICW1、OCW、EOI |
| 数据端口 (0x21/0xA1) | 发送 ICW2-4、读写中断屏蔽寄存器 |

## PIC 初始化

### ICW (Initialization Command Words)

PIC 需要 4 个初始化命令字来配置：

```c
// i8259.h
#define ICW1                0x11    // 初始化命令，边沿触发，级联，需要ICW4
#define ICW2_MASTER         0x20    // 主 PIC 中断向量起始地址 (0x20 = 32)
#define ICW2_SLAVE          0x28    // 从 PIC 中断向量起始地址 (0x28 = 40)
#define ICW3_MASTER         0x04    // 主 PIC: IR2 连接从 PIC (bit 2 = 1)
#define ICW3_SLAVE          0x02    // 从 PIC: 连接到主 PIC 的 IR2 (值为 2)
#define ICW4                0x01    // 8086 模式，正常 EOI
```

### ICW 详解

**ICW1 (0x11)**：
```
0x11 = 0001 0001

位 7-5: 000 (固定)
位 4:   1   (ICW1 标识)
位 3:   0   (边沿触发)
位 2:   0   (级联模式)
位 1:   0   (固定)
位 0:   1   (需要 ICW4)
```

**ICW2 (向量基址)**：
```
主 PIC: 0x20 = 32   → IRQ 0-7  映射到 IDT 0x20-0x27
从 PIC: 0x28 = 40   → IRQ 8-15 映射到 IDT 0x28-0x2F

为什么从 0x20 开始？
- IDT 0x00-0x1F (0-31) 保留给 CPU 异常
- 0x20 (32) 是第一个可用于外部中断的向量
```

**ICW3 (级联配置)**：
```
主 PIC: 0x04 = 0000 0100
        表示从 PIC 连接在 IR2 上

从 PIC: 0x02
        表示自己连接到主 PIC 的 IR2
```

**ICW4 (0x01)**：
```
0x01 = 0000 0001

位 4:   0   (非特殊全嵌套模式)
位 3:   0   (非缓冲模式)
位 2:   0   (非自动 EOI)
位 1:   0   (固定)
位 0:   1   (8086 模式)
```

### i8259_init() 函数

```c
void i8259_init(void) {
    unsigned long flags;
    cli_and_save(flags);    // 保存并关闭中断

    // 1. 屏蔽所有中断
    outb(0xFF, MASTER_8259_DATA);   // 屏蔽主 PIC 所有 IRQ
    outb(0xFF, SLAVE_8259_DATA);    // 屏蔽从 PIC 所有 IRQ

    // 2. 初始化主 PIC
    outb(ICW1, MASTER_8259_PORT);           // ICW1: 初始化命令
    outb(ICW2_MASTER, MASTER_8259_DATA);    // ICW2: 向量基址 0x20
    outb(ICW3_MASTER, MASTER_8259_DATA);    // ICW3: IR2 连接从 PIC
    outb(ICW4, MASTER_8259_DATA);           // ICW4: 8086 模式

    // 3. 初始化从 PIC
    outb(ICW1, SLAVE_8259_PORT);            // ICW1: 初始化命令
    outb(ICW2_SLAVE, SLAVE_8259_DATA);      // ICW2: 向量基址 0x28
    outb(ICW3_SLAVE, SLAVE_8259_DATA);      // ICW3: 连接到主 IR2
    outb(ICW4, SLAVE_8259_DATA);            // ICW4: 8086 模式

    // 4. 启用级联通道 (主 PIC 的 IR2)
    enable_irq(2);

    sti();
    restore_flags(flags);   // 恢复中断状态
}
```

### 初始化流程图

```
i8259_init()
       │
       ├─→ 关中断，屏蔽所有 IRQ
       │
       ├─→ 主 PIC 初始化
       │     ICW1 → 0x20 (命令端口)
       │     ICW2 → 0x21 (数据端口) : 向量 0x20
       │     ICW3 → 0x21 : IR2 连从 PIC
       │     ICW4 → 0x21 : 8086 模式
       │
       ├─→ 从 PIC 初始化
       │     ICW1 → 0xA0 (命令端口)
       │     ICW2 → 0xA1 (数据端口) : 向量 0x28
       │     ICW3 → 0xA1 : 连主 IR2
       │     ICW4 → 0xA1 : 8086 模式
       │
       └─→ 启用 IR2 (级联通道)
```

## 中断屏蔽

### 屏蔽寄存器 (IMR)

每个 PIC 有一个 8 位的中断屏蔽寄存器：
- 位 = 1：该 IRQ 被屏蔽（禁用）
- 位 = 0：该 IRQ 启用

```c
static uint8_t master_mask = 0xFF;  // 初始全部屏蔽
static uint8_t slave_mask = 0xFF;
```

### enable_irq() - 启用中断

```c
void enable_irq(uint32_t irq_num) {
    if (irq_num >= 0 && irq_num <= 7) {
        // 主 PIC (IRQ 0-7)
        master_mask &= ~(1 << irq_num);     // 清除对应位
        outb(master_mask, MASTER_8259_DATA);
    }
    else if (irq_num >= 8 && irq_num <= 15) {
        // 从 PIC (IRQ 8-15)
        slave_mask &= ~(1 << (irq_num - 8));
        outb(slave_mask, SLAVE_8259_DATA);
    }
}
```

**示例：启用键盘 (IRQ 1)**：
```
初始: master_mask = 1111 1111  (所有屏蔽)

enable_irq(1):
~(1 << 1) = ~(0000 0010) = 1111 1101
master_mask &= 1111 1101
master_mask = 1111 1101  (IRQ 1 启用)

写入 0x21 端口
```

### disable_irq() - 禁用中断

```c
void disable_irq(uint32_t irq_num) {
    if (irq_num >= 0 && irq_num <= 7) {
        master_mask |= (1 << irq_num);      // 设置对应位
        outb(master_mask, MASTER_8259_DATA);
    }
    else if (irq_num >= 8 && irq_num <= 15) {
        slave_mask |= (1 << (irq_num - 8));
        outb(slave_mask, SLAVE_8259_DATA);
    }
}
```

## EOI (End of Interrupt)

### 为什么需要 EOI？

当 PIC 发送中断给 CPU 后，会在内部标记该中断"正在处理"。在处理完成前，相同或更低优先级的中断不会被发送。

**必须发送 EOI 告诉 PIC "中断处理完成"**，否则后续中断会被阻塞。

### EOI 命令

```c
#define EOI    0x60    // EOI 命令基址
```

发送 EOI 时，需要将 0x60 与 IRQ 号进行 OR 运算：

```c
void send_eoi(uint32_t irq_num) {
    if (irq_num >= 0 && irq_num <= 7) {
        // 主 PIC 中断：只需发送给主 PIC
        outb(EOI | irq_num, MASTER_8259_PORT);
    }
    else {
        // 从 PIC 中断：需要发送给两个 PIC
        outb(EOI | (irq_num - 8), SLAVE_8259_PORT);  // 先发从 PIC
        outb(EOI | 2, MASTER_8259_PORT);             // 再发主 PIC (IR2)
    }
}
```

### 为什么从 PIC 中断需要两个 EOI？

```
从 PIC 中断传递路径:

设备 (如 RTC)
    │
    ▼
从 PIC IRQ 8
    │
    ▼
主 PIC IR2 (级联)
    │
    ▼
CPU

两个 PIC 都认为自己有中断在处理:
- 从 PIC: IRQ 8 正在处理
- 主 PIC: IR2 正在处理

所以需要两个 EOI:
1. 告诉从 PIC: IRQ 8 处理完了
2. 告诉主 PIC: IR2 (级联) 处理完了
```

### EOI 示例

**键盘中断 (IRQ 1)**：
```c
void keyboard_handler() {
    // ... 处理键盘输入 ...

    send_eoi(1);  // 发送 EOI
    // outb(0x60 | 1, 0x20) = outb(0x61, 0x20)
}
```

**RTC 中断 (IRQ 8)**：
```c
void rtc_interrupt_handler() {
    // ... 处理 RTC ...

    send_eoi(8);
    // 1. outb(0x60 | 0, 0xA0) = outb(0x60, 0xA0) - 从 PIC
    // 2. outb(0x60 | 2, 0x20) = outb(0x62, 0x20) - 主 PIC
}
```

## 中断处理流程

```
设备产生中断 (如键盘按键)
           │
           ▼
┌─────────────────────────────────────────────┐
│  PIC 检查该 IRQ 是否被屏蔽                    │
│  检查是否有更高优先级中断正在处理               │
└─────────────────────────────────────────────┘
           │ (通过检查)
           ▼
┌─────────────────────────────────────────────┐
│  PIC 向 CPU 发送 INT 信号                    │
│  CPU 响应，PIC 发送中断向量号                 │
└─────────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────────┐
│  CPU 根据向量号查 IDT                        │
│  跳转到对应的中断处理程序                     │
└─────────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────────┐
│  中断处理程序执行                             │
│  最后调用 send_eoi(irq_num)                  │
└─────────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────────┐
│  PIC 收到 EOI，清除"正在处理"标记             │
│  可以发送下一个中断                          │
└─────────────────────────────────────────────┘
```

## 中断优先级

PIC 的中断优先级：**IRQ 号越小，优先级越高**

```
优先级 (高 → 低):
IRQ 0 > IRQ 1 > IRQ 2 > ... > IRQ 7 > IRQ 8 > ... > IRQ 15

但 IR2 连接从 PIC，所以:
IRQ 0 > IRQ 1 > (IRQ 8-15) > IRQ 3 > IRQ 4 > ... > IRQ 7
```

本项目中：
- PIT (IRQ 0) 优先级最高
- 键盘 (IRQ 1) 次之
- RTC (IRQ 8) 通过级联，优先级在 IRQ 1 和 IRQ 3 之间

## 与其他模块的关系

```
┌─────────────────────────────────────────────────────────────────┐
│                           系统启动                               │
│  kernel.c: i8259_init() ─────────────────────────────────────── │
└───────────────────────────────────────┬─────────────────────────┘
                                        │
        ┌───────────────────────────────┼───────────────────────────┐
        │                               │                           │
        ▼                               ▼                           ▼
┌───────────────┐             ┌───────────────┐           ┌───────────────┐
│   keyboard.c  │             │    pit.c      │           │ rtc_handler.c │
│               │             │               │           │               │
│ enable_irq(1) │             │ enable_irq(0) │           │ enable_irq(8) │
│ send_eoi(1)   │             │ send_eoi(0)   │           │ send_eoi(8)   │
└───────────────┘             └───────────────┘           └───────────────┘
```

## 常见问题

### 1. 忘记发送 EOI

**症状**：第一次中断正常，之后同类中断不再触发

**原因**：PIC 认为上一个中断还在处理，不发送新中断

**解决**：确保中断处理程序最后调用 `send_eoi()`

### 2. 从 PIC 中断只发一个 EOI

**症状**：RTC 或其他从 PIC 设备只触发一次中断

**原因**：只发了从 PIC 的 EOI，没发主 PIC 的

**解决**：从 PIC 中断需要发两个 EOI

### 3. 初始化顺序错误

**症状**：某些设备中断不工作

**原因**：设备驱动在 PIC 初始化之前调用 `enable_irq()`

**解决**：确保 `i8259_init()` 最先执行

## 总结

i8259 PIC 的核心机制：

| 组件 | 作用 |
|-----|------|
| 主 PIC | 处理 IRQ 0-7，连接 CPU |
| 从 PIC | 处理 IRQ 8-15，级联到主 PIC IR2 |
| ICW1-4 | 初始化配置 |
| IMR (屏蔽寄存器) | 控制哪些 IRQ 启用 |
| EOI | 告知 PIC 中断处理完成 |

关键函数：

| 函数 | 作用 |
|-----|------|
| `i8259_init()` | 初始化两个 PIC |
| `enable_irq(n)` | 启用 IRQ n |
| `disable_irq(n)` | 禁用 IRQ n |
| `send_eoi(n)` | 发送 EOI 信号 |

**核心理解**：PIC 是硬件中断的"看门人"，所有外部中断必须经过它的允许才能到达 CPU。
