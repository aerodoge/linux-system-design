# 文件系统深度解析

## 概述

这个操作系统使用一个**只读的扁平文件系统**，整个文件系统被打包成一个镜像文件加载到内存中。文件系统不支持子目录，所有文件都在根目录下。

## 文件系统布局

### 整体结构

```
┌─────────────────────────────────────────────────────────────────┐
│                    文件系统镜像 (内存中)                          │
├─────────────────────────────────────────────────────────────────┤
│                      Boot Block (4KB)                           │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ 统计信息 (64B)                                            │  │
│  │  - num_dir_entries: 文件数量                              │  │
│  │  - num_inodes: inode 数量                                 │  │
│  │  - num_data_blocks: 数据块数量                            │  │
│  ├──────────────────────────────────────────────────────────┤  │
│  │ 目录项 0 (64B)                                            │  │
│  ├──────────────────────────────────────────────────────────┤  │
│  │ 目录项 1 (64B)                                            │  │
│  ├──────────────────────────────────────────────────────────┤  │
│  │ ...                                                      │  │
│  ├──────────────────────────────────────────────────────────┤  │
│  │ 目录项 62 (64B)   [最多 63 个文件]                         │  │
│  └──────────────────────────────────────────────────────────┘  │
├─────────────────────────────────────────────────────────────────┤
│                      Inode 0 (4KB)                              │
├─────────────────────────────────────────────────────────────────┤
│                      Inode 1 (4KB)                              │
├─────────────────────────────────────────────────────────────────┤
│                      ...                                        │
├─────────────────────────────────────────────────────────────────┤
│                      Inode N-1 (4KB)                            │
├─────────────────────────────────────────────────────────────────┤
│                      Data Block 0 (4KB)                         │
├─────────────────────────────────────────────────────────────────┤
│                      Data Block 1 (4KB)                         │
├─────────────────────────────────────────────────────────────────┤
│                      ...                                        │
├─────────────────────────────────────────────────────────────────┤
│                      Data Block M-1 (4KB)                       │
└─────────────────────────────────────────────────────────────────┘
```

### 地址计算

```
Boot Block 地址:   bootBlock
Inode i 地址:      bootBlock + (i + 1) * 4KB
Data Block j 地址: bootBlock + (num_inodes + 1) * 4KB + j * 4KB
```

## 数据结构定义

### Boot Block (启动块)

```c
typedef struct boot_block {
    uint32_t num_dir_entries;    // 目录项数量 (文件数)
    uint32_t num_inodes;         // inode 数量
    uint32_t num_data_blocks;    // 数据块数量
    uint32_t reserved[13];       // 保留字段 (52 字节)
    dentry_t dir_entries[63];    // 目录项数组 (最多 63 个)
} boot_block_t;
```

**布局**：

```
┌───────────────────────────────────────────────────┐
│  0-3:   num_dir_entries                           │
│  4-7:   num_inodes                                │
│  8-11:  num_data_blocks                           │
│  12-63: reserved (52 bytes)                       │
├───────────────────────────────────────────────────┤ 偏移 64
│  64-127:  dir_entries[0]                          │
├───────────────────────────────────────────────────┤ 偏移 128
│  128-191: dir_entries[1]                          │
├───────────────────────────────────────────────────┤
│  ...                                              │
├───────────────────────────────────────────────────┤ 偏移 4032
│  4032-4095: dir_entries[62]                       │
└───────────────────────────────────────────────────┘

总大小: 64 + 63 × 64 = 4096 字节 = 4KB ✓
```

### Directory Entry (目录项)

```c
typedef struct dir_entry {
    char file_name[32];      // 文件名 (最长 32 字节，无 '\0' 结尾)
    uint32_t file_type;      // 文件类型 (0=RTC, 1=目录, 2=普通文件)
    uint32_t inode;          // inode 号
    uint32_t reserved[6];    // 保留字段 (24 字节)
} dentry_t;
```

**布局**：

```
┌─────────────────────────────────────┐
│  0-31:  file_name (32 bytes)        │
│  32-35: file_type                   │
│  36-39: inode                       │
│  40-63: reserved (24 bytes)         │
└─────────────────────────────────────┘

总大小: 32 + 4 + 4 + 24 = 64 字节 ✓
```

### 文件类型

| file_type | 含义       | 说明            |
|-----------|----------|---------------|
| 0         | RTC 设备文件 | 用于访问 RTC      |
| 1         | 目录       | 只有 "." (当前目录) |
| 2         | 普通文件     | 可执行文件、文本文件等   |

### Index Node (索引节点)

```c
typedef struct index_node {
    uint32_t length;             // 文件大小 (字节数)
    uint32_t data_block[1023];   // 数据块索引数组
} index_node_t;
```

**布局**：

```
┌─────────────────────────────────────┐
│  0-3:     length (文件大小)          │
├─────────────────────────────────────┤
│  4-7:     data_block[0]             │
│  8-11:    data_block[1]             │
│  12-15:   data_block[2]             │
│  ...                                │
│  4092-4095: data_block[1022]        │
└─────────────────────────────────────┘

总大小: 4 + 1023 × 4 = 4096 字节 = 4KB ✓
```

**最大文件大小**：1023 × 4KB ≈ 4MB

## 文件系统初始化

```c
boot_block_t* bootBlock;   // 全局指针，指向文件系统起始位置

void init_file_system(uint32_t bootBlock_addr) {
    bootBlock = (boot_block_t*) bootBlock_addr;
    dir_number = 0;  // 目录读取位置
}
```

文件系统镜像由 bootloader 加载到内存，`init_file_system` 只是保存镜像的起始地址。

## 核心函数详解

### read_dentry_by_name - 按名称查找文件

```c
int32_t read_dentry_by_name(const uint8_t* fname, dentry_t* dentry) {
    int length = strlen((int8_t*)fname);

    // 1. 检查文件名长度
    if (length > MAX_NAME_LENGTH || length == 0) {
        return -1;
    }

    // 2. 处理 32 字符的特殊情况
    int true_length;
    if (length == MAX_NAME_LENGTH) {
        true_length = length + 1;  // 加 1 以区分刚好 32 字符的文件
    } else {
        true_length = length;
    }

    // 3. 遍历所有目录项
    for (int i = 0; i < bootBlock->num_dir_entries; i++) {
        // 长度匹配且名称匹配
        if (true_length == strlen(bootBlock->dir_entries[i].file_name)) {
            if (strncmp((int8_t*)fname,
                        bootBlock->dir_entries[i].file_name,
                        length) == 0) {
                // 4. 复制目录项信息
                strcpy(dentry->file_name, bootBlock->dir_entries[i].file_name);
                dentry->file_type = bootBlock->dir_entries[i].file_type;
                dentry->inode = bootBlock->dir_entries[i].inode;

                // 5. 获取文件大小
                index_node_t* inode_block;
                inode_block = (index_node_t*)bootBlock + dentry->inode + 1;
                f_size = inode_block->length;

                return 0;
            }
        }
    }

    return -1;  // 未找到
}
```

**查找流程**：

```
输入: fname = "shell"
         │
         ▼
检查长度 (0 < len ≤ 32)
         │
         ▼
遍历 dir_entries[0..N-1]
         │
         ├── dir_entries[0].file_name = "."        → 不匹配
         │
         ├── dir_entries[1].file_name = "shell"    → 匹配！
         │   ├── 复制 file_name, file_type, inode
         │   └── 读取 inode 获取文件大小
         │
         └── 返回 0
```

### read_dentry_by_index - 按索引查找文件

```c
int32_t read_dentry_by_index(uint32_t index, dentry_t* dentry) {
    // 检查索引范围
    if (index >= bootBlock->num_dir_entries || index < 0) {
        return -1;
    }

    // 直接复制目录项
    strcpy(dentry->file_name, bootBlock->dir_entries[index].file_name);
    dentry->file_type = bootBlock->dir_entries[index].file_type;
    dentry->inode = bootBlock->dir_entries[index].inode;

    return 0;
}
```

用于 `dir_read` 函数按顺序读取目录内容。

### read_data - 读取文件数据

这是文件系统最核心的函数：

```c
int32_t read_data(uint32_t inode, uint32_t offset, uint8_t* buf, uint32_t length) {
    // 1. 检查 inode 有效性
    if (inode >= bootBlock->num_inodes || inode < 0) {
        return -1;
    }

    // 2. 找到 inode 块
    index_node_t* inode_block;
    inode_block = (index_node_t*)bootBlock + inode + 1;

    // 3. 计算起始位置
    uint32_t data_block_index = offset / FOUR_KB;  // 在哪个数据块
    uint32_t data_line_index = offset % FOUR_KB;   // 块内偏移

    // 4. 定位数据指针
    uint8_t* data_ptr = (uint8_t*)(bootBlock + bootBlock->num_inodes + 1
                        + inode_block->data_block[data_block_index])
                        + data_line_index;

    // 5. 逐字节复制
    for (int i = 0; i < length; i++) {
        // 检查是否超过文件末尾
        if (i + offset >= inode_block->length) {
            return i;  // 返回实际读取的字节数
        }

        buf[i] = *data_ptr;
        data_line_index++;

        // 检查是否需要跳到下一个数据块
        if (data_line_index % FOUR_KB == 0) {
            data_block_index++;
            // 检查下一个数据块是否有效
            if (inode_block->data_block[data_block_index] >= bootBlock->num_data_blocks) {
                return -1;
            }
            // 重新定位到新数据块的起始
            data_ptr = (uint8_t*)(bootBlock + bootBlock->num_inodes + 1
                       + inode_block->data_block[data_block_index]);
        } else {
            data_ptr++;
        }
    }

    return length;
}
```

### read_data 图解

假设要读取 inode 2 的文件，从 offset 5000 开始读取 3000 字节：

```
Step 1: 定位 inode
─────────────────────────────────────
inode_block = bootBlock + (2 + 1) * 4KB = bootBlock + 12KB

Step 2: 计算起始位置
─────────────────────────────────────
data_block_index = 5000 / 4096 = 1   (第 2 个数据块)
data_line_index  = 5000 % 4096 = 904 (块内偏移)

Step 3: 数据块间接寻址
─────────────────────────────────────
inode_block->data_block[1] = 7  (假设)
                               │
                               ▼
data_ptr = bootBlock + (num_inodes + 1 + 7) * 4KB + 904

Step 4: 读取跨块数据
─────────────────────────────────────
┌─────────────────────────────────────────┐
│ Data Block 7 (inode->data_block[1])     │
│  ┌──────────────────────────────────┐   │
│  │ ...                              │   │
│  │ 偏移 904: 开始读取               │←─ 读取 3192 字节
│  │          ...                     │   (填满这个块)
│  │ 偏移 4095: 块末尾                │   │
│  └──────────────────────────────────┘   │
└─────────────────────────────────────────┘
                    │
                    │ 跳转到下一个数据块
                    ▼
┌─────────────────────────────────────────┐
│ Data Block 12 (inode->data_block[2]=12) │
│  ┌──────────────────────────────────┐   │
│  │ 偏移 0: 继续读取                 │←─ 读取剩余字节
│  │ ...                              │   (3000 - 3192 = -192?)
│  └──────────────────────────────────┘   │
└─────────────────────────────────────────┘

等等，3192 > 3000，所以不需要跨块！
让我重新计算：
- 块内起始偏移: 904
- 块内剩余空间: 4096 - 904 = 3192 字节
- 要读取: 3000 字节
- 3000 < 3192，所以全部在同一个块内完成
```

## 文件操作接口

### 文件操作

```c
int32_t file_open(const uint8_t* filename) {
    return 0;  // 简单返回成功
}

int32_t file_close(int32_t fd) {
    return 0;
}

int32_t file_read(int32_t fd, void* buf, int32_t nbytes) {
    // 获取当前进程的 PCB
    pcb_t* pcb = get_specific_pcb(cur_pid);

    // 从文件描述符表获取文件位置和 inode
    uint32_t offset = pcb->fd_table[fd].file_position;
    uint32_t inode = pcb->fd_table[fd].inode;

    // 读取数据
    uint32_t num_data = read_data(inode, offset, (uint8_t*)buf, nbytes);

    // 更新文件位置
    pcb->fd_table[fd].file_position += num_data;

    return num_data;
}

int32_t file_write(int32_t fd, const void* buf, int32_t nbytes) {
    return -1;  // 只读文件系统，不支持写
}
```

### 目录操作

```c
uint32_t dir_number;  // 全局变量，记录当前读取位置

int32_t dir_open(const uint8_t* filename) {
    return 0;
}

int32_t dir_close(int32_t fd) {
    return 0;
}

int32_t dir_read(int32_t fd, void* buf, int32_t nbytes) {
    dentry_t dentry;

    // 读取当前索引的目录项
    if (read_dentry_by_index(dir_number, &dentry) == 0) {
        // 获取文件名长度（最多 32）
        uint32_t length = strlen((int8_t*)dentry.file_name);
        if (length >= MAX_NAME_LENGTH) {
            length = MAX_NAME_LENGTH;
        }

        // 复制文件名到缓冲区
        strncpy((int8_t*)buf, (int8_t*)dentry.file_name, length);

        // 移动到下一个目录项
        dir_number++;

        return length;
    } else {
        // 读完所有目录项，重置
        dir_number = 0;
        return 0;
    }
}

int32_t dir_write(int32_t fd, const void* buf, int32_t nbytes) {
    return -1;  // 只读文件系统
}
```

### dir_read 使用示例

```c
// ls 命令的实现
void ls() {
    char buf[33];  // 32 + 1 for '\0'
    int len;

    while ((len = dir_read(fd, buf, 32)) > 0) {
        buf[len] = '\0';
        printf("%s\n", buf);
    }
}

// 输出:
// .
// shell
// cat
// ls
// fish
// hello
// ...
```

## 文件系统读取流程

### 完整读取流程图

```
用户程序: read(fd, buf, 100)
              │
              ▼
        系统调用处理
              │
              ▼
    file_read(fd, buf, 100)
              │
              ├── 获取 PCB
              │   └── pcb = get_specific_pcb(cur_pid)
              │
              ├── 获取文件信息
              │   ├── offset = pcb->fd_table[fd].file_position
              │   └── inode = pcb->fd_table[fd].inode
              │
              └── read_data(inode, offset, buf, 100)
                        │
                        ├── 验证 inode
                        │
                        ├── 定位 inode 块
                        │   └── inode_block = bootBlock + (inode+1) * 4KB
                        │
                        ├── 计算数据块位置
                        │   ├── block_index = offset / 4096
                        │   └── block_offset = offset % 4096
                        │
                        ├── 定位数据块
                        │   └── data_block_num = inode_block->data_block[block_index]
                        │
                        ├── 计算数据地址
                        │   └── data_ptr = bootBlock + (N+1+data_block_num) * 4KB + block_offset
                        │
                        └── 逐字节复制到 buf
```

### 地址计算公式

```c
// Inode 块地址
inode_addr = (index_node_t*)bootBlock + (inode_num + 1);

// 等价于:
inode_addr = (uint8_t*)bootBlock + (inode_num + 1) * sizeof(index_node_t);
inode_addr = (uint8_t*)bootBlock + (inode_num + 1) * 4096;

// 数据块地址
data_block_addr = (uint8_t*)bootBlock
                + (bootBlock->num_inodes + 1) * 4096
                + data_block_num * 4096;

// 简化形式 (利用指针算术)
data_block_addr = (uint8_t*)(bootBlock + bootBlock->num_inodes + 1 + data_block_num);
```

## 文件描述符表

每个进程的 PCB 中包含文件描述符表：

```c
typedef struct fd_entry {
    file_op_table_t* file_op_table;  // 操作函数指针表
    uint32_t inode;                   // inode 号
    uint32_t file_position;           // 当前读取位置
    uint32_t flags;                   // 标志位（是否使用）
} fd_entry_t;

// PCB 中
fd_entry_t fd_table[8];  // 最多 8 个打开的文件
```

### 文件描述符分配

```
fd    用途
───────────────────
0     stdin  (终端输入)
1     stdout (终端输出)
2     stderr (通常指向 stdout)
3-7   用户程序打开的文件
```

### 操作函数指针表

```c
typedef struct file_op_table {
    int32_t (*read)(int32_t fd, void* buf, int32_t nbytes);
    int32_t (*write)(int32_t fd, const void* buf, int32_t nbytes);
    int32_t (*open)(const uint8_t* filename);
    int32_t (*close)(int32_t fd);
} file_op_table_t;

// 不同类型的文件使用不同的操作表
file_op_table_t file_ops = {file_read, file_write, file_open, file_close};
file_op_table_t dir_ops = {dir_read, dir_write, dir_open, dir_close};
file_op_table_t rtc_ops = {rtc_read, rtc_write, rtc_open, rtc_close};
file_op_table_t terminal_ops = {terminal_read, terminal_write, terminal_open, terminal_close};
```

## 常见问题解答

### Q1: 为什么文件名最长 32 字节但没有 '\0' 结尾？

为了最大化利用空间。目录项固定 64 字节，如果文件名加 '\0' 就只能存 31 个有效字符。代码中需要特殊处理 32 字符的情况：

```c
if (length == MAX_NAME_LENGTH) {
    true_length = length + 1;  // 特殊标记
}
```

### Q2: 为什么 data_block 数组有 1023 个元素而不是 1024？

因为 inode 块的前 4 字节用于存储 `length`：

```
4KB = 4096 字节
length 占用 4 字节
剩余 4092 字节 / 4 = 1023 个 data_block 条目
```

### Q3: 为什么 Boot Block 最多只能有 63 个目录项？

```
Boot Block = 4KB = 4096 字节
统计信息头 = 64 字节
剩余空间 = 4096 - 64 = 4032 字节
每个目录项 = 64 字节
目录项数量 = 4032 / 64 = 63
```

### Q4: 这个文件系统和 Unix/Linux 文件系统有什么区别？

| 特性    | 391 文件系统 | Unix/Linux |
|-------|----------|------------|
| 子目录   | 不支持      | 支持         |
| 写操作   | 不支持      | 支持         |
| 硬链接   | 不支持      | 支持         |
| 权限    | 无        | 有          |
| 时间戳   | 无        | 有          |
| 文件名长度 | 32       | 255+       |
| 最大文件  | ~4MB     | 很大         |

### Q5: read_data 中为什么要逐字节复制？

简单但效率低。更好的实现可以使用 `memcpy` 进行块级复制。逐字节复制的好处是代码简单，容易处理跨块边界的情况。

## 调试技巧

### 打印文件系统信息

```c
void print_fs_info() {
    printf("Files: %d\n", bootBlock->num_dir_entries);
    printf("Inodes: %d\n", bootBlock->num_inodes);
    printf("Data blocks: %d\n", bootBlock->num_data_blocks);
}
```

### 列出所有文件

```c
void list_files() {
    dentry_t dentry;
    for (int i = 0; i < bootBlock->num_dir_entries; i++) {
        read_dentry_by_index(i, &dentry);
        index_node_t* inode = (index_node_t*)bootBlock + dentry.inode + 1;
        printf("%s (type=%d, size=%d)\n",
               dentry.file_name,
               dentry.file_type,
               inode->length);
    }
}
```

### 验证文件内容

```c
void dump_file(const char* name, int n) {
    dentry_t dentry;
    if (read_dentry_by_name(name, &dentry) != 0) {
        printf("File not found\n");
        return;
    }

    uint8_t buf[128];
    int len = read_data(dentry.inode, 0, buf, n);
    for (int i = 0; i < len; i++) {
        printf("%02x ", buf[i]);
    }
    printf("\n");
}
```

## 总结

文件系统的核心概念：

| 概念              | 说明                             |
|-----------------|--------------------------------|
| Boot Block      | 文件系统头，包含统计信息和目录项               |
| Directory Entry | 文件名 → inode 的映射                |
| Inode           | 文件大小 + 数据块索引数组                 |
| Data Block      | 实际文件内容                         |
| 间接寻址            | 通过 inode 的 data_block 数组找到实际数据 |

读取文件的流程：

```
文件名 ──> 目录项 ──> inode ──> 数据块索引 ──> 数据
  │           │         │            │          │
  │           │         │            │          └── 实际内容
  │           │         │            └── data_block[0,1,2...]
  │           │         └── length + data_block[]
  │           └── file_name, file_type, inode
  └── read_dentry_by_name()
```
