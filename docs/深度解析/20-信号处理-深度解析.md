# 信号处理深度解析

## 概述

信号 (Signal) 是一种软件中断机制，允许内核或进程向另一个进程发送异步通知。在 ECE 391 MP3 中，信号处理是 Extra Credit 功能。

### 为什么需要信号？

1. **异步事件通知** - 不需要进程主动查询
2. **异常处理** - 除零、段错误等可以被用户程序捕获
3. **进程间通信** - 简单的 IPC 机制
4. **用户自定义处理** - 程序可以定义如何响应特定事件

### MP3 中的信号

| 信号号 | 名称 | 触发条件 |
|-------|------|---------|
| 0 | DIV_ZERO | 除零异常 |
| 1 | SEGFAULT | 段错误/页错误 |
| 2 | INTERRUPT | Ctrl+C |
| 3 | ALARM | 定时器到期 |
| 4 | USER1 | 用户定义 |

## 信号处理流程

### 整体流程

```
触发信号                  返回用户态时检查              执行用户处理函数
   │                          │                           │
   ▼                          ▼                           ▼
┌─────────┐              ┌─────────┐                ┌─────────┐
│ 异常/   │   设置       │ 检查    │    有信号      │ 修改栈  │
│ 中断/   │ ─────────▶  │ pending │ ─────────────▶ │ 跳转到  │
│ syscall │   pending    │ signals │                │ handler │
└─────────┘              └─────────┘                └─────────┘
                                                         │
                              ┌───────────────────────────┘
                              ▼
                        ┌─────────┐              ┌─────────┐
                        │ handler │   sigreturn  │ 恢复    │
                        │ 执行    │ ─────────▶  │ 原上下文│
                        └─────────┘              └─────────┘
```

### 信号状态

每个进程的 PCB 中需要维护：

```c
typedef struct pcb {
    // ... 其他字段

    // 信号相关
    uint32_t sig_pending;           // 待处理信号位图
    uint32_t sig_masked;            // 被屏蔽的信号位图
    void* sig_handlers[NUM_SIGS];   // 用户信号处理函数
} pcb_t;

#define NUM_SIGS 5

// 默认处理动作
#define SIG_DFL ((void*)0)  // 默认处理（通常是终止）
#define SIG_IGN ((void*)1)  // 忽略信号
```

## 系统调用实现

### set_handler - 设置信号处理函数

```c
/*
 * set_handler - 为指定信号设置处理函数
 *
 * 参数:
 *   signum  - 信号号 (0-4)
 *   handler - 处理函数地址，SIG_DFL 或 SIG_IGN
 *
 * 返回:
 *   0 成功，-1 失败
 */
int32_t set_handler(int32_t signum, void* handler) {
    // 参数检查
    if (signum < 0 || signum >= NUM_SIGS) {
        return -1;
    }

    // 获取当前 PCB
    pcb_t* pcb = get_current_pcb();

    // 设置处理函数
    pcb->sig_handlers[signum] = handler;

    return 0;
}
```

### sigreturn - 从信号处理函数返回

```c
/*
 * sigreturn - 从信号处理函数返回
 *
 * 这个系统调用由信号 trampoline 代码调用
 * 恢复被信号中断的原始执行上下文
 *
 * 返回:
 *   不返回，直接恢复原上下文
 */
int32_t sigreturn(void) {
    pcb_t* pcb = get_current_pcb();

    // 从用户栈获取保存的硬件上下文
    // 用户栈布局见下文
    hw_context_t* saved_context = /* 从用户栈获取 */;

    // 恢复原始上下文
    // 这需要修改内核栈上的 IRET 帧

    // 不返回，直接恢复执行
}
```

## 信号触发

### 触发信号的函数

```c
/*
 * send_signal - 向进程发送信号
 *
 * 参数:
 *   pid    - 目标进程 ID
 *   signum - 信号号
 */
void send_signal(int32_t pid, int32_t signum) {
    if (pid < 0 || pid >= MAX_PROCESSES) return;
    if (signum < 0 || signum >= NUM_SIGS) return;

    pcb_t* pcb = get_specific_pcb(pid);

    // 设置 pending 位
    pcb->sig_pending |= (1 << signum);
}

// 从异常处理中调用
void divide_error_handler() {
    send_signal(cur_pid, SIG_DIV_ZERO);
}

void page_fault_handler() {
    send_signal(cur_pid, SIG_SEGFAULT);
}

// 从键盘处理中调用
void keyboard_handler() {
    // ...
    if (ctrl_pressed && key == 'c') {
        // 向前台进程发送 INTERRUPT 信号
        send_signal(get_foreground_pid(), SIG_INTERRUPT);
    }
}
```

## 信号递送

### 检查并递送信号

信号在返回用户态之前检查和递送：

```c
/*
 * check_and_deliver_signals - 检查并递送待处理信号
 *
 * 在以下时机调用：
 * 1. 系统调用返回用户态前
 * 2. 中断返回用户态前
 * 3. 异常返回用户态前
 *
 * 参数:
 *   hw_context - 指向内核栈上的硬件上下文
 */
void check_and_deliver_signals(hw_context_t* hw_context) {
    pcb_t* pcb = get_current_pcb();

    // 检查是否有待处理且未屏蔽的信号
    uint32_t deliverable = pcb->sig_pending & ~pcb->sig_masked;

    if (deliverable == 0) {
        return;  // 没有信号需要处理
    }

    // 找到第一个待处理信号
    int signum;
    for (signum = 0; signum < NUM_SIGS; signum++) {
        if (deliverable & (1 << signum)) {
            break;
        }
    }

    // 清除 pending 位
    pcb->sig_pending &= ~(1 << signum);

    // 获取处理函数
    void* handler = pcb->sig_handlers[signum];

    if (handler == SIG_IGN) {
        // 忽略信号
        return;
    }

    if (handler == SIG_DFL) {
        // 默认处理
        handle_signal_default(signum);
        return;
    }

    // 用户自定义处理
    setup_signal_frame(hw_context, signum, handler);
}

/*
 * handle_signal_default - 默认信号处理
 */
void handle_signal_default(int signum) {
    switch (signum) {
        case SIG_DIV_ZERO:
        case SIG_SEGFAULT:
        case SIG_INTERRUPT:
            // 终止进程
            halt(256);  // 256 表示被信号杀死
            break;
        case SIG_ALARM:
        case SIG_USER1:
            // 默认忽略
            break;
    }
}
```

## 信号栈帧

### 用户栈布局

执行用户信号处理函数前，需要在用户栈上设置特殊的栈帧：

```
用户栈 (执行 handler 前):

高地址
┌─────────────────────┐
│   原始用户栈内容     │
├─────────────────────┤ ← 原 ESP
│                     │
│   保存的硬件上下文    │  ← 用于 sigreturn 恢复
│   (EIP, CS, EFLAGS,  │
│    ESP, SS, EAX,    │
│    EBX, ECX, EDX,   │
│    ESI, EDI, EBP)   │
│                     │
├─────────────────────┤
│   信号号 (signum)    │  ← handler 的参数
├─────────────────────┤
│   返回地址           │  ← 指向 sigreturn_trampoline
│   (trampoline 地址)  │
├─────────────────────┤ ← 新 ESP
│                     │
│   sigreturn         │  ← trampoline 代码 (8 字节)
│   trampoline code   │
│                     │
└─────────────────────┘
低地址
```

### 设置信号栈帧

```c
// sigreturn trampoline 代码
// 这段代码会被复制到用户栈
static uint8_t sigreturn_trampoline[8] = {
    0xB8, 0x0A, 0x00, 0x00, 0x00,  // mov eax, 10  (sigreturn 系统调用号)
    0xCD, 0x80,                     // int 0x80
    0x00                            // padding
};

/*
 * setup_signal_frame - 设置信号栈帧
 *
 * 参数:
 *   hw_context - 内核栈上的硬件上下文
 *   signum     - 信号号
 *   handler    - 用户处理函数地址
 */
void setup_signal_frame(hw_context_t* hw_context,
                        int signum, void* handler) {

    uint32_t user_esp = hw_context->esp;

    // 1. 复制 trampoline 代码到用户栈
    user_esp -= sizeof(sigreturn_trampoline);
    uint32_t trampoline_addr = user_esp;
    copy_to_user(user_esp, sigreturn_trampoline,
                 sizeof(sigreturn_trampoline));

    // 2. 压入返回地址 (trampoline)
    user_esp -= 4;
    *(uint32_t*)user_esp = trampoline_addr;

    // 3. 压入信号号 (handler 参数)
    user_esp -= 4;
    *(uint32_t*)user_esp = signum;

    // 4. 保存当前硬件上下文 (用于 sigreturn)
    user_esp -= sizeof(hw_context_t);
    copy_to_user(user_esp, hw_context, sizeof(hw_context_t));

    // 5. 修改硬件上下文，使 IRET 跳转到 handler
    hw_context->eip = (uint32_t)handler;
    hw_context->esp = user_esp;

    // 保存上下文地址到 PCB，供 sigreturn 使用
    pcb_t* pcb = get_current_pcb();
    pcb->sig_saved_context = user_esp;
}
```

### sigreturn 实现细节

```c
/*
 * sigreturn - 从信号处理函数返回
 *
 * 用户处理函数执行完后，通过 trampoline 调用此系统调用
 */
int32_t sigreturn(void) {
    pcb_t* pcb = get_current_pcb();

    // 获取保存的上下文地址
    uint32_t saved_addr = pcb->sig_saved_context;

    // 从用户栈读取保存的上下文
    hw_context_t saved_context;
    copy_from_user(&saved_context, saved_addr, sizeof(hw_context_t));

    // 获取当前内核栈上的硬件上下文
    hw_context_t* current_context = get_current_hw_context();

    // 恢复原始上下文
    memcpy(current_context, &saved_context, sizeof(hw_context_t));

    // 返回值会被 IRET 忽略，因为 EAX 已从 saved_context 恢复
    return 0;
}
```

## 执行流程示例

### 除零信号处理流程

```
1. 用户程序执行除零
   int x = 1 / 0;
        │
        ▼
2. CPU 触发异常 0 (除零)
   跳转到 IDT[0] 的处理函数
        │
        ▼
3. 异常处理函数
   divide_error_handler() {
       send_signal(cur_pid, SIG_DIV_ZERO);
   }
        │
        ▼
4. 返回用户态前检查信号
   check_and_deliver_signals() {
       // 发现 SIG_DIV_ZERO pending
       // handler != SIG_DFL
       setup_signal_frame(...);
   }
        │
        ▼
5. IRET 返回用户态
   跳转到用户的 handler，而不是原 EIP
        │
        ▼
6. 用户 handler 执行
   void my_handler(int signum) {
       printf("Caught signal %d\n", signum);
   }
        │
        ▼
7. handler 返回，执行 trampoline
   mov eax, 10
   int 0x80     // sigreturn
        │
        ▼
8. sigreturn 系统调用
   恢复原始上下文
        │
        ▼
9. IRET 返回用户态
   回到原来的位置（除零指令的下一条）
```

## 硬件上下文结构

```c
/*
 * hw_context_t - 硬件上下文
 *
 * 这个结构必须和汇编中断处理匹配
 */
typedef struct hw_context {
    // PUSHA 保存的通用寄存器
    uint32_t edi;
    uint32_t esi;
    uint32_t ebp;
    uint32_t esp_dummy;  // PUSHA 保存的 ESP，忽略
    uint32_t ebx;
    uint32_t edx;
    uint32_t ecx;
    uint32_t eax;

    // 中断号和错误码
    uint32_t irq_num;
    uint32_t error_code;

    // CPU 自动压栈
    uint32_t eip;
    uint32_t cs;
    uint32_t eflags;
    uint32_t esp;    // 用户 ESP (仅跨特权级)
    uint32_t ss;     // 用户 SS (仅跨特权级)
} hw_context_t;
```

## 信号屏蔽

### 临界区保护

在某些情况下需要临时屏蔽信号：

```c
/*
 * sig_mask - 屏蔽信号
 */
uint32_t sig_mask(uint32_t mask) {
    pcb_t* pcb = get_current_pcb();
    uint32_t old_mask = pcb->sig_masked;
    pcb->sig_masked |= mask;
    return old_mask;
}

/*
 * sig_unmask - 取消屏蔽
 */
void sig_unmask(uint32_t mask) {
    pcb_t* pcb = get_current_pcb();
    pcb->sig_masked &= ~mask;
}

// 使用示例
void critical_section() {
    uint32_t old = sig_mask(0xFFFFFFFF);  // 屏蔽所有信号

    // 临界区代码

    sig_unmask(old);  // 恢复
}
```

### 信号处理期间的屏蔽

执行信号处理函数时，通常需要屏蔽同类信号：

```c
void setup_signal_frame(...) {
    // ...

    // 在执行 handler 期间屏蔽该信号
    pcb->sig_masked |= (1 << signum);

    // sigreturn 时恢复
}

int32_t sigreturn(void) {
    // ...

    // 恢复原始屏蔽状态
    pcb->sig_masked = saved_context.sig_masked;

    // ...
}
```

## 与 Linux 的比较

| 特性 | ECE 391 MP3 | Linux |
|-----|-------------|-------|
| 信号数量 | 5 个 | 64 个 (标准 32 + 实时 32) |
| 信号队列 | 无（位图） | 支持排队 |
| 信号屏蔽 | 简单位图 | sigset_t |
| 处理函数 | 单参数 | sigaction 支持多参数 |
| 实时信号 | 不支持 | 支持 |
| 信号信息 | 无 | siginfo_t |

## 常见问题

### 1. 信号丢失

**问题**：同一信号多次触发，只处理一次

**原因**：使用位图而非队列

```c
// 信号 1 触发
pcb->sig_pending |= (1 << 1);  // pending = 0x02

// 信号 1 再次触发
pcb->sig_pending |= (1 << 1);  // pending 仍然是 0x02

// 只会递送一次
```

**解决**：这是设计限制，Linux 的实时信号使用队列解决

### 2. 栈帧设置错误

**问题**：handler 执行后返回到错误位置

**排查**：
```c
// 检查 trampoline 是否正确复制
void debug_signal_frame(uint32_t user_esp) {
    printf("Trampoline at 0x%x:\n", user_esp);
    int i;
    for (i = 0; i < 8; i++) {
        printf("%02x ", *(uint8_t*)(user_esp + i));
    }
    printf("\n");
}
```

### 3. sigreturn 恢复错误上下文

**问题**：sigreturn 后程序行为异常

**排查**：
```c
int32_t sigreturn(void) {
    // 打印保存的上下文
    printf("Restoring: EIP=0x%x, ESP=0x%x\n",
           saved_context.eip, saved_context.esp);
    // ...
}
```

### 4. 嵌套信号处理

**问题**：handler 执行期间又收到信号

**解决**：在 handler 执行期间屏蔽同类信号

## 测试用例

```c
// 测试 1: 基本信号处理
volatile int signal_received = 0;

void test_handler(int signum) {
    signal_received = 1;
}

void test_signal_basic() {
    set_handler(SIG_USER1, test_handler);

    // 触发信号（通过系统调用或其他方式）
    // ...

    // 等待信号处理
    while (!signal_received) {
        // 忙等待
    }

    printf("Signal test passed!\n");
}

// 测试 2: 除零信号
void div_zero_handler(int signum) {
    printf("Caught div by zero!\n");
}

void test_div_zero() {
    set_handler(SIG_DIV_ZERO, div_zero_handler);

    // 这会触发除零异常
    volatile int x = 1;
    volatile int y = 0;
    volatile int z = x / y;  // 触发信号

    printf("Continued after div zero!\n");
}

// 测试 3: Ctrl+C 信号
void interrupt_handler(int signum) {
    printf("Interrupted!\n");
}

void test_ctrl_c() {
    set_handler(SIG_INTERRUPT, interrupt_handler);

    printf("Press Ctrl+C...\n");
    while (1) {
        // 等待 Ctrl+C
    }
}
```

## 实现检查清单

- [ ] PCB 中添加信号相关字段
- [ ] 实现 set_handler 系统调用
- [ ] 实现 sigreturn 系统调用
- [ ] 实现 send_signal 函数
- [ ] 在异常处理中触发信号
- [ ] 在键盘处理中实现 Ctrl+C
- [ ] 实现 check_and_deliver_signals
- [ ] 实现 setup_signal_frame
- [ ] 正确设置 trampoline 代码
- [ ] 处理信号屏蔽

## 总结

| 组件 | 功能 |
|-----|------|
| sig_pending | 待处理信号位图 |
| sig_masked | 被屏蔽的信号位图 |
| sig_handlers[] | 用户处理函数数组 |
| set_handler | 设置处理函数 |
| sigreturn | 从 handler 返回 |
| send_signal | 触发信号 |
| setup_signal_frame | 设置用户栈帧 |
| trampoline | 调用 sigreturn 的代码 |

信号处理的关键点：
1. **异步性** - 信号可以在任何时刻触发
2. **栈帧设置** - 正确设置用户栈以执行 handler
3. **上下文保存** - 保存并恢复被中断的执行上下文
4. **trampoline** - 确保 handler 返回后调用 sigreturn
