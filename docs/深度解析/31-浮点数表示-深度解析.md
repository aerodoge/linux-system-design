# 浮点数表示 - 深度解析

## 1. 为什么需要浮点数？

整数只能表示离散的值，无法表示：
- 小数：如 3.14159、0.001
- 非常大的数：如 6.02 × 10²³（阿伏伽德罗常数）
- 非常小的数：如 1.6 × 10⁻¹⁹（电子电量）

**浮点数**采用科学计数法的思想，用有限的位数表示很大范围的数值。

---

## 2. IEEE 754 标准

现代计算机普遍采用 **IEEE 754** 标准表示浮点数。

### 2.1 基本格式

```
浮点数 = (-1)^S × M × 2^E

S：符号位（Sign）
M：尾数/有效数字（Mantissa/Significand）
E：指数（Exponent）
```

### 2.2 三种精度

| 精度 | 总位数 | 符号位 | 指数位 | 尾数位 | C 类型 |
|------|--------|--------|--------|--------|--------|
| 单精度 | 32 | 1 | 8 | 23 | float |
| 双精度 | 64 | 1 | 11 | 52 | double |
| 扩展精度 | 80 | 1 | 15 | 64 | long double (x87) |

### 2.3 单精度（float）内存布局

```
 31  30      23 22                    0
┌───┬──────────┬────────────────────────┐
│ S │ Exponent │       Mantissa         │
│ 1 │    8     │          23            │
└───┴──────────┴────────────────────────┘
```

### 2.4 双精度（double）内存布局

```
 63  62          52 51                                    0
┌───┬──────────────┬──────────────────────────────────────┐
│ S │   Exponent   │              Mantissa                │
│ 1 │      11      │                 52                   │
└───┴──────────────┴──────────────────────────────────────┘
```

---

## 3. 指数的偏移表示（Biased Exponent）

### 3.1 为什么用偏移？

指数需要表示正负值（如 2⁵ 和 2⁻⁵），但比较浮点数大小时，我们希望能直接按位比较。

**解决方案：** 加上一个偏移量（Bias），使存储的值总是非负的。

```
存储的指数 = 实际指数 + Bias

单精度 Bias = 127  (2^7 - 1)
双精度 Bias = 1023 (2^10 - 1)
```

### 3.2 指数范围

**单精度（8 位指数）：**

| 存储值 | 实际指数 | 用途 |
|--------|----------|------|
| 0 | - | 特殊值（零、非规格化数） |
| 1 | -126 | 最小规格化指数 |
| 127 | 0 | 指数为 0 |
| 254 | +127 | 最大规格化指数 |
| 255 | - | 特殊值（无穷、NaN） |

**双精度（11 位指数）：**

| 存储值 | 实际指数 | 用途 |
|--------|----------|------|
| 0 | - | 特殊值 |
| 1 | -1022 | 最小规格化指数 |
| 1023 | 0 | 指数为 0 |
| 2046 | +1023 | 最大规格化指数 |
| 2047 | - | 特殊值 |

---

## 4. 尾数的隐含位（Implicit Bit）

### 4.1 规格化数的特点

科学计数法中，我们总是把数字写成 `1.xxx × 2^n` 的形式（二进制）。

例如：
```
5.0 = 101.0 (二进制) = 1.01 × 2²
0.5 = 0.1 (二进制) = 1.0 × 2⁻¹
```

既然规格化数的整数部分**总是 1**，那就不用存储它！

### 4.2 隐含的 1

```
实际尾数 = 1.M（M 是存储的 23/52 位）

存储 M = 01000000000000000000000
实际值 = 1.01000000000000000000000 (二进制)
       = 1.25 (十进制)
```

这样，23 位实际上提供了 24 位的精度！

---

## 5. 浮点数的分类

根据指数字段的值，浮点数分为几类：

### 5.1 分类表（单精度）

| 指数(E) | 尾数(M) | 表示的值 | 类型 |
|---------|---------|----------|------|
| 0 | 0 | ±0 | 零 |
| 0 | ≠0 | ±0.M × 2⁻¹²⁶ | 非规格化数 |
| 1~254 | 任意 | ±1.M × 2^(E-127) | 规格化数 |
| 255 | 0 | ±∞ | 无穷大 |
| 255 | ≠0 | NaN | 非数 |

### 5.2 规格化数（Normalized）

最常见的情况，指数不全为 0 也不全为 1。

```
值 = (-1)^S × 1.M × 2^(E-Bias)
```

### 5.3 非规格化数（Denormalized/Subnormal）

指数全为 0，用于表示非常接近 0 的数。

```
值 = (-1)^S × 0.M × 2^(1-Bias)

注意：
1. 没有隐含的 1，整数部分是 0
2. 指数固定为 1-Bias（单精度为 -126）
```

**作用：** 填补 0 和最小规格化数之间的空白，实现"渐进下溢"。

```
单精度最小规格化数：1.0 × 2^(-126) ≈ 1.18 × 10^(-38)
单精度最小非规格化数：2^(-23) × 2^(-126) = 2^(-149) ≈ 1.4 × 10^(-45)
```

### 5.4 零

指数和尾数都为 0。

```
+0: S=0, E=0, M=0  →  0x00000000
-0: S=1, E=0, M=0  →  0x80000000
```

**注意：** +0 和 -0 在比较时相等（`+0.0 == -0.0` 为真）。

### 5.5 无穷大（Infinity）

指数全为 1，尾数全为 0。

```
+∞: S=0, E=255, M=0  →  0x7F800000
-∞: S=1, E=255, M=0  →  0xFF800000
```

产生情况：
- 正数除以 0：`1.0 / 0.0 = +∞`
- 溢出：`1e38 * 1e38 = +∞`

### 5.6 NaN（Not a Number）

指数全为 1，尾数不为 0。

```
NaN: E=255, M≠0
```

**两种 NaN：**

| 类型 | 尾数最高位 | 行为 |
|------|-----------|------|
| QNaN (Quiet) | 1 | 静默传播，不触发异常 |
| SNaN (Signaling) | 0 | 触发浮点异常 |

产生情况：
- `0.0 / 0.0`
- `∞ - ∞`
- `∞ × 0`
- `sqrt(-1)`
- 对负数取对数

**NaN 的特殊性质：**
```c
NaN == NaN  // false！NaN 不等于任何值，包括自己
NaN != NaN  // true！这是检测 NaN 的方法
```

---

## 6. 转换示例

### 6.1 十进制转 IEEE 754 单精度

**例：将 -12.375 转换为单精度浮点数**

**步骤 1：确定符号位**
```
负数，S = 1
```

**步骤 2：转换为二进制**
```
整数部分：12 = 1100 (二进制)
小数部分：0.375 = 0.011 (二进制)
  0.375 × 2 = 0.75  → 0
  0.75 × 2 = 1.5    → 1
  0.5 × 2 = 1.0     → 1

所以：12.375 = 1100.011 (二进制)
```

**步骤 3：规格化**
```
1100.011 = 1.100011 × 2³
```

**步骤 4：计算指数**
```
实际指数 = 3
存储指数 = 3 + 127 = 130 = 10000010 (二进制)
```

**步骤 5：提取尾数**
```
1.100011 的小数部分 = 100011
补齐 23 位：10001100000000000000000
```

**步骤 6：组合**
```
S    Exponent   Mantissa
1    10000010   10001100000000000000000

二进制：1 10000010 10001100000000000000000
十六进制：0xC1460000
```

**验证：**
```c
float f = -12.375;
printf("0x%08X\n", *(unsigned int*)&f);  // 输出：0xC1460000
```

### 6.2 IEEE 754 单精度转十进制

**例：将 0x40490FDB 转换为十进制**

**步骤 1：拆分**
```
0x40490FDB = 0100 0000 0100 1001 0000 1111 1101 1011

S = 0
E = 10000000 = 128
M = 10010010000111111011011
```

**步骤 2：计算实际指数**
```
实际指数 = 128 - 127 = 1
```

**步骤 3：计算尾数值**
```
1.M = 1.10010010000111111011011 (二进制)
    = 1 + 1/2 + 1/16 + 1/128 + ...
    ≈ 1.5707963...
```

**步骤 4：计算最终值**
```
值 = (-1)^0 × 1.5707963... × 2^1
   = 3.1415927...
   ≈ π
```

### 6.3 特殊情况转换

**0.1 的表示问题：**

```
0.1 (十进制) 在二进制中是无限循环小数！

0.1 × 2 = 0.2 → 0
0.2 × 2 = 0.4 → 0
0.4 × 2 = 0.8 → 0
0.8 × 2 = 1.6 → 1
0.6 × 2 = 1.2 → 1
0.2 × 2 = 0.4 → 0  ← 开始循环
...

0.1 = 0.0001100110011001100110011... (二进制，无限循环)
```

这就是为什么 `0.1 + 0.2 ≠ 0.3` 的根本原因！

---

## 7. 精度与范围

### 7.1 精度（有效数字）

| 精度 | 尾数位 | 有效位（含隐含位） | 十进制有效数字 |
|------|--------|-------------------|---------------|
| 单精度 | 23 | 24 | ~7 位 |
| 双精度 | 52 | 53 | ~15-16 位 |

**计算方法：**
```
十进制有效数字 ≈ 尾数位数 × log₁₀(2) ≈ 尾数位数 × 0.301

单精度：24 × 0.301 ≈ 7.2
双精度：53 × 0.301 ≈ 16.0
```

### 7.2 范围

**单精度（float）：**

| 类型 | 值 | 约等于 |
|------|-----|--------|
| 最大规格化数 | (2-2⁻²³) × 2¹²⁷ | 3.4 × 10³⁸ |
| 最小正规格化数 | 1 × 2⁻¹²⁶ | 1.18 × 10⁻³⁸ |
| 最小正非规格化数 | 2⁻²³ × 2⁻¹²⁶ | 1.4 × 10⁻⁴⁵ |

**双精度（double）：**

| 类型 | 值 | 约等于 |
|------|-----|--------|
| 最大规格化数 | (2-2⁻⁵²) × 2¹⁰²³ | 1.8 × 10³⁰⁸ |
| 最小正规格化数 | 1 × 2⁻¹⁰²² | 2.2 × 10⁻³⁰⁸ |
| 最小正非规格化数 | 2⁻⁵² × 2⁻¹⁰²² | 4.9 × 10⁻³²⁴ |

---

## 8. 浮点数的精度陷阱

### 8.1 经典问题：0.1 + 0.2 ≠ 0.3

```c
#include <stdio.h>

int main() {
    double a = 0.1;
    double b = 0.2;
    double c = 0.3;

    printf("0.1 + 0.2 = %.20f\n", a + b);
    printf("0.3       = %.20f\n", c);
    printf("相等? %d\n", (a + b) == c);  // 输出：0 (false)

    return 0;
}
```

**输出：**
```
0.1 + 0.2 = 0.30000000000000004441
0.3       = 0.29999999999999998890
相等? 0
```

**原因：** 0.1、0.2、0.3 在二进制中都是无限循环小数，存储时被截断，累积了不同的舍入误差。

### 8.2 大数吃小数

```c
float big = 1e10f;
float small = 1.0f;

printf("big + small = %.1f\n", big + small);
printf("期望值      = %.1f\n", 1e10f + 1.0f);
```

**输出：**
```
big + small = 10000000000.0
期望值      = 10000000000.0  // 小数被"吃掉"了
```

**原因：** 单精度只有约 7 位有效数字。10000000000 已经用完了所有精度，加 1 时 1 在有效数字之外。

### 8.3 累积误差

```c
float sum = 0.0f;
for (int i = 0; i < 1000000; i++) {
    sum += 0.1f;
}
printf("sum = %f\n", sum);        // 期望：100000
printf("实际 = %f\n", sum);       // 实际：约 100958.34...
```

**解决方案：Kahan 求和算法**

```c
float kahan_sum(float* arr, int n) {
    float sum = 0.0f;
    float c = 0.0f;  // 误差补偿

    for (int i = 0; i < n; i++) {
        float y = arr[i] - c;
        float t = sum + y;
        c = (t - sum) - y;  // 计算丢失的低位
        sum = t;
    }
    return sum;
}
```

### 8.4 比较陷阱

```c
// 错误的比较方式
if (a == b) { ... }  // 几乎永远不要这样比较浮点数

// 正确的比较方式：使用 epsilon
#include <math.h>
#include <float.h>

// 方法1：绝对误差（适用于小数值）
int equal_abs(double a, double b, double epsilon) {
    return fabs(a - b) < epsilon;
}

// 方法2：相对误差（适用于大数值）
int equal_rel(double a, double b, double epsilon) {
    return fabs(a - b) <= epsilon * fmax(fabs(a), fabs(b));
}

// 方法3：ULP 比较（最精确）
int equal_ulp(double a, double b, int max_ulp) {
    // 比较两个浮点数相差多少个最小单位
    // 实现较复杂，需要处理符号和特殊值
}
```

### 8.5 整数转浮点的精度丢失

```c
int big_int = 123456789;
float f = big_int;
int back = (int)f;

printf("原始: %d\n", big_int);   // 123456789
printf("转回: %d\n", back);      // 123456792  不一样！
```

**原因：** float 只有 24 位有效精度，而 123456789 需要 27 位。

```
123456789 = 111010110111100110100010101 (27 位)
float 只能精确表示 24 位，后 3 位被舍入
```

**规则：**
- 32 位 int 可以精确转换为 double（53 位尾数 > 32 位）
- 32 位 int 不能精确转换为 float（24 位尾数 < 32 位）
- 64 位 long long 不能精确转换为 double

---

## 9. 浮点运算的特殊规则

### 9.1 运算结果表

| 运算 | 结果 |
|------|------|
| `x / 0` (x > 0) | +∞ |
| `x / 0` (x < 0) | -∞ |
| `0 / 0` | NaN |
| `∞ + ∞` | +∞ |
| `∞ - ∞` | NaN |
| `∞ × 0` | NaN |
| `∞ × ∞` | ∞ |
| `∞ / ∞` | NaN |
| `sqrt(-1)` | NaN |
| `log(-1)` | NaN |

### 9.2 NaN 的传播

任何涉及 NaN 的运算结果都是 NaN：

```c
NaN + 1 = NaN
NaN * 0 = NaN
NaN < 5 = false
NaN > 5 = false
NaN == NaN = false
```

### 9.3 无穷的运算

```c
∞ + 1 = ∞
∞ - 1 = ∞
∞ * 2 = ∞
∞ / 2 = ∞
1 / ∞ = 0
∞ > x = true (对任何有限 x)
```

---

## 10. 舍入模式

IEEE 754 定义了四种舍入模式：

### 10.1 四种舍入模式

| 模式 | 描述 | 示例 (保留 1 位小数) |
|------|------|---------------------|
| Round to Nearest, Even | 四舍五入，中间值取偶数 | 2.5→2, 3.5→4, 2.25→2.2 |
| Round toward +∞ | 向正无穷舍入（天花板） | 2.1→3, -2.9→-2 |
| Round toward -∞ | 向负无穷舍入（地板） | 2.9→2, -2.1→-3 |
| Round toward 0 | 向零舍入（截断） | 2.9→2, -2.9→-2 |

### 10.2 默认模式：Round to Nearest, Even

**为什么选择"偶数"？**

避免统计偏差。如果总是"四舍五入"，中间值（如 2.5）总是向上，累积起来会有正偏差。

```
传统四舍五入：
1.5 → 2, 2.5 → 3, 3.5 → 4, 4.5 → 5
平均增量：(0.5 + 0.5 + 0.5 + 0.5) / 4 = 0.5（正偏差）

银行家舍入（Round to Even）：
1.5 → 2, 2.5 → 2, 3.5 → 4, 4.5 → 4
平均增量：(0.5 - 0.5 + 0.5 - 0.5) / 4 = 0（无偏差）
```

### 10.3 C 语言中设置舍入模式

```c
#include <fenv.h>

// 获取当前舍入模式
int mode = fegetround();

// 设置舍入模式
fesetround(FE_TONEAREST);   // 默认：四舍五入到偶数
fesetround(FE_UPWARD);      // 向正无穷
fesetround(FE_DOWNWARD);    // 向负无穷
fesetround(FE_TOWARDZERO);  // 向零
```

---

## 11. CPU 中的浮点单元

### 11.1 x87 FPU（传统）

```
x87 浮点寄存器栈：

ST(7) ┌─────────────────────┐
ST(6) │                     │
ST(5) │    80 位扩展精度    │
ST(4) │                     │
ST(3) │  (内部使用更高精度)  │
ST(2) │                     │
ST(1) │                     │
ST(0) └─────────────────────┘ ← 栈顶
```

**特点：**
- 8 个 80 位寄存器，栈式访问
- 内部使用 80 位扩展精度计算
- 结果写回内存时舍入到 32/64 位

### 11.2 SSE/AVX（现代）

```
XMM 寄存器（SSE）：128 位
┌─────────────────────────────────────────────────┐
│  float3  │  float2  │  float1  │  float0       │
│   32位   │   32位   │   32位   │   32位        │
└─────────────────────────────────────────────────┘

或

┌─────────────────────────────────────────────────┐
│         double1         │        double0        │
│          64位           │         64位          │
└─────────────────────────────────────────────────┘

YMM 寄存器（AVX）：256 位
ZMM 寄存器（AVX-512）：512 位
```

**特点：**
- 16 个（或 32 个）向量寄存器
- SIMD 并行计算
- 直接以目标精度计算（无扩展精度）

### 11.3 x87 vs SSE 的精度差异

```c
// 这段代码在 x87 和 SSE 模式下可能有不同结果！
double a = 1.0;
double b = 3.0;
double c = a / b;  // x87: 80位精度计算后舍入到64位
                   // SSE: 直接64位精度计算

// 如果 c 被存入寄存器而非内存，差异更明显
if (c * 3.0 == 1.0) {  // x87: 可能为 true
                        // SSE: 可能为 false
}
```

---

## 12. 实用技巧与最佳实践

### 12.1 浮点数比较函数

```c
#include <math.h>
#include <float.h>
#include <stdbool.h>

// 通用比较函数
bool float_equal(double a, double b, double rel_tol, double abs_tol) {
    // 处理特殊情况
    if (isnan(a) || isnan(b)) return false;
    if (isinf(a) || isinf(b)) return a == b;

    double diff = fabs(a - b);

    // 绝对误差检查（处理接近零的情况）
    if (diff < abs_tol) return true;

    // 相对误差检查
    double largest = fmax(fabs(a), fabs(b));
    return diff <= largest * rel_tol;
}

// 简化版本
bool nearly_equal(double a, double b) {
    return float_equal(a, b, 1e-9, 1e-12);
}
```

### 12.2 检测特殊值

```c
#include <math.h>

double x = some_calculation();

if (isnan(x)) {
    printf("结果是 NaN\n");
}

if (isinf(x)) {
    printf("结果是无穷大\n");
}

if (isfinite(x)) {
    printf("结果是有限数\n");
}

if (isnormal(x)) {
    printf("结果是规格化数\n");
}

// 检测 NaN 的另一种方法
if (x != x) {
    printf("x 是 NaN\n");
}
```

### 12.3 查看浮点数的二进制表示

```c
#include <stdio.h>
#include <stdint.h>

void print_float_bits(float f) {
    uint32_t bits = *(uint32_t*)&f;

    int sign = (bits >> 31) & 1;
    int exp = (bits >> 23) & 0xFF;
    int mantissa = bits & 0x7FFFFF;

    printf("Float: %f\n", f);
    printf("Hex: 0x%08X\n", bits);
    printf("Sign: %d\n", sign);
    printf("Exponent: %d (biased), %d (actual)\n", exp, exp - 127);
    printf("Mantissa: 0x%06X\n", mantissa);
    printf("Binary: ");

    for (int i = 31; i >= 0; i--) {
        printf("%d", (bits >> i) & 1);
        if (i == 31 || i == 23) printf(" ");
    }
    printf("\n\n");
}

void print_double_bits(double d) {
    uint64_t bits = *(uint64_t*)&d;

    int sign = (bits >> 63) & 1;
    int exp = (bits >> 52) & 0x7FF;
    uint64_t mantissa = bits & 0xFFFFFFFFFFFFFULL;

    printf("Double: %.15f\n", d);
    printf("Hex: 0x%016llX\n", bits);
    printf("Sign: %d\n", sign);
    printf("Exponent: %d (biased), %d (actual)\n", exp, exp - 1023);
    printf("Mantissa: 0x%013llX\n", mantissa);
    printf("\n");
}

int main() {
    print_float_bits(3.14159f);
    print_float_bits(-12.375f);
    print_float_bits(0.1f);
    print_float_bits(1.0f / 0.0f);  // +∞
    print_float_bits(0.0f / 0.0f);  // NaN

    print_double_bits(3.141592653589793);

    return 0;
}
```

### 12.4 避免精度问题的策略

**1. 金融计算：使用整数**
```c
// 错误：使用浮点
double price = 19.99;
double total = price * 100;  // 可能是 1998.9999...

// 正确：使用整数（以分为单位）
int price_cents = 1999;
int total_cents = price_cents * 100;  // 精确 199900
```

**2. 累加：从小到大排序**
```c
// 更好的累加顺序：先加小数
float sum_better(float* arr, int n) {
    // 先排序，从小到大
    qsort(arr, n, sizeof(float), compare_float);

    float sum = 0;
    for (int i = 0; i < n; i++) {
        sum += arr[i];
    }
    return sum;
}
```

**3. 比较：考虑相对误差**
```c
// 根据数值大小选择合适的 epsilon
double epsilon = fmax(fabs(a), fabs(b)) * DBL_EPSILON * 100;
```

---

## 13. 浮点异常

### 13.1 五种浮点异常

| 异常 | 触发条件 | 默认结果 |
|------|----------|----------|
| Invalid | 无效操作（如 sqrt(-1)） | NaN |
| Division by Zero | 除以零 | ±∞ |
| Overflow | 结果太大 | ±∞ |
| Underflow | 结果太小（非规格化或零） | 非规格化数或 0 |
| Inexact | 结果被舍入 | 舍入后的值 |

### 13.2 C 语言中处理浮点异常

```c
#include <fenv.h>

#pragma STDC FENV_ACCESS ON

int main() {
    // 清除所有异常标志
    feclearexcept(FE_ALL_EXCEPT);

    // 执行计算
    double result = 1.0 / 0.0;

    // 检查异常
    if (fetestexcept(FE_DIVBYZERO)) {
        printf("发生除零异常\n");
    }

    if (fetestexcept(FE_OVERFLOW)) {
        printf("发生溢出异常\n");
    }

    if (fetestexcept(FE_INVALID)) {
        printf("发生无效操作异常\n");
    }

    return 0;
}
```

---

## 14. 常量与宏

```c
#include <float.h>
#include <math.h>

// float 相关常量
FLT_MAX        // 最大有限值 (~3.4e38)
FLT_MIN        // 最小正规格化值 (~1.2e-38)
FLT_TRUE_MIN   // 最小正值（含非规格化，C11）
FLT_EPSILON    // 1.0 和下一个可表示值的差 (~1.2e-7)
FLT_DIG        // 十进制有效数字 (6)
FLT_MANT_DIG   // 尾数位数 (24，含隐含位)

// double 相关常量
DBL_MAX        // ~1.8e308
DBL_MIN        // ~2.2e-308
DBL_EPSILON    // ~2.2e-16
DBL_DIG        // 15

// 数学常量（math.h，部分实现）
M_PI           // π
M_E            // e
M_SQRT2        // √2

// 特殊值
INFINITY       // 正无穷
NAN            // NaN（Quiet NaN）
HUGE_VAL       // double 溢出返回值
HUGE_VALF      // float 溢出返回值
```

---

## 15. 总结

### 15.1 IEEE 754 核心公式

```
规格化数：   (-1)^S × 1.M × 2^(E-Bias)
非规格化数： (-1)^S × 0.M × 2^(1-Bias)
```

### 15.2 快速参考表

| 特性 | float | double |
|------|-------|--------|
| 总位数 | 32 | 64 |
| 指数位 | 8 | 11 |
| 尾数位 | 23 | 52 |
| Bias | 127 | 1023 |
| 十进制精度 | ~7 位 | ~15 位 |
| 最大值 | ~3.4×10³⁸ | ~1.8×10³⁰⁸ |
| 最小正规格化 | ~1.2×10⁻³⁸ | ~2.2×10⁻³⁰⁸ |

### 15.3 核心注意事项

| 问题 | 原因 | 解决方案 |
|------|------|----------|
| 0.1+0.2≠0.3 | 二进制无法精确表示 | 使用 epsilon 比较 |
| 大数吃小数 | 有效位数有限 | 使用更高精度或特殊算法 |
| 累积误差 | 多次舍入误差叠加 | Kahan 求和算法 |
| 比较失败 | 直接用 == 比较 | 使用误差范围比较 |
| 整数精度丢失 | float 只有 24 位精度 | 大整数用 double |

### 15.4 黄金法则

1. **永远不要用 == 直接比较浮点数**
2. **金融计算使用整数或定点数**
3. **了解你的精度需求，选择合适的类型**
4. **注意运算顺序对精度的影响**
5. **处理特殊值（NaN、Inf）的边界情况**

---

## 16. 字节序问题（Endianness）

### 16.1 什么是字节序

字节序决定了多字节数据在内存中的存储顺序：

```
数值 0x12345678 在内存中的存储：

大端（Big Endian）- 高位在前，符合人类阅读习惯
地址:    0x00  0x01  0x02  0x03
内容:    0x12  0x34  0x56  0x78

小端（Little Endian）- 低位在前，x86/ARM 默认
地址:    0x00  0x01  0x02  0x03
内容:    0x78  0x56  0x34  0x12
```

### 16.2 浮点数的字节序

浮点数同样受字节序影响：

```c
float f = 1.0f;  // IEEE 754: 0x3F800000

// 小端（x86）内存布局：
// 地址:  0x00  0x01  0x02  0x03
// 内容:  0x00  0x00  0x80  0x3F

// 大端内存布局：
// 地址:  0x00  0x01  0x02  0x03
// 内容:  0x3F  0x80  0x00  0x00
```

### 16.3 跨平台传输

**问题：** 网络传输或文件存储时，不同架构的机器可能使用不同字节序。

**解决方案：**

```c
#include <stdint.h>

// 方法1：使用网络字节序（大端）
// 需要自己实现浮点版本，因为 htonl/ntohl 只处理整数

uint32_t float_to_network(float f) {
    uint32_t i = *(uint32_t*)&f;
    return htonl(i);  // 转为网络字节序（大端）
}

float network_to_float(uint32_t n) {
    uint32_t i = ntohl(n);  // 从网络字节序转回
    return *(float*)&i;
}

// 方法2：手动字节交换
float swap_float(float f) {
    uint32_t i = *(uint32_t*)&f;
    i = ((i >> 24) & 0xFF) |
        ((i >> 8) & 0xFF00) |
        ((i << 8) & 0xFF0000) |
        ((i << 24) & 0xFF000000);
    return *(float*)&i;
}

// 方法3：使用文本格式（最安全但最慢）
// 如 JSON、CSV，避免字节序问题
```

### 16.4 检测当前系统字节序

```c
int is_little_endian() {
    uint32_t x = 1;
    return *(uint8_t*)&x == 1;
}

// 或者使用编译器宏
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
    // 小端系统
#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
    // 大端系统
#endif
```

---

## 17. 编译器优化对浮点运算的影响

### 17.1 严格模式 vs 快速模式

编译器可以对浮点运算进行激进优化，但可能改变计算结果：

```bash
# GCC/Clang 选项
-ffast-math        # 启用所有激进优化（危险！）
-fno-fast-math     # 禁用（默认）

-funsafe-math-optimizations  # 允许不安全的数学优化
-ffinite-math-only           # 假设没有 NaN 和 Inf
-fno-signed-zeros            # 忽略 +0/-0 的区别
-fno-trapping-math           # 假设浮点运算不会触发异常
-fassociative-math           # 允许重新结合（改变运算顺序）
-freciprocal-math            # 允许用 x * (1/y) 代替 x / y
```

### 17.2 -ffast-math 的具体影响

```c
// 原始代码
double result = a + b + c;

// 标准模式：严格按顺序计算
// temp = a + b;
// result = temp + c;

// -ffast-math：可能重新排列
// 可能变成 (a + c) + b 如果编译器认为更高效
// 结果可能不同！（浮点加法不满足结合律）
```

**示例：结合律失效**

```c
#include <stdio.h>

int main() {
    double a = 1e16;
    double b = -1e16;
    double c = 1.0;

    // 数学上：(a + b) + c = a + (b + c) = 1.0
    // 但浮点运算：
    printf("(a + b) + c = %f\n", (a + b) + c);  // 1.0
    printf("a + (b + c) = %f\n", a + (b + c));  // 0.0 ！

    // 因为 b + c = -1e16（c 被吃掉了）
    // 然后 a + (-1e16) = 0

    return 0;
}
```

### 17.3 FMA 指令与 -ffp-contract

**FMA (Fused Multiply-Add)：** `a * b + c` 用一条指令完成，只舍入一次。

```bash
-ffp-contract=off   # 禁止融合，每步都舍入
-ffp-contract=on    # 只在同一表达式内融合
-ffp-contract=fast  # 跨语句融合（-ffast-math 默认）
```

```c
// FMA 影响示例
double a = 1.0 + 1e-16;
double b = 1.0 - 1e-16;
double c = -1.0;

// 不使用 FMA：
// temp = a * b = 1.0（1e-32 被舍入掉）
// result = temp + c = 0.0

// 使用 FMA：
// result = fma(a, b, c) = a*b + c
// 内部以更高精度计算，结果可能是 -1e-32 而非 0
```

### 17.4 推荐实践

```c
// 1. 需要精确结果时，不要用 -ffast-math
// 2. 如果必须用，至少测试关键算法

// 3. 使用 #pragma 精确控制
#pragma STDC FP_CONTRACT OFF  // 禁止当前作用域的 FMA 优化

// 4. 在 GCC 中局部禁用
__attribute__((optimize("-fno-fast-math")))
double precise_calculation(double x) {
    // 这个函数不受 -ffast-math 影响
}

// 5. 使用 volatile 强制内存读写（阻止某些优化）
volatile double temp = a + b;
double result = temp + c;  // 强制按顺序计算
```

---

## 18. 多线程与原子性

### 18.1 浮点读写是原子的吗？

**简短回答：不一定。**

- **32 位 float：** 在大多数现代架构上，对齐的 32 位读写是原子的
- **64 位 double：** 在 32 位系统上可能不是原子的！
- **80 位 long double：** 几乎肯定不是原子的

```c
// 危险：32 位系统上的 double
double shared_value;  // 可能被撕裂（torn read/write）

// 线程 1 写入 0x0123456789ABCDEF
// 线程 2 可能读到 0x01234567XXXXXXXX（只读到一半）
```

### 18.2 C11 原子浮点

```c
#include <stdatomic.h>

// C11 不直接支持 atomic_double，但可以用 _Atomic
_Atomic double atomic_val;

// 原子读
double read_val = atomic_load(&atomic_val);

// 原子写
atomic_store(&atomic_val, 3.14);

// 注意：没有原子的浮点运算（如原子加法）
// 需要用 CAS 循环实现
double atomic_add(atomic_double* val, double delta) {
    double old = atomic_load(val);
    while (!atomic_compare_exchange_weak(val, &old, old + delta));
    return old;
}
```

### 18.3 使用锁保护

```c
#include <pthread.h>

typedef struct {
    double value;
    pthread_mutex_t mutex;
} protected_double;

void safe_write(protected_double* pd, double val) {
    pthread_mutex_lock(&pd->mutex);
    pd->value = val;
    pthread_mutex_unlock(&pd->mutex);
}

double safe_read(protected_double* pd) {
    pthread_mutex_lock(&pd->mutex);
    double val = pd->value;
    pthread_mutex_unlock(&pd->mutex);
    return val;
}
```

### 18.4 x86 特定行为

在 x86/x64 上：

```c
// 对齐的 64 位读写在 64 位模式下是原子的
// 但编译器可能重排序！

// 使用 volatile 防止编译器优化
volatile double shared;

// 或使用内存屏障
__atomic_thread_fence(__ATOMIC_SEQ_CST);
```

---

## 19. 半精度与新格式

### 19.1 格式总览

| 格式 | 位数 | 符号 | 指数 | 尾数 | 范围 | 用途 |
|------|------|------|------|------|------|------|
| FP16 (IEEE) | 16 | 1 | 5 | 10 | ±6.5×10⁴ | GPU、深度学习推理 |
| BF16 | 16 | 1 | 8 | 7 | ±3.4×10³⁸ | 深度学习训练 |
| TF32 | 19 | 1 | 8 | 10 | ±3.4×10³⁸ | NVIDIA Tensor Core |
| FP32 | 32 | 1 | 8 | 23 | ±3.4×10³⁸ | 通用计算 |
| FP64 | 64 | 1 | 11 | 52 | ±1.8×10³⁰⁸ | 科学计算 |

### 19.2 FP16（IEEE 754 半精度）

```
 15 14    10 9           0
┌───┬────────┬─────────────┐
│ S │  Exp   │  Mantissa   │
│ 1 │   5    │     10      │
└───┴────────┴─────────────┘

Bias = 15
范围：6.1×10⁻⁵ ~ 6.5×10⁴
精度：约 3-4 位十进制有效数字
```

**特点：**
- 范围小，容易溢出/下溢
- 精度低，只适合对精度要求不高的场景
- 节省内存和带宽

### 19.3 BF16（Brain Float 16）

```
 15 14        7 6        0
┌───┬──────────┬──────────┐
│ S │   Exp    │ Mantissa │
│ 1 │    8     │    7     │
└───┴──────────┴──────────┘

Bias = 127（与 FP32 相同！）
```

**特点：**
- 与 FP32 相同的指数范围（不易溢出）
- 精度比 FP16 更低
- FP32 转 BF16 只需截断尾数（快速）
- Google Brain 发明，用于 TPU

```c
// FP32 到 BF16 的转换（简化版，忽略舍入）
uint16_t fp32_to_bf16(float f) {
    uint32_t bits = *(uint32_t*)&f;
    return (uint16_t)(bits >> 16);  // 直接取高 16 位
}
```

### 19.4 TF32（TensorFloat-32）

```
 18 17         9 8        0
┌───┬───────────┬──────────┐
│ S │    Exp    │ Mantissa │
│ 1 │     8     │    10    │
└───┴───────────┴──────────┘
```

**特点：**
- NVIDIA Ampere 架构引入
- 存储用 FP32，但 Tensor Core 计算时只用 19 位精度
- 平衡精度和性能

### 19.5 混合精度训练

现代深度学习常用混合精度：

```python
# 伪代码：混合精度训练
def train_step(model, data, loss_scale=1024):
    # 前向传播：FP16 加速
    with autocast(dtype=float16):
        output = model(data)
        loss = compute_loss(output)

    # 缩放损失以防止梯度下溢
    scaled_loss = loss * loss_scale

    # 反向传播：仍是 FP16
    scaled_loss.backward()

    # 更新权重：FP32 精度
    # 先将梯度转回 FP32 并除以 scale
    for param in model.parameters():
        param.grad = param.grad.float() / loss_scale
        param.data -= learning_rate * param.grad
```

### 19.6 C/C++ 中使用半精度

```c
// 使用编译器内置类型（需要编译器支持）
#include <arm_fp16.h>   // ARM
// 或
__fp16 half_val;        // GCC/Clang on ARM

// 使用库
#include <half.hpp>     // half 库

// 手动转换
uint16_t float_to_half(float f) {
    uint32_t x = *(uint32_t*)&f;
    uint16_t h;

    uint32_t sign = (x >> 16) & 0x8000;
    int32_t exp = ((x >> 23) & 0xFF) - 127 + 15;
    uint32_t mant = (x >> 13) & 0x3FF;

    if (exp <= 0) {
        h = sign;  // 下溢到零
    } else if (exp >= 31) {
        h = sign | 0x7C00;  // 溢出到无穷
    } else {
        h = sign | (exp << 10) | mant;
    }

    return h;
}
```

---

## 20. 定点数替代方案

### 20.1 什么是定点数

定点数用整数表示小数，小数点位置固定：

```
Q8.8 格式（8 位整数 + 8 位小数）：

16 位整数值 256 表示 1.0
16 位整数值 512 表示 2.0
16 位整数值 384 表示 1.5
16 位整数值 1   表示 0.00390625 (1/256)

转换公式：
实际值 = 整数值 / 2^小数位数
整数值 = 实际值 × 2^小数位数
```

### 20.2 定点数运算

```c
typedef int32_t fixed_t;  // Q16.16 格式

#define FIXED_SHIFT 16
#define FIXED_ONE (1 << FIXED_SHIFT)  // 65536 表示 1.0

// 从浮点转换
fixed_t float_to_fixed(float f) {
    return (fixed_t)(f * FIXED_ONE);
}

// 转回浮点
float fixed_to_float(fixed_t x) {
    return (float)x / FIXED_ONE;
}

// 加法：直接加
fixed_t fixed_add(fixed_t a, fixed_t b) {
    return a + b;
}

// 乘法：需要移位
fixed_t fixed_mul(fixed_t a, fixed_t b) {
    // 使用 64 位中间结果防止溢出
    int64_t temp = (int64_t)a * b;
    return (fixed_t)(temp >> FIXED_SHIFT);
}

// 除法：先左移再除
fixed_t fixed_div(fixed_t a, fixed_t b) {
    int64_t temp = (int64_t)a << FIXED_SHIFT;
    return (fixed_t)(temp / b);
}
```

### 20.3 定点数 vs 浮点数

| 特性 | 定点数 | 浮点数 |
|------|--------|--------|
| 精度 | 固定，可预测 | 动态，随值变化 |
| 范围 | 固定，较小 | 很大 |
| 运算速度 | 快（整数运算） | 较慢（需要 FPU） |
| 舍入误差 | 可预测 | 难以预测 |
| 适用场景 | 嵌入式、音频、金融 | 科学计算、图形 |

### 20.4 金融计算：使用整数

```c
// 金融计算：使用最小单位（分）作为整数

typedef int64_t money_t;  // 单位：分

money_t dollars_to_cents(double dollars) {
    // 四舍五入到最近的分
    return (money_t)(dollars * 100 + 0.5);
}

double cents_to_dollars(money_t cents) {
    return (double)cents / 100;
}

// 加法
money_t money_add(money_t a, money_t b) {
    return a + b;  // 精确！
}

// 乘以比率（如税率 8.5%）
money_t money_multiply_rate(money_t amount, int rate_bps) {
    // rate_bps: 基点（1/10000），8.5% = 850 基点
    return (amount * rate_bps + 5000) / 10000;  // 四舍五入
}

// 示例
int main() {
    money_t price = 1999;  // $19.99
    money_t tax = money_multiply_rate(price, 850);  // 8.5% 税
    money_t total = money_add(price, tax);

    printf("Price: $%.2f\n", cents_to_dollars(price));   // $19.99
    printf("Tax:   $%.2f\n", cents_to_dollars(tax));     // $1.70
    printf("Total: $%.2f\n", cents_to_dollars(total));   // $21.69

    return 0;
}
```

### 20.5 嵌入式系统中的定点数

```c
// 无 FPU 的嵌入式系统常用 Q15 格式

typedef int16_t q15_t;  // Q1.15：1 位符号 + 15 位小数

#define Q15_ONE 0x7FFF  // 0.999969... (接近 1)

// 范围：-1.0 ~ 0.999969...

q15_t q15_mul(q15_t a, q15_t b) {
    int32_t temp = (int32_t)a * b;
    return (q15_t)(temp >> 15);
}

// 常用于数字信号处理（DSP）
// ARM CMSIS-DSP 库提供了优化的定点运算函数
```

---

## 21. 著名浮点数事故案例

### 21.1 爱国者导弹事件（1991）

**事件：** 1991 年海湾战争期间，美国爱国者导弹系统因浮点误差未能拦截伊拉克飞毛腿导弹，导致 28 名美军士兵死亡。

**原因：**

```c
// 系统使用 24 位定点数表示时间（单位：0.1 秒）

// 问题：0.1 秒无法精确表示
// 0.1 (十进制) = 0.00011001100110011... (二进制，无限循环)

// 24 位定点数表示：
// 0.1 ≈ 0.00011001100110011001100 (截断)
// 实际值 ≈ 0.09999990463...
// 每 0.1 秒误差：0.000000095 秒

// 系统运行 100 小时后的累积误差：
// 100 小时 = 100 × 60 × 60 × 10 = 3,600,000 个 0.1 秒
// 总误差 = 3,600,000 × 0.000000095 ≈ 0.34 秒

// 飞毛腿导弹速度约 1676 m/s
// 0.34 秒的误差 = 570 米的定位偏差
// 导弹完全错过目标
```

**教训：**
- 累积误差会随时间增长
- 关键系统需要定期校准或重启
- 选择合适的数据表示方式

### 21.2 阿丽亚娜 5 号火箭爆炸（1996）

**事件：** 欧洲航天局阿丽亚娜 5 号火箭首飞后 37 秒爆炸自毁，损失 5 亿美元。

**原因：**

```ada
-- 惯性导航系统代码（从阿丽亚娜 4 号继承）
-- 将 64 位浮点数转换为 16 位有符号整数

horizontal_velocity : Float_64;  -- 水平速度
velocity_int : Integer_16;       -- 转换后的整数

velocity_int := Integer_16(horizontal_velocity);  -- 溢出！

-- 阿丽亚娜 4 号：水平速度较小，在 16 位范围内
-- 阿丽亚娜 5 号：更强的发动机，水平速度超过 32767

-- 当速度超过 32767 时，转换溢出
-- 导航系统报错，备份系统也是同样的代码，也报错
-- 飞行控制软件收到错误数据，执行了剧烈的姿态修正
-- 火箭解体，自毁程序启动
```

**教训：**
- 复用代码时要验证前置假设
- 整数溢出和浮点转换需要边界检查
- 备份系统不应该有相同的缺陷

### 21.3 温哥华股票交易所指数错误（1982）

**事件：** 温哥华股票交易所指数从 1000 点开始，22 个月后跌到 520 点，而实际应该在 1098 点左右。

**原因：**

```c
// 指数计算：每次交易后更新并截断到小数点后 3 位

double index = 1000.0;

void update_index(double change) {
    index = index + change;
    // 截断到 3 位小数（向下截断）
    index = floor(index * 1000) / 1000;
}

// 问题：截断总是向下，永远不会向上舍入
// 每天约 3000 次更新，每次平均损失约 0.0005
// 22 个月累积误差巨大
```

**教训：**
- 截断 vs 四舍五入的选择很重要
- 高频更新会放大舍入误差

### 21.4 Excel 2007 乘法 Bug

**事件：** Excel 2007 中，某些乘法结果显示错误。

```
850 × 77.1 显示为 100000，而非正确的 65535

原因：65535 是 16 位无符号整数的最大值
内部计算正确，但显示模块有 bug
将接近 65535 的浮点结果错误显示为 100000
```

### 21.5 JavaScript 大整数问题

```javascript
// JavaScript 所有数字都是 64 位浮点数

console.log(9007199254740992 === 9007199254740993);  // true!

// 2^53 = 9007199254740992 是能精确表示的最大整数
// 超过这个值，整数精度开始丢失

// 实际应用中的问题：
// Twitter 曾因推文 ID 超过 2^53 导致 API 返回错误 ID
// 解决方案：用字符串传输大整数
```

### 21.6 波音 787 电力系统 Bug（2015）

**事件：** FAA 发布适航指令，要求每 248 天重启一次波音 787 的电力系统。

**原因：**

```c
// 系统使用 32 位有符号整数计数器（单位：10 毫秒）

int32_t uptime_ticks;  // 运行时间计数器

// 248 天后溢出：
// 248 天 × 24 × 60 × 60 × 100 = 2,142,720,000 ticks
// 接近 INT32_MAX = 2,147,483,647

// 溢出后变为负数，触发安全机制，导致所有发电机同时进入故障保护模式
// 飞机在飞行中可能完全失去电力
```

**教训：**
- 整数溢出同样危险
- 长时间运行的系统需要考虑计数器溢出

---

## 22. 浮点数序列化问题

### 22.1 JSON 精度问题

JSON 规范没有限制数字精度，但大多数实现用双精度浮点：

```javascript
// JavaScript (JSON.parse 使用 64 位浮点)
JSON.parse('{"id": 9007199254740993}')
// 结果：{id: 9007199254740992}  // 精度丢失！

// 解决方案：大整数用字符串传输
{"id": "9007199254740993"}
```

### 22.2 二进制格式：跨平台问题

```c
// 问题1：字节序
float f = 1.5f;
fwrite(&f, sizeof(float), 1, file);  // 不同平台读取可能不同

// 问题2：浮点格式
// 虽然大多数系统用 IEEE 754，但不是全部
// 某些老系统（VAX）使用不同格式

// 解决方案：使用可移植的序列化格式
// - Protocol Buffers
// - MessagePack
// - 或手动转换为网络字节序
```

### 22.3 可移植的浮点序列化

```c
#include <stdint.h>
#include <string.h>
#include <arpa/inet.h>

// 方法1：转换为网络字节序
void serialize_float(float f, uint8_t* buf) {
    uint32_t i;
    memcpy(&i, &f, sizeof(i));
    i = htonl(i);
    memcpy(buf, &i, sizeof(i));
}

float deserialize_float(uint8_t* buf) {
    uint32_t i;
    memcpy(&i, buf, sizeof(i));
    i = ntohl(i);
    float f;
    memcpy(&f, &i, sizeof(f));
    return f;
}

// 方法2：分解为整数部分（更可移植）
void serialize_float_portable(float f, uint8_t* buf) {
    // 分解 IEEE 754 格式
    uint32_t bits;
    memcpy(&bits, &f, sizeof(bits));

    int sign = (bits >> 31) & 1;
    int exp = (bits >> 23) & 0xFF;
    int mant = bits & 0x7FFFFF;

    // 按大端序写入
    buf[0] = (sign << 7) | (exp >> 1);
    buf[1] = ((exp & 1) << 7) | (mant >> 16);
    buf[2] = (mant >> 8) & 0xFF;
    buf[3] = mant & 0xFF;
}
```

### 22.4 文本格式的精度

```c
float f = 0.1f;

// 精度不足
printf("%.2f\n", f);  // "0.10" - 无法还原精确值

// 足够的精度（float 用 9 位，double 用 17 位）
printf("%.9g\n", f);  // "0.100000001" - 可以精确还原

// C99 十六进制格式（精确）
printf("%a\n", f);    // "0x1.99999ap-4" - 无损

// 最佳实践：使用 %a 或足够的十进制位数
```

---

## 23. 哈希与相等性问题

### 23.1 为什么浮点数不适合做哈希键

```c
#include <stdio.h>

int main() {
    double a = 0.1 + 0.2;
    double b = 0.3;

    // 逻辑上相等，但位模式不同
    printf("a == b: %d\n", a == b);  // 0 (false)
    printf("a: %016llx\n", *(unsigned long long*)&a);
    printf("b: %016llx\n", *(unsigned long long*)&b);
    // 不同的十六进制值 = 不同的哈希值！

    return 0;
}
```

### 23.2 特殊值的相等性问题

```c
// NaN 的问题
double nan1 = NAN;
double nan2 = NAN;

nan1 == nan2;  // false！NaN 不等于任何值

// 但作为哈希键，我们可能希望所有 NaN 映射到同一个桶

// +0 和 -0 的问题
double pos_zero = +0.0;
double neg_zero = -0.0;

pos_zero == neg_zero;  // true

// 但它们的位模式不同
// 0x0000000000000000 vs 0x8000000000000000
// 默认哈希函数会给出不同结果
```

### 23.3 如果必须用浮点数做键

```c
#include <math.h>
#include <stdint.h>

// 方法1：规范化 + 精度截断
typedef struct {
    int64_t mantissa;
    int exponent;
} normalized_float;

normalized_float normalize_for_hash(double d, int precision) {
    if (isnan(d)) {
        return (normalized_float){0, INT_MIN};  // 所有 NaN 相同
    }
    if (d == 0.0) {
        return (normalized_float){0, 0};  // +0 和 -0 相同
    }

    int exp;
    double mant = frexp(d, &exp);
    // 截断到指定精度
    int64_t imant = (int64_t)(mant * (1LL << precision));

    return (normalized_float){imant, exp};
}

// 方法2：使用 epsilon 范围
// 将浮点数映射到离散的"桶"

int64_t float_to_bucket(double d, double epsilon) {
    return (int64_t)(d / epsilon);
}

// 方法3：使用字符串表示
// 转换为固定精度的字符串，用字符串做键
char* float_to_key(double d, int precision) {
    static char buf[32];
    snprintf(buf, sizeof(buf), "%.*g", precision, d);
    return buf;
}
```

### 23.4 语言标准库的处理

```python
# Python: float 可以做字典键，但有陷阱
d = {}
d[0.1 + 0.2] = "a"
d[0.3] = "b"
print(len(d))  # 2！因为 0.1+0.2 != 0.3

# NaN 作为键
d[float('nan')] = "x"
d[float('nan')] = "y"
print(len(d))  # 2！每个 NaN 是不同的键
```

```java
// Java: Float/Double 作为 HashMap 键
// hashCode() 基于位模式，有相同的问题

Map<Double, String> map = new HashMap<>();
map.put(0.1 + 0.2, "a");
map.put(0.3, "b");
System.out.println(map.size());  // 2

// Float.compare() 和 Double.compare() 正确处理了 NaN 和 ±0
// 但 hashCode() 仍基于位模式
```

### 23.5 推荐做法

```
1. 避免使用浮点数作为哈希键

2. 如果必须使用：
   - 规范化特殊值（NaN → 固定值，-0 → +0）
   - 考虑精度截断
   - 使用专门设计的比较和哈希函数

3. 替代方案：
   - 使用定点数/整数
   - 使用字符串（固定格式）
   - 使用有理数（分子/分母）
```

---

## 24. 数学函数的实现原理

### 24.1 为什么需要了解实现？

CPU 只提供基本运算（加减乘除、平方根），而 sin、cos、exp、log 等函数需要软件实现。了解实现原理有助于：
- 理解精度和性能特性
- 在无标准库环境（嵌入式）中实现
- 优化特定场景的计算

### 24.2 多项式逼近（Taylor/Chebyshev）

**基本思想：** 用多项式近似复杂函数。

**Taylor 展开：**

```
sin(x) = x - x³/3! + x⁵/5! - x⁷/7! + ...
cos(x) = 1 - x²/2! + x⁴/4! - x⁶/6! + ...
exp(x) = 1 + x + x²/2! + x³/3! + ...
ln(1+x) = x - x²/2 + x³/3 - x⁴/4 + ...  (|x| < 1)
```

**实现示例：sin(x)**

```c
#include <math.h>

// 简化版 sin 实现（仅用于演示）
double my_sin(double x) {
    // 1. 范围规约：将 x 归约到 [-π/2, π/2]
    // 利用 sin 的周期性和对称性
    x = fmod(x, 2 * M_PI);
    if (x > M_PI) x -= 2 * M_PI;
    if (x < -M_PI) x += 2 * M_PI;
    if (x > M_PI / 2) x = M_PI - x;
    if (x < -M_PI / 2) x = -M_PI - x;

    // 2. 多项式逼近（Horner 形式，减少乘法次数）
    double x2 = x * x;

    // sin(x) ≈ x(1 - x²/6(1 - x²/20(1 - x²/42)))
    // 等价于 Taylor 展开的前几项
    double result = x * (1.0 - x2 / 6.0 * (1.0 - x2 / 20.0 * (1.0 - x2 / 42.0)));

    return result;
}

// 更精确的版本使用 Chebyshev 多项式或 minimax 逼近
// 标准库通常使用预计算的系数表
```

**Horner 形式的优势：**

```c
// 直接计算：需要多次幂运算
// a₀ + a₁x + a₂x² + a₃x³ + a₄x⁴

// Horner 形式：只需要乘法和加法
// a₀ + x(a₁ + x(a₂ + x(a₃ + x·a₄)))

double horner(double x, double* coeffs, int n) {
    double result = coeffs[n];
    for (int i = n - 1; i >= 0; i--) {
        result = result * x + coeffs[i];
    }
    return result;
}
```

### 24.3 CORDIC 算法

**CORDIC (COordinate Rotation DIgital Computer)**：只用加法、减法和移位计算三角函数，适合无乘法器的硬件。

**基本思想：** 通过一系列固定角度的旋转来逼近目标角度。

```c
#include <stdint.h>

// CORDIC 常量（预计算的 arctan(2^-i)）
static const double cordic_angles[] = {
    0.7853981633974483,   // arctan(2^0) = 45°
    0.4636476090008061,   // arctan(2^-1) = 26.565°
    0.24497866312686414,  // arctan(2^-2) = 14.036°
    0.12435499454676144,  // arctan(2^-3)
    0.06241880999595735,  // arctan(2^-4)
    0.031239833430268277, // arctan(2^-5)
    // ... 更多项以提高精度
};

// CORDIC 增益 K = ∏(1/√(1+2^(-2i))) ≈ 0.6072529350088814
#define CORDIC_GAIN 0.6072529350088814
#define CORDIC_ITERATIONS 16

// 计算 sin 和 cos
void cordic_sincos(double angle, double* sin_out, double* cos_out) {
    double x = CORDIC_GAIN;  // 初始化为增益的倒数
    double y = 0.0;
    double z = angle;

    for (int i = 0; i < CORDIC_ITERATIONS; i++) {
        double d = (z >= 0) ? 1.0 : -1.0;
        double x_new = x - d * y * (1.0 / (1 << i));  // y >> i
        double y_new = y + d * x * (1.0 / (1 << i));  // x >> i
        double z_new = z - d * cordic_angles[i];

        x = x_new;
        y = y_new;
        z = z_new;
    }

    *cos_out = x;
    *sin_out = y;
}

// 整数版本（嵌入式常用）
// 使用定点数，完全避免浮点运算
```

**CORDIC 的优势：**
- 只需加法和移位，无需乘法器
- 适合 FPGA 和简单 MCU
- 可计算多种函数（sin、cos、arctan、sinh、cosh、sqrt、log、exp）

### 24.4 查表法

**基本思想：** 预计算函数值存入表格，运行时查表+插值。

```c
#include <math.h>

#define TABLE_SIZE 256
#define TABLE_SCALE (TABLE_SIZE / (M_PI / 2))

static double sin_table[TABLE_SIZE + 1];

// 初始化查找表
void init_sin_table() {
    for (int i = 0; i <= TABLE_SIZE; i++) {
        sin_table[i] = sin(i / TABLE_SCALE);
    }
}

// 查表计算 sin（线性插值）
double fast_sin(double x) {
    // 范围规约到 [0, π/2]
    int quadrant = 0;
    if (x < 0) { x = -x; quadrant ^= 1; }
    x = fmod(x, 2 * M_PI);
    if (x > M_PI) { x -= M_PI; quadrant ^= 1; }
    if (x > M_PI / 2) { x = M_PI - x; }

    // 查表 + 线性插值
    double index = x * TABLE_SCALE;
    int i = (int)index;
    double frac = index - i;

    double result = sin_table[i] * (1 - frac) + sin_table[i + 1] * frac;

    return (quadrant & 1) ? -result : result;
}
```

### 24.5 指数和对数

**exp(x) 实现思路：**

```c
// exp(x) = exp(n * ln2 + r) = 2^n * exp(r)
// 其中 r 很小，可用多项式逼近

double my_exp(double x) {
    // 处理特殊情况
    if (x != x) return x;  // NaN
    if (x > 709.78) return INFINITY;  // 溢出
    if (x < -745.13) return 0.0;      // 下溢

    // 分解：x = n * ln(2) + r，|r| < ln(2)/2
    const double ln2 = 0.6931471805599453;
    int n = (int)(x / ln2 + (x >= 0 ? 0.5 : -0.5));
    double r = x - n * ln2;

    // 多项式逼近 exp(r)
    double r2 = r * r;
    double result = 1.0 + r * (1.0 + r / 2.0 * (1.0 + r / 3.0 * (1.0 + r / 4.0)));

    // 乘以 2^n（使用 IEEE 754 指数操作）
    // ldexp(x, n) = x * 2^n
    return ldexp(result, n);
}
```

**log(x) 实现思路：**

```c
double my_log(double x) {
    if (x <= 0) return (x == 0) ? -INFINITY : NAN;
    if (x != x) return x;  // NaN

    // 分解：x = m * 2^e，其中 1 <= m < 2
    int e;
    double m = frexp(x, &e);
    m *= 2; e--;  // 调整使 1 <= m < 2

    // log(x) = log(m * 2^e) = log(m) + e * log(2)
    // log(m) 用多项式逼近，m 接近 1

    // 变换：令 u = (m-1)/(m+1)，则 log(m) = 2 * arctanh(u)
    double u = (m - 1) / (m + 1);
    double u2 = u * u;

    // arctanh(u) = u + u³/3 + u⁵/5 + ...
    double log_m = 2 * u * (1 + u2 / 3 * (1 + u2 * 3 / 5 * (1 + u2 * 5 / 7)));

    return log_m + e * 0.6931471805599453;
}
```

### 24.6 标准库实现参考

实际标准库（如 glibc、musl）的实现更复杂：

```
典型优化技术：
1. 精心选择的 minimax 多项式系数
2. 高低位分离计算（避免精度损失）
3. 使用 FMA 指令减少舍入误差
4. 针对特殊值的快速路径
5. 多级范围规约
```

---

## 25. 区间算术（Interval Arithmetic）

### 25.1 什么是区间算术

区间算术用区间 [a, b] 代替单个浮点数，跟踪计算过程中的误差范围。

```
传统浮点：x = 0.1（实际有误差，但不知道多大）
区间算术：x ∈ [0.09999999999999999, 0.10000000000000001]
```

### 25.2 基本运算规则

```
[a, b] + [c, d] = [a+c, b+d]
[a, b] - [c, d] = [a-d, b-c]
[a, b] × [c, d] = [min(ac,ad,bc,bd), max(ac,ad,bc,bd)]
[a, b] / [c, d] = [a,b] × [1/d, 1/c]  (假设 0 ∉ [c,d])
```

### 25.3 C 实现

```c
#include <math.h>
#include <fenv.h>
#include <float.h>

typedef struct {
    double lo;  // 下界
    double hi;  // 上界
} interval;

// 设置舍入模式的辅助函数
static inline void round_down() { fesetround(FE_DOWNWARD); }
static inline void round_up() { fesetround(FE_UPWARD); }
static inline void round_nearest() { fesetround(FE_TONEAREST); }

// 区间加法
interval interval_add(interval a, interval b) {
    interval result;
    round_down();
    result.lo = a.lo + b.lo;
    round_up();
    result.hi = a.hi + b.hi;
    round_nearest();
    return result;
}

// 区间减法
interval interval_sub(interval a, interval b) {
    interval result;
    round_down();
    result.lo = a.lo - b.hi;
    round_up();
    result.hi = a.hi - b.lo;
    round_nearest();
    return result;
}

// 区间乘法
interval interval_mul(interval a, interval b) {
    double products[4];
    round_down();
    products[0] = a.lo * b.lo;
    products[1] = a.lo * b.hi;
    products[2] = a.hi * b.lo;
    products[3] = a.hi * b.hi;

    double lo = fmin(fmin(products[0], products[1]),
                     fmin(products[2], products[3]));

    round_up();
    products[0] = a.lo * b.lo;
    products[1] = a.lo * b.hi;
    products[2] = a.hi * b.lo;
    products[3] = a.hi * b.hi;

    double hi = fmax(fmax(products[0], products[1]),
                     fmax(products[2], products[3]));

    round_nearest();
    return (interval){lo, hi};
}

// 区间平方根
interval interval_sqrt(interval a) {
    if (a.hi < 0) {
        return (interval){NAN, NAN};  // 无效
    }
    interval result;
    round_down();
    result.lo = (a.lo > 0) ? sqrt(a.lo) : 0;
    round_up();
    result.hi = sqrt(a.hi);
    round_nearest();
    return result;
}

// 检查区间是否包含某值
int interval_contains(interval a, double x) {
    return a.lo <= x && x <= a.hi;
}

// 区间宽度（误差范围）
double interval_width(interval a) {
    return a.hi - a.lo;
}

// 使用示例
void demo_interval() {
    // 创建 0.1 的区间表示
    interval x = {0.1, 0.1};  // 实际上有舍入误差

    // 更精确的创建方式
    round_down();
    double lo = 0.1;
    round_up();
    double hi = 0.1;
    round_nearest();
    interval x_precise = {lo, hi};

    // 计算 (0.1 + 0.2) 的区间
    interval a = {0.1, 0.1};
    interval b = {0.2, 0.2};
    interval sum = interval_add(a, b);

    printf("0.1 + 0.2 ∈ [%.17g, %.17g]\n", sum.lo, sum.hi);
    printf("包含 0.3? %d\n", interval_contains(sum, 0.3));
}
```

### 25.4 区间算术的应用

**1. 验证计算结果的可靠性：**

```c
// 判断方程是否有根
// 如果 f([a,b]) 包含 0，则可能有根
// 如果 f([a,b]) 不包含 0，则一定没有根
```

**2. 全局优化：**

```c
// 分支定界法
// 如果某区间的函数值下界大于当前最优值，可以剪枝
```

**3. 计算机辅助证明：**

```c
// 用区间算术证明数学定理
// 如果计算结果的区间满足某条件，则定理成立
```

### 25.5 现有库

```c
// MPFI (Multiple Precision Floating-point Interval)
#include <mpfi.h>

mpfi_t x, y, result;
mpfi_init(x); mpfi_init(y); mpfi_init(result);

mpfi_set_d(x, 0.1);
mpfi_set_d(y, 0.2);
mpfi_add(result, x, y);

mpfi_out_str(stdout, 10, 0, result);  // 输出区间

// Boost.Interval (C++)
#include <boost/numeric/interval.hpp>

using namespace boost::numeric;
interval<double> x(0.1), y(0.2);
interval<double> sum = x + y;
```

---

## 26. 任意精度浮点库

### 26.1 为什么需要任意精度

标准浮点精度有限：
- float: ~7 位十进制
- double: ~15 位十进制

某些场景需要更高精度：
- 密码学（大素数计算）
- 科学计算（天文、物理模拟）
- 金融（精确计算）
- 数学研究（计算 π 到百万位）

### 26.2 GMP（GNU Multiple Precision）

```c
#include <gmp.h>
#include <stdio.h>

int main() {
    // 初始化大整数
    mpz_t a, b, result;
    mpz_init(a);
    mpz_init(b);
    mpz_init(result);

    // 设置值
    mpz_set_str(a, "123456789012345678901234567890", 10);
    mpz_set_str(b, "987654321098765432109876543210", 10);

    // 计算
    mpz_mul(result, a, b);  // result = a * b

    // 输出
    printf("a * b = ");
    mpz_out_str(stdout, 10, result);
    printf("\n");

    // 清理
    mpz_clear(a);
    mpz_clear(b);
    mpz_clear(result);

    return 0;
}

// 编译：gcc -o test test.c -lgmp
```

### 26.3 MPFR（Multiple Precision Floating-point Reliable）

MPFR 基于 GMP，提供正确舍入的浮点运算。

```c
#include <mpfr.h>
#include <stdio.h>

int main() {
    // 设置默认精度（位数）
    mpfr_set_default_prec(256);  // 256 位精度

    mpfr_t x, y, result;
    mpfr_init(x);
    mpfr_init(y);
    mpfr_init(result);

    // 计算 π
    mpfr_const_pi(x, MPFR_RNDN);  // 正确舍入
    printf("π = ");
    mpfr_out_str(stdout, 10, 50, x, MPFR_RNDN);
    printf("\n");

    // 计算 sin(π/6)
    mpfr_const_pi(x, MPFR_RNDN);
    mpfr_div_ui(x, x, 6, MPFR_RNDN);  // x = π/6
    mpfr_sin(result, x, MPFR_RNDN);

    printf("sin(π/6) = ");
    mpfr_out_str(stdout, 10, 50, result, MPFR_RNDN);
    printf("\n");
    // 应该非常接近 0.5

    // 验证 0.1 + 0.2 问题
    mpfr_set_d(x, 0.1, MPFR_RNDN);
    mpfr_set_d(y, 0.2, MPFR_RNDN);
    mpfr_add(result, x, y, MPFR_RNDN);

    printf("0.1 + 0.2 = ");
    mpfr_out_str(stdout, 10, 30, result, MPFR_RNDN);
    printf("\n");

    // 清理
    mpfr_clear(x);
    mpfr_clear(y);
    mpfr_clear(result);

    return 0;
}

// 编译：gcc -o test test.c -lmpfr -lgmp
```

### 26.4 MPFR 的关键特性

```c
// 1. 正确舍入
// 所有运算结果都是正确舍入的，如同无限精度计算后舍入

// 2. 可变精度
mpfr_t x;
mpfr_init2(x, 1000);  // 1000 位精度
mpfr_set_prec(x, 500); // 改变精度

// 3. 多种舍入模式
MPFR_RNDN  // 最近偶数
MPFR_RNDZ  // 向零
MPFR_RNDU  // 向上
MPFR_RNDD  // 向下
MPFR_RNDA  // 远离零

// 4. 丰富的数学函数
mpfr_sin(r, x, rnd);
mpfr_cos(r, x, rnd);
mpfr_exp(r, x, rnd);
mpfr_log(r, x, rnd);
mpfr_pow(r, x, y, rnd);
mpfr_gamma(r, x, rnd);
mpfr_zeta(r, x, rnd);
// ... 以及更多
```

### 26.5 实际应用示例：计算 e 到高精度

```c
#include <mpfr.h>
#include <stdio.h>

// 使用 e = Σ(1/n!) 计算
void compute_e(mpfr_t result, int digits) {
    mpfr_prec_t prec = digits * 4;  // 大约 3.32 位/十进制位，留余量

    mpfr_t term, factorial;
    mpfr_init2(term, prec);
    mpfr_init2(factorial, prec);
    mpfr_init2(result, prec);

    mpfr_set_ui(result, 1, MPFR_RNDN);     // e = 1
    mpfr_set_ui(factorial, 1, MPFR_RNDN);  // 0! = 1

    for (int n = 1; ; n++) {
        mpfr_mul_ui(factorial, factorial, n, MPFR_RNDN);  // n!
        mpfr_ui_div(term, 1, factorial, MPFR_RNDN);       // 1/n!

        // 检查是否足够小
        if (mpfr_get_exp(term) < -prec) break;

        mpfr_add(result, result, term, MPFR_RNDN);
    }

    mpfr_clear(term);
    mpfr_clear(factorial);
}

int main() {
    mpfr_t e;
    mpfr_init(e);

    compute_e(e, 100);  // 计算 100 位

    printf("e = ");
    mpfr_out_str(stdout, 10, 100, e, MPFR_RNDN);
    printf("\n");

    mpfr_clear(e);
    return 0;
}
```

### 26.6 性能考虑

```
精度 vs 性能（相对于 double）：

精度(位)    加法     乘法      除法
64         1x       1x        1x
128        ~2x      ~4x       ~6x
256        ~4x      ~10x      ~20x
1024       ~20x     ~100x     ~300x
```

**优化建议：**
- 只在需要时使用高精度
- 中间计算可用较低精度
- 使用 MPFR 的原地操作减少内存分配

---

## 27. Decimal 浮点（IEEE 754-2008）

### 27.1 为什么需要 Decimal 浮点

二进制浮点无法精确表示十进制小数：

```c
// 二进制浮点
double x = 0.1;
// 实际存储的是 0.1000000000000000055511151231257827021181583404541015625

// Decimal 浮点可以精确表示
// decimal64 x = 0.1;  // 精确的 0.1
```

**主要应用：金融计算**

### 27.2 IEEE 754-2008 Decimal 格式

| 格式 | 总位数 | 有效数字 | 指数范围 |
|------|--------|----------|----------|
| decimal32 | 32 | 7 | -95 ~ 96 |
| decimal64 | 64 | 16 | -383 ~ 384 |
| decimal128 | 128 | 34 | -6143 ~ 6144 |

### 27.3 C 语言支持（C23/编译器扩展）

```c
// GCC 支持（需要 libdfp）
#include <math.h>

// _Decimal32, _Decimal64, _Decimal128 类型
_Decimal64 price = 19.99DD;
_Decimal64 quantity = 3.0DD;
_Decimal64 total = price * quantity;  // 精确的 59.97

printf("Total: %Df\n", total);

// 与 double 的转换
double d = (double)total;
_Decimal64 dec = (_Decimal64)d;  // 可能有精度损失
```

### 27.4 软件实现

如果编译器不支持，可以使用库：

```c
// Intel Decimal Floating-Point Math Library
#include "bid_functions.h"

BID_UINT64 a, b, result;
a = bid64_from_string("0.1");
b = bid64_from_string("0.2");
result = bid64_add(a, b);  // 精确的 0.3

char str[32];
bid64_to_string(str, result);
printf("0.1 + 0.2 = %s\n", str);  // "0.3"
```

### 27.5 手动实现简单版本

```c
#include <stdint.h>
#include <stdio.h>

// 简单的定点十进制（4 位小数）
typedef struct {
    int64_t value;  // 实际值 × 10000
} decimal;

#define DECIMAL_SCALE 10000

decimal decimal_from_double(double d) {
    return (decimal){(int64_t)(d * DECIMAL_SCALE + 0.5)};
}

double decimal_to_double(decimal d) {
    return (double)d.value / DECIMAL_SCALE;
}

decimal decimal_add(decimal a, decimal b) {
    return (decimal){a.value + b.value};
}

decimal decimal_sub(decimal a, decimal b) {
    return (decimal){a.value - b.value};
}

decimal decimal_mul(decimal a, decimal b) {
    // 注意：需要处理溢出
    return (decimal){(a.value * b.value) / DECIMAL_SCALE};
}

decimal decimal_div(decimal a, decimal b) {
    return (decimal){(a.value * DECIMAL_SCALE) / b.value};
}

void decimal_print(decimal d) {
    int64_t integer = d.value / DECIMAL_SCALE;
    int64_t frac = d.value % DECIMAL_SCALE;
    if (frac < 0) frac = -frac;
    printf("%lld.%04lld", integer, frac);
}

int main() {
    decimal a = decimal_from_double(0.1);
    decimal b = decimal_from_double(0.2);
    decimal sum = decimal_add(a, b);

    printf("0.1 + 0.2 = ");
    decimal_print(sum);
    printf("\n");  // 输出：0.3000

    return 0;
}
```

---

## 28. GPU 浮点精度

### 28.1 GPU 浮点特点

GPU 浮点与 CPU 的主要区别：

| 特性 | CPU | GPU |
|------|-----|-----|
| IEEE 754 严格遵守 | 是 | 部分（可配置） |
| FMA 融合 | 可选 | 默认开启 |
| 非规格化数 | 支持 | 可能刷为零 |
| 精度模式 | 固定 | 多种可选 |
| NaN 处理 | 标准 | 可能简化 |

### 28.2 GLSL 精度修饰符

```glsl
// GLSL ES（移动设备 OpenGL）
precision highp float;    // 至少 FP32
precision mediump float;  // 至少 FP16
precision lowp float;     // 至少 FP10

// 变量级别指定
highp float position;
mediump vec3 normal;
lowp vec4 color;

// 精度范围（最低保证）
// highp:   (-2^62, 2^62), 精度 2^-16 相对误差
// mediump: (-2^14, 2^14), 精度 2^-10 相对误差
// lowp:    (-2, 2),       精度 2^-8 相对误差
```

### 28.3 CUDA 精度控制

```cpp
// CUDA 浮点控制

// 1. 编译选项
// nvcc --ftz=true   // 非规格化数刷为零（更快）
// nvcc --prec-div=false  // 快速除法（精度略低）
// nvcc --prec-sqrt=false // 快速平方根
// nvcc --fmad=true  // 允许 FMA 融合

// 2. 代码中控制
__device__ float my_func(float x) {
    // 使用内置函数获得更快但精度略低的计算
    float fast_recip = __frcp_rn(x);   // 快速倒数
    float fast_sqrt = __fsqrt_rn(x);   // 快速平方根
    float fast_div = __fdividef(a, b); // 快速除法

    // 精确版本
    float precise_recip = 1.0f / x;
    float precise_sqrt = sqrtf(x);

    return fast_sqrt;
}

// 3. 使用双精度
__device__ double precise_calc(double x) {
    return sqrt(x);  // 双精度平方根
}

// 注意：某些 GPU 的双精度性能是单精度的 1/2 到 1/32
```

### 28.4 WebGL 精度问题

```javascript
// WebGL 着色器精度
// 移动设备可能不支持 highp

// 检测支持
const gl = canvas.getContext('webgl');
const highpSupport = gl.getShaderPrecisionFormat(
    gl.FRAGMENT_SHADER, gl.HIGH_FLOAT
);
console.log('highp precision:', highpSupport.precision);

// 着色器中的处理
const fragmentShader = `
#ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
#else
    precision mediump float;
#endif

void main() {
    // 在移动设备上，大数值可能溢出
    // mediump 最大值约 65504
    float largeValue = 50000.0;  // 可能不精确
}
`;
```

### 28.5 GPU 精度最佳实践

```cpp
// 1. 避免非规格化数
// GPU 上非规格化数可能很慢或被刷为零
if (abs(x) < 1e-38f) x = 0.0f;

// 2. 避免大数和小数混合计算
// 先归一化到相近数量级
float normalized = x / scale;
float result = do_calculation(normalized);
result *= scale;

// 3. 累加使用 Kahan 求和或分层求和
// GPU 并行归约时特别重要

// 4. 需要高精度时使用双精度或模拟
// 双双精度（double-double）在 GPU 上的实现
struct dd_real {
    float hi, lo;  // 表示 hi + lo，其中 |lo| < |hi| * epsilon
};

__device__ dd_real dd_add(dd_real a, dd_real b) {
    float s = a.hi + b.hi;
    float v = s - a.hi;
    float e = (a.hi - (s - v)) + (b.hi - v) + a.lo + b.lo;
    return (dd_real){s + e, e - ((s + e) - s)};
}
```

---

## 29. SIMD 浮点运算

### 29.1 SIMD 概述

**SIMD (Single Instruction, Multiple Data)**：一条指令处理多个数据。

```
标量运算：
a + b → c              // 1 次加法

SIMD 运算（4 路并行）：
[a0,a1,a2,a3] + [b0,b1,b2,b3] → [c0,c1,c2,c3]  // 1 条指令，4 次加法
```

### 29.2 x86 SIMD 浮点指令集

| 指令集 | 寄存器 | 宽度 | float/次 | double/次 |
|--------|--------|------|----------|-----------|
| SSE | XMM | 128位 | 4 | 2 |
| AVX | YMM | 256位 | 8 | 4 |
| AVX-512 | ZMM | 512位 | 16 | 8 |

### 29.3 使用 Intrinsics

```c
#include <immintrin.h>
#include <stdio.h>

// SSE: 4 个 float 并行加法
void add_arrays_sse(float* a, float* b, float* result, int n) {
    int i;
    for (i = 0; i <= n - 4; i += 4) {
        __m128 va = _mm_loadu_ps(&a[i]);    // 加载 4 个 float
        __m128 vb = _mm_loadu_ps(&b[i]);
        __m128 vr = _mm_add_ps(va, vb);      // 4 路并行加法
        _mm_storeu_ps(&result[i], vr);       // 存储结果
    }
    // 处理剩余元素
    for (; i < n; i++) {
        result[i] = a[i] + b[i];
    }
}

// AVX: 8 个 float 并行
void add_arrays_avx(float* a, float* b, float* result, int n) {
    int i;
    for (i = 0; i <= n - 8; i += 8) {
        __m256 va = _mm256_loadu_ps(&a[i]);
        __m256 vb = _mm256_loadu_ps(&b[i]);
        __m256 vr = _mm256_add_ps(va, vb);
        _mm256_storeu_ps(&result[i], vr);
    }
    for (; i < n; i++) {
        result[i] = a[i] + b[i];
    }
}

// 编译：gcc -mavx2 -O3 simd_example.c
```

### 29.4 常用 SIMD 浮点操作

```c
#include <immintrin.h>

// ============ SSE (128-bit) ============

// 加载
__m128 v = _mm_loadu_ps(ptr);        // 非对齐加载
__m128 v = _mm_load_ps(ptr);         // 对齐加载（ptr 必须 16 字节对齐）
__m128 v = _mm_set_ps(d,c,b,a);      // 设置 4 个值
__m128 v = _mm_set1_ps(x);           // 广播：[x,x,x,x]

// 算术
__m128 r = _mm_add_ps(a, b);         // 加法
__m128 r = _mm_sub_ps(a, b);         // 减法
__m128 r = _mm_mul_ps(a, b);         // 乘法
__m128 r = _mm_div_ps(a, b);         // 除法
__m128 r = _mm_sqrt_ps(a);           // 平方根
__m128 r = _mm_rsqrt_ps(a);          // 快速 1/√x（近似）
__m128 r = _mm_rcp_ps(a);            // 快速 1/x（近似）

// FMA (需要 FMA 扩展)
__m128 r = _mm_fmadd_ps(a, b, c);    // a*b + c
__m128 r = _mm_fmsub_ps(a, b, c);    // a*b - c
__m128 r = _mm_fnmadd_ps(a, b, c);   // -a*b + c

// 比较
__m128 mask = _mm_cmpgt_ps(a, b);    // a > b
__m128 mask = _mm_cmpeq_ps(a, b);    // a == b

// 最大/最小
__m128 r = _mm_max_ps(a, b);
__m128 r = _mm_min_ps(a, b);

// 存储
_mm_storeu_ps(ptr, v);               // 非对齐存储
_mm_store_ps(ptr, v);                // 对齐存储

// ============ AVX (256-bit) ============

__m256 v = _mm256_loadu_ps(ptr);
__m256 r = _mm256_add_ps(a, b);
__m256 r = _mm256_fmadd_ps(a, b, c);
_mm256_storeu_ps(ptr, v);
```

### 29.5 SIMD 归约（求和）

```c
#include <immintrin.h>

// SSE 水平求和
float hsum_sse(__m128 v) {
    __m128 shuf = _mm_movehdup_ps(v);        // [1,1,3,3]
    __m128 sums = _mm_add_ps(v, shuf);       // [0+1,1+1,2+3,3+3]
    shuf = _mm_movehl_ps(sums, sums);        // [2+3,3+3,2+3,3+3]
    sums = _mm_add_ss(sums, shuf);           // [0+1+2+3,...]
    return _mm_cvtss_f32(sums);
}

// AVX 水平求和
float hsum_avx(__m256 v) {
    __m128 vlow = _mm256_castps256_ps128(v);
    __m128 vhigh = _mm256_extractf128_ps(v, 1);
    vlow = _mm_add_ps(vlow, vhigh);
    return hsum_sse(vlow);
}

// 数组求和
float sum_array_avx(float* arr, int n) {
    __m256 sum = _mm256_setzero_ps();

    int i;
    for (i = 0; i <= n - 8; i += 8) {
        __m256 v = _mm256_loadu_ps(&arr[i]);
        sum = _mm256_add_ps(sum, v);
    }

    float total = hsum_avx(sum);

    // 处理剩余
    for (; i < n; i++) {
        total += arr[i];
    }

    return total;
}
```

### 29.6 自动向量化

现代编译器可以自动向量化简单循环：

```c
// 编译器可能自动向量化
void add_arrays(float* a, float* b, float* result, int n) {
    for (int i = 0; i < n; i++) {
        result[i] = a[i] + b[i];
    }
}

// 编译：gcc -O3 -march=native -ftree-vectorize

// 帮助编译器向量化的提示
void add_arrays_restricted(float* restrict a, float* restrict b,
                          float* restrict result, int n) {
    // restrict 告诉编译器指针不重叠
    #pragma omp simd  // OpenMP SIMD 提示
    for (int i = 0; i < n; i++) {
        result[i] = a[i] + b[i];
    }
}

// 检查是否向量化
// gcc -O3 -march=native -fopt-info-vec
```

### 29.7 SIMD 精度注意事项

```c
// 1. SIMD 结果可能与标量不同（运算顺序）
float scalar_sum = 0;
for (int i = 0; i < n; i++) scalar_sum += arr[i];

// SIMD 会以不同顺序累加，可能得到略有不同的结果

// 2. 快速近似函数精度较低
__m128 approx = _mm_rsqrt_ps(x);  // 精度约 12 位
__m128 exact = _mm_div_ps(_mm_set1_ps(1.0f), _mm_sqrt_ps(x));

// 牛顿迭代提高精度
__m128 half = _mm_set1_ps(0.5f);
__m128 three = _mm_set1_ps(3.0f);
// y = y * (3 - x * y * y) / 2
approx = _mm_mul_ps(_mm_mul_ps(half, approx),
                    _mm_sub_ps(three, _mm_mul_ps(x, _mm_mul_ps(approx, approx))));

// 3. 非规格化数可能影响性能
// 设置 DAZ (Denormals Are Zero) 和 FTZ (Flush To Zero)
_mm_setcsr(_mm_getcsr() | 0x8040);
```

---

## 参考资料

- IEEE 754-2019 Standard for Floating-Point Arithmetic
- What Every Computer Scientist Should Know About Floating-Point Arithmetic (David Goldberg)
- Computer Systems: A Programmer's Perspective (CSAPP) Chapter 2
- Intel 64 and IA-32 Architectures Software Developer's Manual
- GAO Report: Patriot Missile Defense (GAO/IMTEC-92-26)
- Ariane 5 Flight 501 Failure Report
- Mixed Precision Training (NVIDIA/Google Research)
- GMP Manual: https://gmplib.org/manual/
- MPFR Manual: https://www.mpfr.org/mpfr-current/mpfr.html
- Intel Intrinsics Guide: https://www.intel.com/content/www/us/en/docs/intrinsics-guide/
- CORDIC Algorithm: J.E. Volder, "The CORDIC Trigonometric Computing Technique"
