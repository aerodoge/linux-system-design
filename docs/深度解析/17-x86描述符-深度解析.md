# x86 描述符深度解析

## 概述

x86 保护模式依赖三种描述符表：
- **GDT** (Global Descriptor Table) - 定义内存段
- **IDT** (Interrupt Descriptor Table) - 定义中断处理程序
- **TSS** (Task State Segment) - 保存任务状态

本文档重点讲解 GDT 和 TSS，IDT 在 01-IDT-深度解析.md 中详细介绍。

## 段选择子

### 选择子格式

```
┌────────────────────────────────────────┐
│ 15          3  2  1  0                 │
│ ├───────────┬───┬────┤                 │
│ │   Index   │ TI│ RPL│                 │
│ └───────────┴───┴────┘                 │
└────────────────────────────────────────┘

Index: GDT/LDT 中的描述符索引 (除以 8)
TI:    表指示器 (0=GDT, 1=LDT)
RPL:   请求特权级 (0-3)
```

### 本项目的段选择子

```c
// x86_desc.h
#define KERNEL_CS   0x0010    // 0000 0000 0001 0000
#define KERNEL_DS   0x0018    // 0000 0000 0001 1000
#define USER_CS     0x0023    // 0000 0000 0010 0011
#define USER_DS     0x002B    // 0000 0000 0010 1011
#define KERNEL_TSS  0x0030    // 0000 0000 0011 0000
#define KERNEL_LDT  0x0038    // 0000 0000 0011 1000
```

**解析**：

| 选择子 | 二进制 | Index | TI | RPL | 含义 |
|-------|--------|-------|----|----|------|
| KERNEL_CS (0x10) | 0001 0000 | 2 | 0 | 0 | GDT[2], Ring 0 |
| KERNEL_DS (0x18) | 0001 1000 | 3 | 0 | 0 | GDT[3], Ring 0 |
| USER_CS (0x23) | 0010 0011 | 4 | 0 | 3 | GDT[4], Ring 3 |
| USER_DS (0x2B) | 0010 1011 | 5 | 0 | 3 | GDT[5], Ring 3 |
| KERNEL_TSS (0x30) | 0011 0000 | 6 | 0 | 0 | GDT[6], Ring 0 |
| KERNEL_LDT (0x38) | 0011 1000 | 7 | 0 | 0 | GDT[7], Ring 0 |

### GDT 布局

```
GDT:
┌─────────────────────────────────────────────────────┐
│  GDT[0]  │  NULL 描述符 (必须为空)                   │
├─────────────────────────────────────────────────────┤
│  GDT[1]  │  (未使用)                                │
├─────────────────────────────────────────────────────┤
│  GDT[2]  │  内核代码段 (KERNEL_CS = 0x10)           │
├─────────────────────────────────────────────────────┤
│  GDT[3]  │  内核数据段 (KERNEL_DS = 0x18)           │
├─────────────────────────────────────────────────────┤
│  GDT[4]  │  用户代码段 (USER_CS = 0x23)             │
├─────────────────────────────────────────────────────┤
│  GDT[5]  │  用户数据段 (USER_DS = 0x2B)             │
├─────────────────────────────────────────────────────┤
│  GDT[6]  │  TSS 描述符 (KERNEL_TSS = 0x30)          │
├─────────────────────────────────────────────────────┤
│  GDT[7]  │  LDT 描述符 (KERNEL_LDT = 0x38)          │
└─────────────────────────────────────────────────────┘
```

## 段描述符

### 结构定义

```c
typedef struct seg_desc {
    uint16_t seg_lim_15_00;     // 段限长 [15:0]
    uint16_t base_15_00;        // 基地址 [15:0]
    uint8_t  base_23_16;        // 基地址 [23:16]
    uint32_t type       : 4;    // 段类型
    uint32_t sys        : 1;    // 系统段标志
    uint32_t dpl        : 2;    // 描述符特权级
    uint32_t present    : 1;    // 存在位
    uint32_t seg_lim_19_16 : 4; // 段限长 [19:16]
    uint32_t avail      : 1;    // 可用位
    uint32_t reserved   : 1;    // 保留 (64位模式用)
    uint32_t opsize     : 1;    // 操作数大小 (0=16位, 1=32位)
    uint32_t granularity: 1;    // 粒度 (0=字节, 1=4KB页)
    uint8_t  base_31_24;        // 基地址 [31:24]
} seg_desc_t;
```

### 位字段图

```
63        56 55  52 51  48 47 46 45 44 43    40 39        32
┌───────────┬──────┬──────┬──┬───┬──┬──┬──────┬────────────┐
│ Base[31:24]│ G │DB│ L │AVL│ Limit │ P │DPL│ S │  Type  │ Base[23:16] │
└───────────┴──────┴──────┴──┴───┴──┴──┴──────┴────────────┘
     8 bit    1  1  1  1    4    1   2   1    4       8

31                     16 15                      0
┌───────────────────────┬───────────────────────────┐
│     Base[15:0]        │      Limit[15:0]          │
└───────────────────────┴───────────────────────────┘
        16 bit                   16 bit
```

### 字段说明

| 字段 | 位数 | 说明 |
|-----|------|------|
| Base | 32 | 段基地址 (分散在三处) |
| Limit | 20 | 段限长 (分散在两处) |
| G | 1 | 粒度: 0=字节, 1=4KB |
| DB | 1 | 默认操作数大小: 0=16位, 1=32位 |
| L | 1 | 64位代码段标志 |
| AVL | 1 | 操作系统可用 |
| P | 1 | 存在位: 1=有效 |
| DPL | 2 | 特权级: 0=内核, 3=用户 |
| S | 1 | 描述符类型: 0=系统, 1=代码/数据 |
| Type | 4 | 段类型 (见下表) |

### Type 字段

**代码段 (S=1)**：

| Type | 二进制 | 含义 |
|------|--------|------|
| 0xA | 1010 | 只执行，已访问 |
| 0xB | 1011 | 执行/读，已访问 |

**数据段 (S=1)**：

| Type | 二进制 | 含义 |
|------|--------|------|
| 0x2 | 0010 | 读/写 |
| 0x3 | 0011 | 读/写，已访问 |

**系统段 (S=0)**：

| Type | 含义 |
|------|------|
| 0x2 | LDT |
| 0x9 | 32位 TSS (可用) |
| 0xB | 32位 TSS (忙) |

## TSS (Task State Segment)

### 为什么需要 TSS？

当发生特权级切换（用户态 → 内核态）时，CPU 需要知道：
1. 内核栈在哪里 (SS0:ESP0)
2. 使用哪个 LDT

TSS 存储这些信息。

### TSS 结构

```c
typedef struct tss_t {
    // 任务链接 (硬件任务切换用，我们不用)
    uint16_t prev_task_link;
    uint16_t prev_task_link_pad;

    // Ring 0 栈指针 ← 最重要！
    uint32_t esp0;
    uint16_t ss0;
    uint16_t ss0_pad;

    // Ring 1 栈指针 (通常不用)
    uint32_t esp1;
    uint16_t ss1;
    uint16_t ss1_pad;

    // Ring 2 栈指针 (通常不用)
    uint32_t esp2;
    uint16_t ss2;
    uint16_t ss2_pad;

    // 页目录基址
    uint32_t cr3;

    // 通用寄存器 (硬件任务切换用)
    uint32_t eip;
    uint32_t eflags;
    uint32_t eax, ecx, edx, ebx;
    uint32_t esp, ebp, esi, edi;

    // 段寄存器
    uint16_t es, es_pad;
    uint16_t cs, cs_pad;
    uint16_t ss, ss_pad;
    uint16_t ds, ds_pad;
    uint16_t fs, fs_pad;
    uint16_t gs, gs_pad;

    // LDT 选择子
    uint16_t ldt_segment_selector;
    uint16_t ldt_pad;

    // I/O 权限位图
    uint16_t debug_trap : 1;
    uint16_t io_pad     : 15;
    uint16_t io_base_addr;
} tss_t;
```

### TSS 内存布局

```
TSS (104 字节):
偏移    内容
┌─────────────────────────────────────┐
│ 0x00  │ prev_task_link              │
├───────┼─────────────────────────────┤
│ 0x04  │ ESP0 ← 内核栈指针            │
├───────┼─────────────────────────────┤
│ 0x08  │ SS0  ← 内核栈段              │
├───────┼─────────────────────────────┤
│ 0x0C  │ ESP1                        │
├───────┼─────────────────────────────┤
│ 0x10  │ SS1                         │
├───────┼─────────────────────────────┤
│ 0x14  │ ESP2                        │
├───────┼─────────────────────────────┤
│ 0x18  │ SS2                         │
├───────┼─────────────────────────────┤
│ 0x1C  │ CR3                         │
├───────┼─────────────────────────────┤
│ 0x20  │ EIP                         │
│  ...  │ (更多寄存器)                 │
├───────┼─────────────────────────────┤
│ 0x60  │ LDT segment selector        │
├───────┼─────────────────────────────┤
│ 0x64  │ I/O map base address        │
└───────┴─────────────────────────────┘
```

### 本项目如何使用 TSS

**主要用途**：存储内核栈信息 (SS0:ESP0)

```c
// kernel.c 中初始化
tss.ss0 = KERNEL_DS;      // 内核数据段
tss.esp0 = 0x800000;      // 8MB，初始内核栈顶
tss.ldt_segment_selector = KERNEL_LDT;
```

**进程切换时更新**：

```c
// execute_func() 中
tss.esp0 = 0x800000 - (new_pid + 1) * 0x2000;  // 每个进程的内核栈

// schedule() 中
tss.esp0 = new_terminal.esp0;  // 恢复新进程的内核栈
```

### 特权级切换时的作用

```
用户程序执行 int 0x80 (系统调用):

1. CPU 检测到特权级变化 (Ring 3 → Ring 0)

2. CPU 从 TSS 获取 SS0:ESP0
   ┌─────────────────────────────────────────────┐
   │  TSS                                        │
   │  ├── SS0  = 0x18 (KERNEL_DS)               │
   │  └── ESP0 = 0x7FC000 (进程1的内核栈顶)       │
   └─────────────────────────────────────────────┘

3. CPU 切换到内核栈，压入用户态状态:
   ┌─────────────────────────────────────────────┐
   │  内核栈 (从 0x7FC000 向下)                   │
   │  ├── SS (用户栈段)                          │
   │  ├── ESP (用户栈指针)                       │
   │  ├── EFLAGS                                │
   │  ├── CS (用户代码段)                        │
   │  └── EIP (返回地址)                         │
   └─────────────────────────────────────────────┘

4. 跳转到中断处理程序
```

## GDT 初始化

### boot.S 中加载 GDT

```asm
# boot.S
lgdt gdt_desc_ptr       # 加载 GDT 描述符

ljmp $KERNEL_CS, $keep_going  # 刷新 CS

keep_going:
    movw $KERNEL_DS, %cx
    movw %cx, %ss       # 设置栈段
    movw %cx, %ds       # 设置数据段
    movw %cx, %es
    movw %cx, %fs
    movw %cx, %gs
```

### kernel.c 中设置 TSS 描述符

```c
// kernel.c entry()
{
    seg_desc_t the_tss_desc;
    the_tss_desc.granularity   = 0x0;  // 字节粒度
    the_tss_desc.opsize        = 0x0;  // 16位 (TSS 固定)
    the_tss_desc.reserved      = 0x0;
    the_tss_desc.avail         = 0x0;
    the_tss_desc.seg_lim_19_16 = TSS_SIZE & 0x000F0000;
    the_tss_desc.present       = 0x1;  // 存在
    the_tss_desc.dpl           = 0x0;  // Ring 0
    the_tss_desc.sys           = 0x0;  // 系统段
    the_tss_desc.type          = 0x9;  // 32位 TSS (可用)
    the_tss_desc.seg_lim_15_00 = TSS_SIZE & 0x0000FFFF;

    SET_TSS_PARAMS(the_tss_desc, &tss, tss_size);

    tss_desc_ptr = the_tss_desc;

    // 初始化 TSS 内容
    tss.ldt_segment_selector = KERNEL_LDT;
    tss.ss0 = KERNEL_DS;
    tss.esp0 = 0x800000;

    // 加载任务寄存器
    ltr(KERNEL_TSS);
}
```

### SET_TSS_PARAMS 宏

```c
#define SET_TSS_PARAMS(str, addr, lim)                          \
do {                                                            \
    str.base_31_24 = ((uint32_t)(addr) & 0xFF000000) >> 24;     \
    str.base_23_16 = ((uint32_t)(addr) & 0x00FF0000) >> 16;     \
    str.base_15_00 = (uint32_t)(addr) & 0x0000FFFF;             \
    str.seg_lim_19_16 = ((lim) & 0x000F0000) >> 16;             \
    str.seg_lim_15_00 = (lim) & 0x0000FFFF;                     \
} while (0)
```

将 TSS 的地址和大小分散填入描述符的各个位字段。

## ltr 指令

```c
#define ltr(desc)                       \
    asm volatile ("ltr %w0"             \
        :                               \
        : "r" (desc)                    \
    )
```

`ltr` (Load Task Register) 将 TSS 描述符的选择子加载到任务寄存器。

**执行后**：
- CPU 知道 TSS 在哪里
- 特权级切换时会自动使用 TSS 中的 SS0:ESP0

## 特权级和 DPL

### 三种特权级检查

```
CPL (Current Privilege Level): 当前代码的特权级 (CS.RPL)
DPL (Descriptor Privilege Level): 段/门的特权级
RPL (Requested Privilege Level): 请求的特权级 (选择子中)
```

### 访问规则

**数据段访问**：
```
CPL ≤ DPL 且 RPL ≤ DPL

例: 用户代码 (CPL=3) 访问内核数据段 (DPL=0)
3 ≤ 0? 否 → 拒绝访问
```

**代码段跳转** (通过调用门)：
```
CPL ≥ 门的 DPL  (可以调用)
CPL ≤ 目标段 DPL (可以跳转)

例: 用户代码通过系统调用门进入内核
用户 CPL=3, 门 DPL=3 → 可以调用
内核 DPL=0 → 切换到 Ring 0
```

## 本项目的特权级配置

```
┌─────────────────────────────────────────────────────────────────┐
│                           内存视图                               │
├─────────────────────────────────────────────────────────────────┤
│  Ring 0 (内核)                                                  │
│  ├── 代码段: KERNEL_CS (0x10), DPL=0                           │
│  ├── 数据段: KERNEL_DS (0x18), DPL=0                           │
│  └── 内核代码、数据、栈                                          │
├─────────────────────────────────────────────────────────────────┤
│  Ring 3 (用户)                                                  │
│  ├── 代码段: USER_CS (0x23), DPL=3                             │
│  ├── 数据段: USER_DS (0x2B), DPL=3                             │
│  └── 用户程序、数据、栈                                          │
└─────────────────────────────────────────────────────────────────┘

用户 → 内核的唯一入口: int 0x80 (系统调用门, DPL=3)
```

## 总结

### GDT 要点

| 概念 | 说明 |
|-----|------|
| 段选择子 | 16位，包含索引、TI、RPL |
| 段描述符 | 8字节，定义段的基址、限长、属性 |
| 特权级 | 0=内核，3=用户 |

### TSS 要点

| 概念 | 说明 |
|-----|------|
| 主要用途 | 存储 Ring 0 栈指针 (SS0:ESP0) |
| 更新时机 | 进程切换时 |
| 加载方式 | `ltr` 指令 |

### 初始化顺序

```
boot.S:
  lgdt gdt_desc_ptr     ← 加载 GDT
  ljmp $KERNEL_CS, ...  ← 刷新 CS
  mov $KERNEL_DS, ...   ← 设置数据段

kernel.c entry():
  设置 TSS 描述符
  tss.ss0 = KERNEL_DS
  tss.esp0 = 0x800000
  ltr(KERNEL_TSS)       ← 加载 TSS
```

理解 GDT 和 TSS 是理解特权级切换和进程管理的基础。
