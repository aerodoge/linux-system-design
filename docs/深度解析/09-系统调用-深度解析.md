# 系统调用深度解析

## 概述

系统调用是用户程序请求操作系统服务的接口。用户程序运行在用户态（Ring 3），不能直接访问硬件或内核数据结构，必须通过系统调用陷入内核态（Ring
0）
来完成特权操作。

## 系统调用列表

| 调用号 | 名称          | 功能            |
|-----|-------------|---------------|
| 1   | halt        | 终止当前进程        |
| 2   | execute     | 执行新程序         |
| 3   | read        | 读取文件/设备       |
| 4   | write       | 写入文件/设备       |
| 5   | open        | 打开文件/设备       |
| 6   | close       | 关闭文件/设备       |
| 7   | getargs     | 获取程序参数        |
| 8   | vidmap      | 映射视频内存到用户空间   |
| 9   | set_handler | 设置信号处理函数（未实现） |
| 10  | sigreturn   | 从信号处理返回（未实现）  |

## 系统调用入口

### 用户态调用

用户程序通过`int $0x80`触发系统调用：

```c
// 用户程序中的系统调用
int result = read(fd, buf, nbytes);

// 实际汇编实现
// EAX = 系统调用号 (3 = read)
// EBX = 第一个参数 (fd)
// ECX = 第二个参数 (buf)
// EDX = 第三个参数 (nbytes)
// int $0x80
```

### 汇编入口 (interrupt_handler.S)

```asm
syscall:
    pushal          ; 保存通用寄存器
    pushfl          ; 保存 EFLAGS
    pushl $SYSCALL  ; 压入标识 (0x80)
    jmp interrupt_handler

interrupt_handler:
    popl %edi
    cmpl $SYSCALL, %edi
    je syscall_jump_sub   ; 是系统调用
    ; ... 其他处理

syscall_jump_sub:
    ; 检查系统调用号有效性 (1-10)
    cmpl $1, %eax
    jl invalid_sysnum
    cmpl $10, %eax
    jg invalid_sysnum

    ; 压入参数 (C 调用约定)
    pushl %edx        ; 参数 3
    pushl %ecx        ; 参数 2
    pushl %ebx        ; 参数 1

    ; 调用对应的处理函数
    call *syscall_jumptable(,%eax,4)

    ; 保存返回值
    movl %eax, ret_val
    addl $12, %esp    ; 清理参数
    jmp finish_syscall

invalid_sysnum:
    movl $-1, ret_val

finish_syscall:
    popfl
    popal
    movl ret_val, %eax  ; 返回值放入 EAX
    iret

syscall_jumptable:
    .long 0                 ; 0: 未使用
    .long halt_func         ; 1: halt
    .long execute_func      ; 2: execute
    .long read_func         ; 3: read
    .long write_func        ; 4: write
    .long open_func         ; 5: open
    .long close_func        ; 6: close
    .long getargs_func      ; 7: getargs
    .long vidmap_func       ; 8: vidmap
    .long set_handler_func  ; 9: set_handler
    .long sigreturn_func    ; 10: sigreturn
```

### 系统调用流程图

```
用户程序: read(fd, buf, nbytes)
           │
           ▼
    int $0x80 (软中断)
           │
           ▼
┌─────────────────────────────────────────────────────────┐
│                      CPU 自动完成                        │
│  1. 特权级切换: Ring 3 → Ring 0                           │
│  2. 从TSS获取内核栈 (SS0:ESP0)                            │
│  3. 压入: SS, ESP, EFLAGS, CS, EIP                       │
│  4. 从IDT[0x80]获取处理函数地址                            │
└─────────────────────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────────────────────┐
│                    syscall(ASM)                         │
│  pushal, pushfl, pushl $0x80                            │
│  jmp interrupt_handler                                  │
└─────────────────────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────────────────────┐
│                 syscall_jump_sub(ASM)                   │
│  验证 EAX (1-10)                                         │
│  pushl %edx, %ecx, %ebx                                 │
│  call *syscall_jumptable(,%eax,4)                       │
└─────────────────────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────────────────────┐
│                    read_func(C)                         │
│  1. 验证参数                                              │
│  2. 获取当前 PCB                                          │
│  3. 调用 fd_table[fd].op_table_ptr.read()                │
│  4. 返回读取字节数                                         │
└─────────────────────────────────────────────────────────┘
           │
           ▼
    iret 返回用户态
           │
           ▼
    用户程序继续执行
```

---

## 文件操作系统调用

### open - 打开文件

```c
int32_t open_func(const uint8_t* filename) 
{
    pcb_t* pcb = get_specific_pcb(cur_pid);
    dentry_t file_dentry;

    // 1. 特殊处理 stdin/stdout
    if (strcmp(filename, "stdin") == 0) {
        pcb->fd_table[0].op_table_ptr = stdin_table;
        pcb->fd_table[0].flags = 1;
        return 0;
    }
    if (strcmp(filename, "stdout") == 0) {
        pcb->fd_table[1].op_table_ptr = stdout_table;
        pcb->fd_table[1].flags = 1;
        return 1;
    }

    // 2. 在文件系统中查找文件
    if (read_dentry_by_name(filename, &file_dentry) == -1) {
        return -1;
    }

    // 3. 分配文件描述符 (2-7)
    uint32_t fd;
    for (fd = 2; fd < MAX_FILES; fd++) {
        if (pcb->fd_table[fd].flags == 0) {
            pcb->fd_table[fd].flags = 1;
            pcb->fd_table[fd].file_position = 0;
            break;
        }
    }
    if (fd == MAX_FILES) return -1;  // 没有可用 fd

    // 4. 根据文件类型设置操作表
    switch (file_dentry.file_type) {
        case 0:  // RTC 设备
            rtc_open(filename);
            pcb->fd_table[fd].op_table_ptr = rtc_table;
            break;
        case 1:  // 目录
            pcb->fd_table[fd].op_table_ptr = dir_table;
            break;
        case 2:  // 普通文件
            pcb->fd_table[fd].inode = file_dentry.inode;
            pcb->fd_table[fd].op_table_ptr = file_table;
            break;
    }

    return fd;
}
```

### 文件描述符表

每个进程的PCB包含一个文件描述符表：

```c
typedef struct file_desc {
    op_table_t op_table_ptr;   // 操作函数指针
    uint32_t inode;            // inode 号
    uint32_t file_position;    // 当前读取位置
    uint32_t flags;            // 1=使用中, 0=空闲
} file_desc_t;

// PCB 中
file_desc_t fd_table[8];  // 最多 8 个打开的文件
```

文件描述符分配：

```
fd    用途        操作表
─────────────────────────────
0     stdin      stdin_table  (terminal_read, no_write)
1     stdout     stdout_table (no_read, terminal_write)
2-7   用户文件    file_table / dir_table / rtc_table
```

### 操作表 (op_table) - 函数指针实现多态

操作表是一个**函数指针结构体**，用于实现类似面向对象的多态。不同类型的文件（终端、普通文件、目录、RTC）有不同的操作实现，但通过统一的接口调用。

#### 定义

```c
typedef struct op_table {
    int32_t (*read)(int32_t fd, void* buf, int32_t nbytes);
    int32_t (*write)(int32_t fd, const void* buf, int32_t nbytes);
    int32_t (*open)(const uint8_t* filename);
    int32_t (*close)(int32_t fd);
} op_table_t;
```

#### 预定义的操作表

```c
// syscall_handler.c 中定义
op_table_t stdin_table  = {terminal_read, no_write,       no_open, no_close};
op_table_t stdout_table = {no_read,       terminal_write, no_open, no_close};
op_table_t file_table   = {file_read,     file_write,     file_open, file_close};
op_table_t dir_table    = {dir_read,      dir_write,      dir_open,  dir_close};
op_table_t rtc_table    = {rtc_read,      rtc_write,      rtc_open,  rtc_close};
```

#### 函数定义位置

**实际驱动函数**：

| 函数               | 定义位置          | 功能           |
|------------------|---------------|--------------|
| `terminal_read`  | terminal.c    | 从键盘缓冲区读取     |
| `terminal_write` | terminal.c    | 输出到屏幕        |
| `file_read`      | file_system.c | 从文件系统读取数据    |
| `file_write`     | file_system.c | 返回-1（只读文件系统） |
| `dir_read`       | file_system.c | 读取目录项名称      |
| `rtc_read`       | rtc_handler.c | 等待RTC中断      |
| `rtc_write`      | rtc_handler.c | 设置RTC虚拟频率    |

**no_xxx占位函数**（syscall_handler.c:475-510）：

```c
// 用于禁止某些操作，直接返回 -1
int32_t no_read(int32_t fd, void* buf, int32_t nbytes) { return -1; }
int32_t no_write(int32_t fd, const void* buf, int32_t nbytes) { return -1; }
int32_t no_open(const uint8_t* filename) { return -1; }
int32_t no_close(int32_t fd) { return -1; }
```

**no_xxx的作用**：

| 操作表          | read          | write          | 原因             |
|--------------|---------------|----------------|----------------|
| stdin_table  | terminal_read | **no_write**   | stdin 只能读，不能写  |
| stdout_table | **no_read**   | terminal_write | stdout 只能写，不能读 |

当用户尝试`write(0, ...)`(写 stdin)或`read(1, ...)`(读 stdout) 时，会调用`no_write`或`no_read`，直接返回-1表示操作非法。

#### 工作原理

当用户调用`read(fd, buf, nbytes)`时，系统调用处理函数通过函数指针调用对应的实现：

```c
int32_t read_func(int32_t fd, void* buf, int32_t nbytes) {
    pcb_t* pcb = get_specific_pcb(cur_pid);

    // 通过函数指针调用对应的read实现
    return pcb->fd_table[fd].op_table_ptr.read(fd, buf, nbytes);
}
```

根据fd指向的文件类型，自动调用不同的函数：

```
用户调用              fd 类型        操作表            实际执行
─────────────────────────────────────────────────────────────
read(0, buf, n)   →  stdin      →  stdin_table   →  terminal_read()  从键盘读
read(3, buf, n)   →  普通文件    →  file_table    →  file_read()      从文件系统读
read(4, buf, n)   →  RTC设备    →  rtc_table      →  rtc_read()       等待RTC中断
read(5, buf, n)   →  目录       →  dir_table      →  dir_read()       读目录项名称
```

#### 类比C++虚函数

这本质上是C语言实现的**虚函数表 (vtable)**：

```
C++ 写法:
class File {
    virtual int read(...) = 0;
};
class Terminal : File {
    int read(...) { /* 键盘读取 */ }
};
class RegularFile : File {
    int read(...) { /* 文件读取 */ }
};

file->read();  // 根据实际类型调用不同实现

C写法 (本项目):
fd_table[fd].op_table_ptr.read(fd, buf, nbytes);
// 根据操作表调用不同实现
```

**优点**：系统调用层只需要写一份代码，就能统一处理终端、文件、目录、RTC 等所有类型，实现了**接口统一、实现分离**的设计模式。

### execute_func() - execute系统调用处理函数

`execute_func()`是`execute`系统调用的处理函数，定义在`syscall_handler.c`中。当用户在shell中输入命令时，最终会调用这个函数来创建并运行新进程。

#### 调用路径

```
用户输入 "cat readme.txt"
       ↓
shell 解析命令
       ↓
调用 int $0x80 (execute 系统调用, EAX=2)
       ↓
syscall_jumptable[2] = execute_func
       ↓
execute_func("cat readme.txt")
```

#### 主要工作

```c
int32_t execute_func(const uint8_t* command) 
{
    // 1. 解析命令和参数
    //    "cat readme.txt" → cmd="cat", arg="readme.txt"
    parse_args(command, parsed_command, argument);

    // 2. 检查可执行文件是否有效
    //    读取文件头，检查 magic number (0x7F454C46 "ELF")
    if (!is_executable(parsed_command)) return -1;

    // 3. 分配新的 pid
    new_pid = get_available_pid();

    // 4. 设置新进程的页表 (4MB 页)
    //    虚拟地址 128MB → 物理地址 (8 + pid*4)MB
    set_process_paging(new_pid);

    // 5. 加载程序到内存
    //    复制可执行文件内容到 0x08048000
    load_program(parsed_command);

    // 6. 初始化PCB
    pcb_t* pcb = get_specific_pcb(new_pid);
    pcb->pid = new_pid;
    pcb->parent = get_specific_pcb(cur_pid);  // 设置父进程
    strcpy(pcb->arg, argument);               // 保存参数

    // 7. 更新cur_pid
    cur_pid = new_pid;

    // 8. 设置TSS (内核栈指针)
    tss.esp0 = get_kernel_stack(new_pid);

    // 9. 跳转到用户程序入口 (IRET)
    //    设置用户栈、入口地址，然后iret
    context_switch_to_user(entry_point, user_esp);
}
```

#### 执行流程图

```
execute_func("cat readme.txt")
       │
       ├─→ 解析: cmd="cat", arg="readme.txt"
       │
       ├─→ 验证: cat是合法ELF可执行文件
       │
       ├─→ 分配pid=1
       │
       ├─→ 设置页表: 128MB(虚拟) → 12MB(物理)
       │             └── pid=1, 所以 8+1*4=12MB
       │
       ├─→ 加载程序到 0x08048000
       │
       ├─→ 初始化PCB[1]:
       │     - pid = 1
       │     - parent = &PCB[0] (shell)
       │     - arg = "readme.txt"
       │
       ├─→ cur_pid = 1
       │
       ├─→ tss.esp0 = 8MB - 1*8KB (进程1的内核栈顶)
       │
       └─→ iret跳转到cat程序入口
              └── 现在CPU在执行cat程序
```

#### get_specific_pcb() - 获取PCB地址

`get_specific_pcb(new_pid)` **不是创建新PCB**，而是**计算已存在的PCB内存地址**。

PCB 不是动态分配的，而是**预先静态分配**在内核栈底部：

```c
// 获取 PCB 地址的计算
pcb_t* get_specific_pcb(uint8_t pid) {
    // PCB 位于 8MB - (pid+1)*8KB 处
    return (pcb_t*)(0x800000 - (pid + 1) * 0x2000);
}
```

**内存布局**：

```
8MB (0x800000) ─────────────────────────
    │  进程0 内核栈 (8KB)                 │
    │  ┌────────────────────────┐       │
    │  │                        │ ← 栈底 (ESP 初始值 = 0x800000)
    │  │          ↑             │
    │  │        栈空间           │   栈向下增长
    │  │          ↑             │
    │  │  PCB[0]                │ ← get_specific_pcb(0) = 0x7FE000
    │  └────────────────────────┘       │
8MB-8KB (0x7FE000) ─────────────────────
    │  进程1 内核栈 (8KB)                 │
    │  ┌────────────────────────┐       │
    │  │                        │ ← 栈底 (ESP 初始值 = 0x7FE000)
    │  │          ↑             │
    │  │        栈空间           │   栈向下增长
    │  │          ↑             │
    │  │  PCB[1]                │ ← get_specific_pcb(1) = 0x7FC000
    │  └────────────────────────┘       │
8MB-16KB (0x7FC000) ────────────────────
    │        ...                       │
```

PCB放在低地址是为了**保护**：栈向下增长，如果栈溢出会先覆盖PCB，容易检测到错误。

**关键理解**：

| 操作                      | 说明               |
|-------------------------|------------------|
| `get_specific_pcb(pid)` | 计算地址，不分配内存       |
| PCB内存                   | 始终存在于内核栈底部       |
| `execute_func()`        | 负责**初始化**这块内存的内容 |

#### PCB 空间的预分配

PCB数量由**最大进程数**决定，这是一个**编译时常量**。本系统最多支持**6个进程**（3个终端 × 每个终端最多2个进程）：

```c
#define MAX_PROCESSES 6
```

**固定的内存布局**：

```
8MB (0x800000) ────────────────────────────
    │  ┌─ 栈底0 (ESP=0x800000) ─┐         │
    │  │       内核栈0 ↑        │  pid 0  │
    │  │  PCB[0] (0x7FE000)    │         │
8MB-8KB (0x7FE000) ────────────────────────
    │  ┌─ 栈底1 (ESP=0x7FE000) ─┐         │
    │  │       内核栈1 ↑        │  pid 1  │
    │  │  PCB[1] (0x7FC000)    │         │
8MB-16KB (0x7FC000) ───────────────────────
    │  ┌─ 栈底2 ───────────────┐         │
    │  │       内核栈2 ↑        │  pid 2  │
    │  │  PCB[2]               │         │
8MB-24KB ──────────────────────────────────
    │         ... (pid 3-5)              │
8MB-48KB ──────────────────────────────────
    │       未使用                        │
4MB ───────────────────────────────────────
    │       内核代码/数据                  │
0   ───────────────────────────────────────
```

每个8KB块：高地址是栈底（ESP 初始值），低地址存放PCB。

**为什么不动态分配？**

| 方式   | 优点         | 缺点                |
|------|------------|-------------------|
| 静态分配 | 简单、无碎片、确定性 | 浪费内存（未使用的PCB也占空间） |
| 动态分配 | 按需分配、灵活    | 需要内存管理器、可能碎片化     |

对于教学OS，静态分配足够简单可靠。真实OS（如 Linux）使用slab分配器动态管理PCB。

#### Linux 的最大进程数

Linux 也有最大进程数限制，但比本项目灵活得多：

| 限制类型   | 查看命令                           | 说明                    |
|--------|--------------------------------|-----------------------|
| 系统全局最大 | `cat /proc/sys/kernel/pid_max` | 默认32768或4194304 (64位) |
| 单用户最大  | `ulimit -u`                    | 防止单用户耗尽资源             |
| 内核编译限制 | `CONFIG_BASE_SMALL`            | 嵌入式系统可配置更小值           |

```bash
# 查看限制
$ cat /proc/sys/kernel/pid_max
4194304

$ ulimit -u
63703

# 可以动态修改（需要 root）
$ echo 65536 > /proc/sys/kernel/pid_max
```

**391 OS vs Linux 对比**：

| 特性    | 391 OS   | Linux        |
|-------|----------|--------------|
| PCB分配 | 静态，编译时固定 | 动态，运行时按需分配   |
| 最大进程数 | 硬编码6个    | 可配置，默认几万到几百万 |
| 内存管理  | 固定位置     | slab 分配器动态管理 |
| PID回收 | 简单标记     | 复杂的PID命名空间   |

Linux 的 `task_struct`（相当于 PCB）通过slab分配器动态创建：

```c
// Linux 内核中创建进程
struct task_struct *p = kmem_cache_alloc(task_struct_cachep, GFP_KERNEL);
```

所以Linux的"最大进程数"不是内存预分配的限制，而是**管理上的限制**（PID空间、资源配额等）。

所以`execute_func()`中的代码：

```c
pcb_t* pcb = get_specific_pcb(new_pid);  // 获取地址（内存已存在）
pcb->pid = new_pid;                       // 初始化内容
pcb->parent = get_specific_pcb(cur_pid);  // 初始化内容
```

### cur_pid 全局变量

系统调用需要知道"当前是哪个进程在调用"，才能访问正确的PCB。`cur_pid`是一个全局变量，追踪**当前正在CPU上执行的进程**：

```c
// syscall_handler.c:15
uint8_t cur_pid = 0;
```

**cur_pid的更新时机**：

| 时机           | 位置                    | 操作                           |
|--------------|-----------------------|------------------------------|
| execute创建新进程 | syscall_handler.c:107 | `cur_pid = new_pid;`         |
| halt返回父进程    | syscall_handler.c:230 | `cur_pid = parent_pcb->pid;` |
| schedule切换进程 | pit.c:96              | `cur_pid = process;`         |

**流程示例**：

```
1. 系统启动，执行 shell (pid=0)
   cur_pid = 0

2. shell 执行 "cat readme.txt"
   execute_func() 中:
   new_pid = get_available_pid();  // 返回 1
   cur_pid = new_pid;              // cur_pid = 1

3. cat 程序调用 read(3, buf, 100)
   read_func() 中:
   pcb = get_specific_pcb(cur_pid);  // 获取 pid=1 的 PCB
   // 从 cat 的 fd_table[3] 读取文件

4. cat 程序调用 halt(0)
   halt_func() 中:
   cur_pid = parent_pcb->pid;  // cur_pid = 0，回到 shell

5. 调度器切换到另一个终端的进程 (pid=2)
   schedule() 中:
   cur_pid = process;  // cur_pid = 2
```

**cur_pid的原子性保护**：

既然是全局变量，如何保证并发安全？答案是**通过关中断 (cli/sti)**：

```c
// execute_func 中
cli();                      // 关中断
// ...
cur_pid = new_pid;          // 修改 cur_pid
// ...
sti();                      // 开中断

// halt_func 中
cli();
cur_pid = parent_pcb->pid;
sti();

// schedule 中
cli();
cur_pid = process;
sti();
```

**为什么关中断就够了？**

这个系统是**单核CPU**，并发只来自**中断**：

```
单核系统的并发来源:
┌─────────────────────────────────────────────┐
│  用户程序执行                                 │
│      │                                      │
│      │ ← PIT 中断 (调度器)                    │
│      │ ← 键盘中断                             │
│      │ ← RTC 中断                            │
│      │                                      │
│  只有中断能打断当前执行                         │
└─────────────────────────────────────────────┘

cli 后:
┌─────────────────────────────────────────────┐
│  代码执行                                    │
│      │                                      │
│      │ ✗ 所有中断被屏蔽                       │
│      │                                      │
│  没有任何东西能打断，天然原子                    │
└─────────────────────────────────────────────┘
```

**单核 vs 多核**：

| 系统类型     | 并发来源        | 保护方式        |
|----------|-------------|-------------|
| 单核 (本项目) | 只有中断        | cli/sti 关中断 |
| 多核       | 中断 + 其他 CPU | 自旋锁 + 关中断   |

如果是多核系统，关中断不够，因为另一个 CPU 核心可以同时执行：

```c
// 多核系统需要自旋锁
spinlock_t pid_lock;

void update_cur_pid(uint8_t new_pid) {
    spin_lock(&pid_lock);    // 原子获取锁
    cur_pid = new_pid;
    spin_unlock(&pid_lock);
}
```

本项目是单核设计，cli/sti足够保证原子性。

### read - 读取

```c
int32_t read_func(int32_t fd, void* buf, int32_t nbytes)
{
    // 1. 参数检查
    if (fd < 0 || fd > 7 || buf == NULL) return -1;

    // 2. 获取当前进程的 PCB (使用 cur_pid)
    pcb_t* pcb = get_specific_pcb(cur_pid);

    // 3. 检查文件是否打开
    if (pcb->fd_table[fd].flags == 0) return -1;

    // 4. 调用对应类型的 read 函数
    return pcb->fd_table[fd].op_table_ptr.read(fd, buf, nbytes);
}
```

多态调用示意：

```
fd = 0 (stdin)  → terminal_read()   → 从键盘缓冲区读取
fd = 3 (文件)   → file_read()       → 从文件系统读取
fd = 4 (RTC)    → rtc_read()        → 等待 RTC 中断
fd = 5 (目录)   → dir_read()        → 读取目录项名称
```

### write - 写入

```c
int32_t write_func(int32_t fd, const void* buf, int32_t nbytes) 
{
    cli();

    if (fd < 0 || fd > 7 || buf == NULL) return -1;

    pcb_t* pcb = get_specific_pcb(cur_pid);
    if (pcb->fd_table[fd].flags == 0) return -1;

    int i = pcb->fd_table[fd].op_table_ptr.write(fd, buf, nbytes);

    sti();
    return i;
}
```

### close - 关闭

```c
int32_t close_func(int32_t fd) 
{
    // stdin (0) 和 stdout (1) 不能关闭
    if (fd < 2 || fd > 7) return -1;

    pcb_t* pcb = get_specific_pcb(cur_pid);
    if (pcb->fd_table[fd].flags == 0) return -1;

    // 标记为未使用
    pcb->fd_table[fd].flags = 0;

    // 调用类型特定的 close
    return pcb->fd_table[fd].op_table_ptr.close(fd);
}
```

---

## getargs - 获取程序参数

### 参数传递机制

当`execute("cat readme.txt")`被调用时：

```
命令字符串:   "cat     readme.txt"
              │           │
              ▼           ▼
         parsed_command  argument
            "cat"       "readme.txt"
```

### 实现

```c
int32_t getargs_func(uint8_t* buf, int32_t nbytes) 
{
    if (buf == NULL || nbytes == 0) return -1;

    pcb_t* pcb = get_specific_pcb(cur_pid);

    // 检查是否有参数
    if (strlen(pcb->arg) == 0) return -1;

    // 复制参数到用户缓冲区
    strncpy((int8_t*)buf, pcb->arg, nbytes);

    return 0;
}
```

### 使用示例

```c
// 用户程序 cat.c
int main() {
    char filename[128];

    // 获取命令行参数
    if (getargs((uint8_t*)filename, 128) == -1) {
        printf("Usage: cat <filename>\n");
        return -1;
    }

    // 打开并读取文件
    int fd = open((uint8_t*)filename);
    // ...
}
```

---

## vidmap - 视频内存映射

### 为什么需要vidmap？

用户程序（如fish动画演示）需要直接操作显存来绘制图形。但显存地址0xB8000在内核空间，用户程序无法直接访问。

### 实现

```c
int32_t vidmap_func(uint8_t** screen_start) {
    // 验证指针在用户空间
    if (screen_start == NULL || (uint32_t)screen_start == _4MB) {
        return -1;
    }

    // 返回给用户的虚拟地址
    *screen_start = (uint8_t*)_132MB;  // 0x8400000 = 132MB

    // 创建页表映射: 132MB (虚拟) → 0xB8000 (物理)
    remap_vid(_132MB, VIDEO);

    return 0;
}
```

### 内存映射示意

```
用户程序虚拟地址空间:
┌───────────────────────────────────────┐ 0x00000000
│                                       │
├───────────────────────────────────────┤ 0x08000000 (128MB)
│         程序代码和数据 (4MB)            │
│         0x08048000 是加载地址          │
├───────────────────────────────────────┤ 0x08400000 (132MB)
│         视频内存映射 ←── vidmap 返回    │
│              │                        │
│              │ 页表映射                │
│              ▼                        │
│         物理地址 0xB8000               │
└───────────────────────────────────────┘

使用方式:
uint8_t* video;
vidmap(&video);
// video 指向 0x8400000
// 写入 video[i] 等同于写入显存 0xB8000 + i
```

---

## 系统调用安全检查

### 参数验证

每个系统调用都必须验证用户传入的参数：

```c
// 1. 空指针检查
if (buf == NULL) return -1;

// 2. 文件描述符范围检查
if (fd < 0 || fd > 7) return -1;

// 3. 文件状态检查
if (pcb->fd_table[fd].flags == 0) return -1;

// 4. 地址范围检查 (vidmap)
if ((uint32_t)screen_start < _128MB) return -1;  // 不在用户空间
```

### stdin/stdout 保护

```c
// close 不能关闭 stdin (0) 和 stdout (1)
if (fd < 2) return -1;

// stdin 不能 write
int32_t no_write(...) { return -1; }

// stdout 不能 read
int32_t no_read(...) { return -1; }
```

---

## 总结

系统调用的核心机制：

| 概念    | 说明                                   |
|-------|--------------------------------------|
| 入口点   | `int $0x80`触发软中断                     |
| 参数传递  | EAX=调用号, EBX/ECX/EDX=参数              |
| 调度表   | `syscall_jumptable`根据调用号分发到对应函数      |
| 文件描述符 | PCB中的`fd_table[8]`，0=stdin, 1=stdout |
| 多态    | 通过`op_table_ptr`实现不同文件类型的统一接口        |
| 返回值   | 通过EAX返回给用户程序                         |

系统调用实现要点：

1. **验证参数** - 检查指针、范围、状态
2. **获取 PCB** - `get_specific_pcb(cur_pid)`
3. **调用驱动** - 通过函数指针表实现多态
4. **返回结果** - 成功返回正值，失败返回 -1
