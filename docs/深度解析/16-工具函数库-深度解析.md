# 工具函数库深度解析

## 概述

`lib.c` 和 `lib.h` 提供了操作系统的基础工具函数，包括：
- 字符串操作
- 内存操作
- 端口 I/O
- 中断控制
- 屏幕输出

这些函数是整个系统的基石，几乎每个模块都会用到。

## 函数分类总览

```
lib.c / lib.h
    │
    ├── 屏幕输出
    │     ├── printf()      格式化输出
    │     ├── puts()        输出字符串
    │     ├── putc()        输出单字符
    │     ├── putc_term()   输出到指定终端
    │     ├── clear()       清屏
    │     ├── scroll()      屏幕滚动
    │     └── update_cursor() 更新光标
    │
    ├── 字符串操作
    │     ├── strlen()      字符串长度
    │     ├── strcpy()      字符串复制
    │     ├── strncpy()     限长复制
    │     ├── strncmp()     字符串比较
    │     ├── strrev()      字符串反转
    │     └── itoa()        整数转字符串
    │
    ├── 内存操作
    │     ├── memset()      内存填充
    │     ├── memcpy()      内存复制
    │     └── memmove()     重叠安全复制
    │
    ├── 端口 I/O
    │     ├── inb/inw/inl   端口读取
    │     └── outb/outw/outl 端口写入
    │
    └── 中断控制
          ├── cli()         关中断
          ├── sti()         开中断
          ├── cli_and_save() 保存并关中断
          └── restore_flags() 恢复中断状态
```

## 屏幕输出函数

### 显存结构

VGA 文本模式显存位于 0xB8000，每个字符占 2 字节：

```
0xB8000 ─────────────────────────────────
    │ 字符0 │ 属性0 │ 字符1 │ 属性1 │ ...
    └───┬───┴───┬───┴───────┴───────┘
        │       │
        │       └── 颜色属性 (前景/背景色)
        └────────── ASCII 字符

属性字节:
┌─────────────────────────────────┐
│ 7 │ 6  5  4 │ 3 │ 2  1  0 │
│闪烁│ 背景色  │高亮│  前景色  │
└─────────────────────────────────┘

本项目的终端颜色:
ATTRIB_TERM1 = 0x0F  白色 (终端1)
ATTRIB_TERM2 = 0x03  青色 (终端2)
ATTRIB_TERM3 = 0x02  绿色 (终端3)
```

### putc() - 输出单个字符

```c
void putc(uint8_t c) {
    // 1. 计算当前光标位置
    screen_x = (current_location % (NUM_COLS*2)) / 2;
    screen_y = current_location / (NUM_COLS * 2);

    // 2. 检查是否需要滚屏
    if (screen_x == NUM_COLS-1 && screen_y == NUM_ROWS-1) {
        scroll();
        screen_y -= 1;
    }

    // 3. 处理特殊字符
    if (c == '\n' || c == '\r') {
        // 换行
        screen_y++;
        screen_x = 0;
    }
    else if (c == '\t') {
        // Tab: 移动 4 格
        screen_x += 4;
    }
    else {
        // 4. 普通字符：写入显存
        //    位置 = (行 * 80 + 列) * 2
        int offset = (NUM_COLS * screen_y + screen_x) << 1;
        *(video_mem + offset) = c;           // 字符
        *(video_mem + offset + 1) = ATTRIB;  // 属性

        screen_x++;
    }

    // 5. 处理换行
    screen_y += screen_x / NUM_COLS;
    screen_x %= NUM_COLS;

    // 6. 更新光标
    current_location = 2 * (screen_x + screen_y * NUM_COLS);
    update_cursor(screen_x + screen_y * NUM_COLS);
}
```

### printf() - 格式化输出

支持的格式说明符：

| 格式 | 含义 | 示例 |
|-----|------|------|
| `%d` | 有符号十进制 | printf("%d", -42) → "-42" |
| `%u` | 无符号十进制 | printf("%u", 42) → "42" |
| `%x` | 十六进制 | printf("%x", 255) → "FF" |
| `%#x` | 8位十六进制 | printf("%#x", 14) → "0000000E" |
| `%c` | 字符 | printf("%c", 65) → "A" |
| `%s` | 字符串 | printf("%s", "hello") → "hello" |
| `%%` | 字面% | printf("%%") → "%" |

**实现原理**：

```c
int32_t printf(int8_t *format, ...) {
    int8_t* buf = format;
    int32_t* esp = (void *)&format;  // 可变参数起始
    esp++;  // 跳过 format 参数

    while (*buf != '\0') {
        if (*buf == '%') {
            buf++;
            switch (*buf) {
                case 'd':
                    // 从栈上获取参数，转换并输出
                    int32_t value = *((int32_t *)esp);
                    itoa(value, conv_buf, 10);
                    puts(conv_buf);
                    esp++;  // 移动到下一个参数
                    break;
                // ... 其他格式
            }
        } else {
            putc(*buf);
        }
        buf++;
    }
}
```

### scroll() - 屏幕滚动

```c
void scroll() {
    int i;
    // 1. 将每一行上移一行
    for (i = NUM_COLS*2; i < NUM_ROWS*NUM_COLS*2; i += 2) {
        video_mem[i - NUM_COLS*2] = video_mem[i];
    }

    // 2. 清空最后一行
    for (i = (NUM_ROWS-1)*NUM_COLS*2; i < NUM_COLS*NUM_ROWS*2; i += 2) {
        video_mem[i] = '\0';
    }
}
```

```
滚动前:                    滚动后:
┌─────────────────┐       ┌─────────────────┐
│ 第0行           │       │ 第1行           │ ← 原第1行
│ 第1行           │  ──→  │ 第2行           │ ← 原第2行
│ 第2行           │       │ ...             │
│ ...             │       │ 第23行          │ ← 原第24行
│ 第24行          │       │                 │ ← 新空行
└─────────────────┘       └─────────────────┘
```

### update_cursor() - 更新光标

VGA 光标通过端口 0x3D4/0x3D5 控制：

```c
void update_cursor(int location) {
    // 光标位置分高低字节发送
    outb(0x0F, 0x3D4);                          // 选择低字节寄存器
    outb((unsigned char)(location & 0xFF), 0x3D5);  // 写入低字节

    outb(0x0E, 0x3D4);                          // 选择高字节寄存器
    outb((unsigned char)((location >> 8) & 0xFF), 0x3D5);  // 写入高字节
}
```

## 字符串操作函数

### strlen() - 字符串长度

```c
uint32_t strlen(const int8_t* s) {
    uint32_t len = 0;
    while (s[len] != '\0')
        len++;
    return len;
}
```

### strncmp() - 字符串比较

```c
int32_t strncmp(const int8_t* s1, const int8_t* s2, uint32_t n) {
    int32_t i;
    for (i = 0; i < n; i++) {
        if ((s1[i] != s2[i]) || (s1[i] == '\0')) {
            return s1[i] - s2[i];  // 返回差值
        }
    }
    return 0;  // 相等
}
```

**返回值**：
- `0`：字符串相等
- `> 0`：s1 > s2
- `< 0`：s1 < s2

### itoa() - 整数转字符串

```c
int8_t* itoa(uint32_t value, int8_t* buf, int32_t radix) {
    static int8_t lookup[] = "0123456789ABCDEF...";
    int8_t *newbuf = buf;

    // 特殊处理 0
    if (value == 0) {
        buf[0] = '0';
        buf[1] = '\0';
        return buf;
    }

    // 从低位到高位提取数字
    while (value > 0) {
        *newbuf = lookup[value % radix];
        newbuf++;
        value /= radix;
    }
    *newbuf = '\0';

    // 反转字符串 (因为是从低位开始的)
    return strrev(buf);
}
```

**示例**：
```
itoa(255, buf, 16):
  255 % 16 = 15 → 'F'
  255 / 16 = 15
  15 % 16 = 15 → 'F'
  15 / 16 = 0
  buf = "FF" (反转后)
```

## 内存操作函数

### memset() - 内存填充

```c
void* memset(void* s, int32_t c, uint32_t n);
```

将 `s` 开始的 `n` 字节设置为 `c`。

**使用场景**：
```c
// 清零缓冲区
memset(buffer, 0, 128);

// 初始化视频内存
memset((void*)0xB8000, 0, 4096);
```

**优化实现**：使用汇编 `rep stosl` 一次写入 4 字节，比逐字节快 4 倍。

### memcpy() - 内存复制

```c
void* memcpy(void* dest, const void* src, uint32_t n);
```

将 `src` 的 `n` 字节复制到 `dest`。

**使用场景**：
```c
// 保存视频内存到备份
memcpy(term[0].vid_backup, (uint8_t*)VIDEO, SCREEN_SIZE);

// 恢复视频内存
memcpy((uint8_t*)VIDEO, term[0].vid_backup, SCREEN_SIZE);
```

**注意**：`memcpy` 不处理内存重叠，如果 src 和 dest 重叠，使用 `memmove`。

### memmove() - 重叠安全复制

```c
void* memmove(void* dest, const void* src, uint32_t n);
```

与 `memcpy` 类似，但能正确处理重叠区域：

```
memcpy 问题 (重叠时):
src:  [A B C D E F]
dest:     [? ? ? ? ? ?]  (dest 在 src 中间)

如果从前向后复制:
step1: [A B A D E F]  dest[0] = src[0]
step2: [A B A B E F]  dest[1] = src[1]  ← 错误! 原 src[3] 被覆盖了

memmove 解决方案:
- 如果 dest > src: 从后向前复制
- 如果 dest < src: 从前向后复制
```

## 端口 I/O 函数

### inb/outb - 字节读写

```c
// 读取端口
static inline uint32_t inb(port) {
    uint32_t val;
    asm volatile (
        "xorl %0, %0    \n"   // val = 0
        "inb (%w1), %b0 \n"   // val = in(port)
        : "=a"(val)
        : "d"(port)
    );
    return val;
}

// 写入端口
#define outb(data, port)            \
    asm volatile (                  \
        "outb %b1, (%w0)"           \
        :                           \
        : "d"(port), "a"(data)      \
    )
```

**使用场景**：

| 设备 | 读/写 | 端口 | 用途 |
|-----|-------|------|------|
| PIC | outb | 0x20, 0xA0 | 发送命令 |
| PIC | outb | 0x21, 0xA1 | 设置掩码 |
| 键盘 | inb | 0x60 | 读取扫描码 |
| RTC | outb/inb | 0x70, 0x71 | 读写 CMOS |
| VGA | outb | 0x3D4, 0x3D5 | 控制光标 |
| PIT | outb | 0x40, 0x43 | 设置定时器 |

### inw/inl 和 outw/outl

类似 inb/outb，但操作 16 位或 32 位数据。

## 中断控制宏

### cli() - 关中断

```c
#define cli()                       \
    asm volatile ("cli"             \
        :                           \
        :                           \
        : "memory", "cc"            \
    )
```

**用途**：进入临界区，防止中断打断

```c
cli();
// 临界区代码，不会被中断打断
cur_pid = new_pid;
sti();
```

### sti() - 开中断

```c
#define sti()                       \
    asm volatile ("sti"             \
        :                           \
        :                           \
        : "memory", "cc"            \
    )
```

### cli_and_save() / restore_flags() - 保存/恢复中断状态

```c
#define cli_and_save(flags)         \
    asm volatile (                  \
        "pushfl          \n"        \
        "popl %0         \n"        \
        "cli             \n"        \
        : "=r"(flags)               \
    )

#define restore_flags(flags)        \
    asm volatile (                  \
        "pushl %0        \n"        \
        "popfl           \n"        \
        :                           \
        : "r"(flags)                \
    )
```

**用途**：嵌套临界区

```c
unsigned long flags;
cli_and_save(flags);    // 保存当前中断状态并关中断

// ... 临界区 ...

restore_flags(flags);   // 恢复之前的中断状态
                        // 如果之前是开的，现在就开
                        // 如果之前是关的，现在就关
```

**为什么不直接用 cli/sti？**

```c
// 错误示例
void func_a() {
    cli();
    func_b();   // func_b 里也有 cli/sti
    // 此时中断被意外开启了！
    sti();
}

void func_b() {
    cli();
    // ...
    sti();  // 问题：这会开启中断，但 func_a 还在临界区！
}

// 正确做法
void func_b() {
    unsigned long flags;
    cli_and_save(flags);
    // ...
    restore_flags(flags);  // 恢复原状态，不强制开启
}
```

## 使用示例

### 调试输出

```c
// 打印变量值
printf("pid = %d, esp = %#x\n", cur_pid, esp);

// 输出: pid = 3, esp = 007FE000
```

### 初始化缓冲区

```c
char buffer[128];
memset(buffer, 0, 128);  // 清零
```

### 读取硬件状态

```c
// 读取键盘扫描码
uint8_t scancode = inb(0x60);

// 发送 EOI 到 PIC
outb(0x60 | irq_num, 0x20);
```

### 保护临界区

```c
void update_global_var() {
    unsigned long flags;
    cli_and_save(flags);

    // 安全地修改全局变量
    global_counter++;

    restore_flags(flags);
}
```

## 常见问题

### 1. printf 格式不匹配

```c
// 错误：%d 期望 int，但传了指针
printf("addr = %d\n", ptr);  // 应该用 %x

// 正确
printf("addr = %x\n", (uint32_t)ptr);
```

### 2. memcpy 方向错误

```c
// 复制时注意方向
memcpy(dest, src, n);  // src → dest，不是 dest → src
```

### 3. 忘记恢复中断

```c
void bad_function() {
    cli();
    // ... 代码 ...
    if (error) return;  // 错误：没有 sti()！
    sti();
}

// 正确做法
void good_function() {
    unsigned long flags;
    cli_and_save(flags);
    // ... 代码 ...
    if (error) {
        restore_flags(flags);
        return;
    }
    restore_flags(flags);
}
```

## 总结

lib.c/lib.h 提供的工具函数：

| 类别 | 主要函数 | 用途 |
|-----|---------|------|
| 屏幕输出 | printf, putc, clear, scroll | 调试、用户交互 |
| 字符串 | strlen, strcpy, strncmp | 命令解析、文件操作 |
| 内存 | memset, memcpy, memmove | 数据初始化、复制 |
| 端口 I/O | inb, outb | 硬件通信 |
| 中断控制 | cli, sti, cli_and_save | 临界区保护 |

这些函数是操作系统的"瑞士军刀"，理解它们有助于理解整个系统的运作。
