# 系统启动深度解析

## 概述

系统启动是理解整个操作系统的起点。本文档按时间顺序介绍从 GRUB 引导到第一个 shell 运行的完整过程。

## 启动流程总览

```
┌─────────────────────────────────────────────────────────────────┐
│  1. BIOS/UEFI                                                   │
│     - 硬件自检 (POST)                                            │
│     - 加载引导扇区                                                │
└───────────────────────────────┬─────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│  2. GRUB (引导加载程序)                                          │
│     - 加载内核到内存                                              │
│     - 加载文件系统镜像 (模块)                                      │
│     - 跳转到内核入口 _start                                       │
└───────────────────────────────┬─────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│  3. boot.S (汇编入口)                                            │
│     - 关中断                                                     │
│     - 加载 GDT、IDT                                              │
│     - 设置栈指针 ESP = 8MB                                        │
│     - 设置段寄存器                                                │
│     - 调用 entry()                                               │
└───────────────────────────────┬─────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│  4. kernel.c entry() (C 入口)                                    │
│     - 验证 Multiboot 魔数                                        │
│     - 打印启动信息                                                │
│     - 设置 LDT、TSS                                              │
│     - 初始化各子系统                                              │
│     - 启动第一个 shell                                            │
└───────────────────────────────┬─────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│  5. 用户程序运行                                                  │
│     - shell 等待用户输入                                          │
└─────────────────────────────────────────────────────────────────┘
```

## 阶段 1：GRUB 引导

### Multiboot 协议

GRUB 使用 Multiboot 协议与内核交互。内核必须在前 8KB 包含一个 Multiboot 头：

```asm
# boot.S
.text
    # Multiboot header (required for GRUB to boot us)
    .long MULTIBOOT_HEADER_MAGIC     # 魔数: 0x1BADB002
    .long MULTIBOOT_HEADER_FLAGS     # 标志
    .long -(MULTIBOOT_HEADER_MAGIC + MULTIBOOT_HEADER_FLAGS)  # 校验和
```

### GRUB 传递的信息

GRUB 跳转到内核时：
- **EAX** = Multiboot 魔数 (0x2BADB002)
- **EBX** = Multiboot 信息结构体地址

```c
// multiboot.h
typedef struct multiboot_info {
    uint32_t flags;           // 哪些字段有效
    uint32_t mem_lower;       // 低端内存大小 (KB)
    uint32_t mem_upper;       // 高端内存大小 (KB)
    uint32_t mods_count;      // 加载的模块数量
    uint32_t mods_addr;       // 模块信息数组地址
    // ... 更多字段
} multiboot_info_t;
```

## 阶段 2：boot.S 汇编入口

### 完整代码解析

```asm
.globl start, _start

start:
_start:
    # 1. 关闭中断，防止意外中断
    cli

    # 2. 加载全局描述符表 (GDT)
    lgdt gdt_desc_ptr

    # 3. 加载中断描述符表 (IDT)
    lidt idt_desc_ptr

    # 4. 远跳转，刷新 CS 段寄存器
    ljmp $KERNEL_CS, $keep_going

keep_going:
    # 5. 设置栈指针 (8MB 位置)
    movl $0x800000, %esp

    # 6. 设置所有数据段寄存器
    movw $KERNEL_DS, %cx
    movw %cx, %ss        # 栈段
    movw %cx, %ds        # 数据段
    movw %cx, %es        # 附加段
    movw %cx, %fs
    movw %cx, %gs

    # 7. 压入 entry() 的参数
    pushl %ebx           # Multiboot 信息结构体地址
    pushl %eax           # Multiboot 魔数

    # 8. 调用 C 入口函数
    call entry

halt:
    hlt
    jmp halt
```

### 关键步骤详解

**为什么要 cli？**
```
GRUB 跳转到内核时，中断可能是开启的
但此时 IDT 还没设置好，如果发生中断会导致三重故障
所以第一件事就是关中断
```

**为什么要 lgdt/lidt？**
```
GRUB 有自己的 GDT/IDT，但内核需要使用自己的
lgdt 加载新的 GDT
lidt 加载新的 IDT（此时是空的，稍后在 C 中填充）
```

**为什么要远跳转 ljmp？**
```
加载新 GDT 后，CS 寄存器还缓存着旧值
ljmp 强制 CPU 使用新的代码段描述符
格式: ljmp $段选择子, $偏移地址
```

**为什么栈设在 8MB？**
```
内存布局:
0-4MB:    内核代码和数据
4MB-8MB:  内核栈和 PCB
8MB+:     用户程序空间

ESP = 0x800000 (8MB) 是内核栈的起始位置
栈向下增长，所以从 8MB 开始
```

## 阶段 3：kernel.c entry() 函数

### 函数签名

```c
void entry(unsigned long magic, unsigned long addr);
```

参数来自 boot.S 压栈：
- `magic` = EAX = 0x2BADB002 (Multiboot 魔数)
- `addr` = EBX = Multiboot 信息结构体地址

### 初始化顺序

```c
void entry(unsigned long magic, unsigned long addr) {
    multiboot_info_t *mbi = (multiboot_info_t *)addr;

    // ========== 1. 基本验证 ==========
    clear();  // 清屏

    // 验证 Multiboot 魔数
    if (magic != MULTIBOOT_BOOTLOADER_MAGIC) {
        printf("Invalid magic number!\n");
        return;
    }

    // ========== 2. 打印启动信息 ==========
    printf("flags = 0x%x\n", mbi->flags);
    // ... 打印内存信息、模块信息等

    // ========== 3. 设置 LDT ==========
    {
        seg_desc_t the_ldt_desc;
        // ... 设置 LDT 描述符
        SET_LDT_PARAMS(the_ldt_desc, &ldt, ldt_size);
        ldt_desc_ptr = the_ldt_desc;
        lldt(KERNEL_LDT);
    }

    // ========== 4. 设置 TSS ==========
    {
        seg_desc_t the_tss_desc;
        // ... 设置 TSS 描述符
        SET_TSS_PARAMS(the_tss_desc, &tss, tss_size);
        tss_desc_ptr = the_tss_desc;

        tss.ldt_segment_selector = KERNEL_LDT;
        tss.ss0 = KERNEL_DS;      // 内核栈段
        tss.esp0 = 0x800000;      // 内核栈指针 (8MB)
        ltr(KERNEL_TSS);          // 加载任务寄存器
    }

    // ========== 5. 初始化子系统 ==========
    initialize_IDT();             // IDT (中断描述符表)

    module_t* fs_mod = (module_t*)mbi->mods_addr;
    init_file_system(fs_mod->mod_start);  // 文件系统

    init_paging();                // 分页
    i8259_init();                 // PIC (中断控制器)

    sti();                        // 开中断

    init_keyboard();              // 键盘
    rtc_init();                   // RTC
    prep_term();                  // 终端预初始化
    pit_init();                   // PIT (定时器)
    init_term();                  // 终端初始化 (启动 shell)

    // ========== 6. 空转等待 ==========
    asm volatile (".1: hlt; jmp .1;");
}
```

### 初始化顺序图

```
entry()
   │
   ├─→ 验证 Multiboot 魔数
   │
   ├─→ 设置 LDT/TSS
   │      │
   │      ├─→ TSS.ss0 = KERNEL_DS (内核数据段)
   │      └─→ TSS.esp0 = 8MB (内核栈)
   │
   ├─→ initialize_IDT()
   │      └─→ 设置异常处理、中断处理、系统调用入口
   │
   ├─→ init_file_system()
   │      └─→ 解析文件系统镜像
   │
   ├─→ init_paging()
   │      └─→ 设置页目录、页表，启用分页
   │
   ├─→ i8259_init()
   │      └─→ 初始化 PIC，启用级联
   │
   ├─→ sti()  ← 此时可以安全地开中断了
   │
   ├─→ init_keyboard()
   │      └─→ enable_irq(1)
   │
   ├─→ rtc_init()
   │      └─→ enable_irq(8)
   │
   ├─→ prep_term()
   │      └─→ 初始化 term[].running_pid = -1
   │
   ├─→ pit_init()
   │      └─→ enable_irq(0)
   │
   └─→ init_term()
          └─→ execute("shell")  ← 启动第一个用户程序
```

### 为什么这个顺序？

| 步骤 | 依赖 | 原因 |
|-----|------|------|
| LDT/TSS | 无 | 后续特权级切换需要 |
| IDT | 无 | 所有中断/异常需要 |
| 文件系统 | 无 | execute 需要读取程序 |
| 分页 | 无 | 进程隔离需要 |
| PIC | IDT | 硬件中断需要 IDT 已设置 |
| sti() | IDT, PIC | 开中断前必须准备好处理 |
| 键盘/RTC/PIT | PIC, IDT | 设备中断需要 PIC 和 IDT |
| 终端 | 所有上述 | 启动 shell 需要一切就绪 |

## 阶段 4：启动第一个 Shell

### init_term() 函数

```c
int32_t init_term() {
    // 1. 初始化三个终端的数据结构
    term[0].term_id = 0;
    term[1].term_id = 1;
    term[2].term_id = 2;

    term[0].vid_backup = (uint8_t*)VIDEOA;  // 0xB9000
    term[1].vid_backup = (uint8_t*)VIDEOB;  // 0xBA000
    term[2].vid_backup = (uint8_t*)VIDEOC;  // 0xBB000

    for (i = 0; i < 3; i++) {
        term[i].cursor_location = 0;
        term[i].cursor_x = 0;
        term[i].cursor_y = 0;
        // ... 其他初始化
    }

    // 2. 设置当前终端为 0
    curr_term = 0;
    restore_term_info(0);

    // 3. 启动第一个 shell！
    return execute((uint8_t*)"shell");
}
```

### execute("shell") 做了什么

```
execute("shell")
       │
       ├─→ 在文件系统中找到 "shell" 程序
       │
       ├─→ 分配 pid = 0
       │
       ├─→ 设置进程页表 (128MB → 8MB)
       │
       ├─→ 加载程序到 0x08048000
       │
       ├─→ 初始化 PCB[0]
       │
       ├─→ 设置 TSS.esp0 (进程 0 的内核栈)
       │
       └─→ iret 跳转到 shell 入口
              └─→ shell 开始运行，显示 "391OS> "
```

## 内存布局 (启动后)

```
0x00000000 ─────────────────────────────
           │  (保留区域)                │
0x00100000 (1MB) ──────────────────────
           │  内核代码和数据             │
           │  (从 GRUB 加载)            │
0x00400000 (4MB) ──────────────────────
           │  内核页表                  │
           │  (分页相关结构)             │
0x00800000 (8MB) ──────────────────────
           │  PCB[0] + 内核栈0          │ ← shell 的内核栈
           │  PCB[1] + 内核栈1          │
           │  ...                       │
0x00C00000 (12MB) ─────────────────────
           │  用户程序 (shell)          │
           │  物理地址 8MB 开始          │
           │  虚拟地址映射到 128MB       │
           │  ...                       │
0x08000000 (128MB) ────────────────────
           │  用户程序虚拟地址空间        │
           │  0x08048000 是加载地址      │
           │  ...                       │
0x08400000 (132MB) ────────────────────
           │  vidmap 映射区域           │
           │  (用户程序访问显存)          │
           │  ...                       │
```

## TSS 的作用

TSS (Task State Segment) 在本项目中主要用于**特权级切换**时获取内核栈：

```c
// kernel.c 中设置
tss.ss0 = KERNEL_DS;      // 内核栈使用的段
tss.esp0 = 0x800000;      // 内核栈指针

// 当用户程序发生中断/系统调用时:
// CPU 自动从 TSS 获取 ss0:esp0，切换到内核栈
```

```
用户态 (Ring 3)           中断/系统调用            内核态 (Ring 0)
┌─────────────┐                │                  ┌─────────────┐
│  用户栈     │                │                  │  内核栈     │
│  ESP(用户)  │                │                  │  ESP(内核)  │
└─────────────┘                │                  └─────────────┘
                               │
                      CPU 从 TSS 获取
                      SS0:ESP0 切换栈
```

## 常见问题

### 1. 为什么内核入口不是 main()？

GRUB 直接跳转到 `_start` 符号。我们可以把 C 入口函数叫任何名字，这里叫 `entry()`。

### 2. 为什么要在汇编中设置段寄存器？

C 语言无法直接操作段寄存器。必须用汇编设置好段寄存器后，C 代码才能正常访问内存。

### 3. 为什么 init_term() 后内核就 hlt 了？

`init_term()` 调用 `execute("shell")`，这会切换到用户态运行 shell。
`execute` 不会返回（除非 shell 退出）。
`hlt` 只是以防万一的兜底。

### 4. 第一个进程的 parent 是谁？

第一个 shell (pid=0) 的 parent 指针为 NULL 或指向自己。
当它调用 halt 时，系统会重新启动一个 shell。

## 总结

启动流程的核心阶段：

| 阶段 | 执行者 | 主要任务 |
|-----|-------|---------|
| 1 | GRUB | 加载内核和模块到内存 |
| 2 | boot.S | 设置 GDT/IDT/栈，跳转到 C |
| 3 | entry() | 初始化所有子系统 |
| 4 | init_term() | 启动第一个 shell |

初始化顺序的关键依赖：

```
IDT (异常/中断入口)
    ↓
PIC (硬件中断控制)
    ↓
sti() (开中断)
    ↓
设备驱动 (键盘、RTC、PIT)
    ↓
终端 + execute("shell")
```

理解启动流程有助于理解整个系统的架构：**从硬件抽象到进程管理，每一层都建立在前一层之上**。
