# IDT (中断描述符表) 深度解析

## 1. 为什么需要 IDT？

当 CPU 执行过程中发生中断或异常时，它需要知道跳转到哪里处理。IDT 就是这个"电话簿"：

```
用户程序执行中
      │
      ▼
  x = 1/0  ← 除零异常！
      │
      ▼
  CPU: "发生异常 #0，去哪里处理？"
      │
      ▼
  查找 IDT[0] → 获取处理函数地址 → 跳转执行
```

**IDT 基本信息**：

- 共256个表项（索引 0-255）
- 每个表项8字节
- 通过IDTR寄存器告诉CPU位置
- 使用`lidt`指令加载

**向量分配**：

| 范围 | 用途 |
|------|------|
| 0-19 | CPU 异常（Intel 定义）|
| 20-31 | Intel 保留 |
| 32-255 | 用户可用（硬件中断、系统调用）|

---

## 2. 术语辨析：异常 vs 中断

### 2.1 广义与狭义

"中断"有广义和狭义之分：

```
广义的"中断" (Interrupt) ─── IDT 处理的所有事件
│
├── 异常 (Exception)              [向量 0-31]
│   │   CPU 内部检测到的事件（被动触发）
│   │
│   ├── 故障 (Fault)              可恢复，返回触发指令重新执行
│   │     例：#PF 页错误、#GP 通用保护
│   │
│   ├── 陷阱 (Trap)               返回下一条指令继续执行
│   │     例：#BP 断点 (INT 3)、#OF 溢出
│   │
│   └── 终止 (Abort)              不可恢复，必须终止程序
│         例：#DF 双重错误、#MC 机器检查
│
└── 中断 (Interrupt)              [向量 32-255]
    │   外部事件或软件指令触发（主动触发）
    │
    ├── 硬件中断 (Hardware IRQ)    外部设备触发
    │     例：键盘、定时器、RTC
    │
    └── 软件中断 (Software)        INT n 指令触发
          例：INT 0x80 系统调用
```

### 2.2 简单记忆

| 向量范围 | 类型 | 触发方式 | 例子 |
|----------|------|----------|------|
| 0-19 | **CPU 异常** | CPU 检测（被动）| 除零、页错误、GP 错误 |
| 20-31 | **Intel 保留** | - | 不使用 |
| 32-47 | **硬件中断** | IRQ 0-15（主动）| 定时器、键盘、RTC |
| 48-255 | **软件中断** | INT n 指令 | 系统调用 (0x80) |

### 2.3 代码中的对应

```c
void initialize_IDT() {
    for (i = 0; i < NUM_VEC; i++) {
        // ...
        if (i < 32) {
            idt[i].reserved3 = 1;  // 异常 (0-31) 用陷阱门
        }
        // i >= 32 默认用中断门（硬件中断）
    }
}

void set_exceptions() {   // 设置异常 (0-31)
    SET_IDT_ENTRY(idt[0], EXCEPTION_0);   // #DE 除零异常
    SET_IDT_ENTRY(idt[14], EXCEPTION_14); // #PF 页错误
    // ...
}

void set_interrupts() {   // 设置中断 (32+)
    SET_IDT_ENTRY(idt[32], PIT_handler);  // IRQ0 定时器
    SET_IDT_ENTRY(idt[33], KB_handler);   // IRQ1 键盘
    SET_IDT_ENTRY(idt[40], RTC_handler);  // IRQ8 RTC
}
```

**总结**：狭义上，**0-31 是异常，32 之后是中断**。

---

## 3. IDT 表项结构（8字节）

### 3.1 代码中的定义 (x86_desc.h:149-164)

```c
typedef union idt_desc_t {
    uint32_t val[2];           // 作为两个32位整数访问
    struct {
        uint16_t offset_15_00;  // 处理函数地址 低16位  [字节 0-1]
        uint16_t seg_selector;  // 段选择子            [字节 2-3]
        uint8_t  reserved4;     // 必须为 0            [字节 4]
        uint32_t reserved3 : 1; // 门类型位            [字节 5, bit 0]
        uint32_t reserved2 : 1; // 必须为 1            [字节 5, bit 1]
        uint32_t reserved1 : 1; // 必须为 1            [字节 5, bit 2]
        uint32_t size      : 1; // 1=32位, 0=16位      [字节 5, bit 3]
        uint32_t reserved0 : 1; // 必须为 0            [字节 5, bit 4]
        uint32_t dpl       : 2; // 特权级 (0-3)        [字节 5, bit 5-6]
        uint32_t present   : 1; // 存在位              [字节 5, bit 7]
        uint16_t offset_31_16;  // 处理函数地址 高16位 [字节 6-7]
    } __attribute__ ((packed));
} idt_desc_t;
```

### 3.2 位字段布局图

```
字节:    7        6        5        4        3        2        1        0
      ┌────────┬────────┬────────┬────────┬────────┬────────┬────────┬────────┐
 位:  │31    24│23    16│15     8│7      0│31    16│15     8│7      0│        │
      ├────────┴────────┼─┬──┬─┬─┬─┬─┬────┼────────┼────────┴────────┼────────┤
      │  offset 31:16   │P│DPL│0│D│1│1│T│ │   00   │   seg_selector  │off15:0 │
      └─────────────────┴─┴──┴─┴─┴─┴─┴─┴──┴────────┴─────────────────┴────────┘
                         │  │  │ │ │ │ │
                         │  │  │ │ │ │ └── reserved3 (T): 门类型
                         │  │  │ │ │ └──── reserved2: 固定=1
                         │  │  │ │ └────── reserved1: 固定=1
                         │  │  │ └──────── size (D): 1=32位门
                         │  │  └────────── reserved0: 固定=0
                         │  └───────────── dpl: 描述符特权级
                         └──────────────── present: 存在位
```

### 3.3 字段详解

| 字段               | 位数 | 说明                          |
|------------------|----|-----------------------------|
| **offset_15_00** | 16 | 处理函数地址的低16位                 |
| **seg_selector** | 16 | 段选择子，通常是 KERNEL_CS (0x0010) |
| **reserved4**    | 8  | 必须为 0                       |
| **reserved3**    | 1  | **门类型**：0=中断门, 1=陷阱门        |
| **reserved2**    | 1  | 必须为 1                       |
| **reserved1**    | 1  | 必须为 1                       |
| **size**         | 1  | 门大小：1=32位, 0=16位            |
| **reserved0**    | 1  | 必须为 0                       |
| **dpl**          | 2  | 描述符特权级 (0=内核, 3=用户)         |
| **present**      | 1  | 1=表项有效, 0=无效                |
| **offset_31_16** | 16 | 处理函数地址的高16位                 |

---

## 4. 中断门 vs 陷阱门

### 4.1 门类型编码

reserved3/2/1/size 组合决定门类型：

| reserved3 | reserved2 | reserved1 | size | 二进制  | 十六进制 | 类型     |
|-----------|-----------|-----------|------|------|------|--------|
| 0         | 1         | 1         | 1    | 1110 | 0xE  | 32位中断门 |
| 1         | 1         | 1         | 1    | 1111 | 0xF  | 32位陷阱门 |

### 4.2 核心区别

```
┌─────────────────────────────────────────────────────────────────┐
│                   中断门 (Interrupt Gate)                       │
│                   reserved3 = 0, Type = 0xE                     │
├─────────────────────────────────────────────────────────────────┤
│  行为：进入时 CPU 自动清除 EFLAGS.IF (关闭中断)                  │
│                                                                 │
│  效果：处理期间不会被其他中断打断                                │
│                                                                 │
│  用途：硬件中断                                                  │
│        - IRQ 0: PIT 定时器 → IDT[32]                            │
│        - IRQ 1: 键盘      → IDT[33]                             │
│        - IRQ 8: RTC       → IDT[40]                             │
│                                                                 │
│  原因：防止中断嵌套导致栈溢出                                    │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    陷阱门 (Trap Gate)                           │
│                    reserved3 = 1, Type = 0xF                    │
├─────────────────────────────────────────────────────────────────┤
│  行为：进入时不修改 EFLAGS.IF (保持中断状态)                     │
│                                                                 │
│  效果：处理期间可以响应更高优先级的中断                          │
│                                                                 │
│  用途：CPU 异常和系统调用                                        │
│        - 异常 0-19: 除零、页错误、GP错误等                       │
│        - 系统调用: INT 0x80                                      │
│                                                                 │
│  原因：异常处理可能需要较长时间，不应阻塞紧急中断                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.3 为什么这样设计？

**硬件中断用中断门**：

- 硬件中断频繁发生（如定时器每秒上千次）
- 如果不关中断，中断 A 处理中又来中断 B，B 处理中又来 A...
- 栈会不断增长，最终溢出
- 所以必须关中断，处理完一个再处理下一个

**异常用陷阱门**：

- 异常处理可能耗时较长（如页错误需要从磁盘加载）
- 如果关中断，整个系统会卡住
- 更高优先级的事件（如 NMI）应该能打断异常处理

**系统调用用陷阱门**：

- 系统调用可能阻塞（如 read 等待输入）
- 必须允许中断，否则系统会假死

---

## 5. DPL（描述符特权级）

### 5.1 x86 特权级

```
       Ring 0 (内核态)
      ┌─────────────┐
      │   Kernel    │  最高特权，可以执行所有指令
      │             │  可以访问所有内存
      └──────┬──────┘
             │
       Ring 1, 2 (很少使用)
             │
      ┌──────┴──────┐
      │    User     │  Ring 3 (用户态)
      │  Programs   │  受限，不能直接访问硬件
      └─────────────┘
```

### 5.2 DPL 的作用

IDT 表项的 DPL 决定了**谁可以通过软件中断（INT n）触发这个处理程序**：

```
规则：CPL <= DPL 才能触发

CPL = Current Privilege Level (当前特权级)
DPL = Descriptor Privilege Level (描述符特权级)
```

**例子**：

| 场景            | CPL | DPL | 能否触发 | 说明           |
|---------------|-----|-----|------|--------------|
| 内核执行 INT 0x80 | 0   | 3   | ✅    | 0 <= 3       |
| 用户执行 INT 0x80 | 3   | 3   | ✅    | 3 <= 3       |
| 用户执行 INT 0x0E | 3   | 0   | ❌    | 3 > 0，触发 #GP |

### 5.3 为什么系统调用 DPL=3？

```c
if (i == 0x80) {
    idt[i].dpl = 3;  // 允许用户态调用
}
```

**原因**：系统调用是用户程序**主动**请求内核服务的方式。

```
用户程序 (Ring 3)              内核 (Ring 0)
┌─────────────────┐           ┌─────────────────┐
│ printf("hi")    │           │                 │
│      │          │           │                 │
│      ▼          │           │                 │
│ write() 系统调用│  INT 0x80 │                 │
│      │          │ ────────► │ sys_write()     │
│      │          │           │      │          │
│      │          │ ◄──────── │      │          │
│ 继续执行        │   iret    │                 │
└─────────────────┘           └─────────────────┘
```

如果 `DPL=0`，用户程序执行 `INT 0x80` 会触发 **#GP (General Protection Fault)**，系统调用就无法工作。

### 5.4 为什么异常 DPL=0？

```c
idt[i].dpl = 0;  // 默认值
```

**原因**：异常是 CPU **被动**检测到的错误，不是软件主动触发的。

- 用户程序不应该能用 `INT 0` 假装发生了除零异常
- 即使 DPL=0，当真正的除零发生时，CPU 硬件会忽略 DPL 检查
- 这防止了恶意程序伪造异常

---

## 6. idt_init.c 代码详解

### 6.1 完整代码分析

```c
void initialize_IDT() {
    int i;

    // ========== 第一步：初始化所有 256 个表项 ==========
    for (i = 0; i < NUM_VEC; i++) {

        // 段选择子 = KERNEL_CS (0x0010)
        // 原因：所有处理函数都在内核代码段中
        idt[i].seg_selector = KERNEL_CS;

        // 保留字节必须为 0
        idt[i].reserved4 = 0;

        // size = 1 表示 32 位门
        // 如果是 0，表示 16 位门（实模式遗留，现在不用）
        idt[i].size = 1;

        // 默认使用中断门 (reserved3 = 0)
        // Type = 0 1 1 1 = 0xE (中断门)
        idt[i].reserved3 = 0;
        idt[i].reserved2 = 1;  // 固定值
        idt[i].reserved1 = 1;  // 固定值
        idt[i].reserved0 = 0;  // 固定值

        // DPL = 0，只有内核能通过 INT n 触发
        idt[i].dpl = 0;

        // present = 1，表项有效
        idt[i].present = 1;

        // ===== 异常 (0-31) 使用陷阱门 =====
        if (i < 32) {
            idt[i].reserved3 = 1;  // Type = 0xF (陷阱门)
            // 原因：异常处理期间允许响应中断
        }

        // ===== 系统调用 (0x80) 特殊处理 =====
        if (i == 0x80) {
            idt[i].reserved3 = 1;  // 陷阱门（允许中断）
            idt[i].dpl = 3;        // 允许用户态调用
        }
    }

    // ========== 第二步：设置异常处理函数地址 ==========
    set_exceptions();

    // ========== 第三步：设置中断处理函数地址 ==========
    set_interrupts();

    // ========== 第四步：设置系统调用 ==========
    SET_IDT_ENTRY(idt[0x80], syscall);
}
```

### 6.2 set_exceptions() 分析

```c
void set_exceptions() {
    // SET_IDT_ENTRY 宏展开后：
    // idt[n].offset_31_16 = (handler >> 16) & 0xFFFF;  // 高16位
    // idt[n].offset_15_00 = handler & 0xFFFF;          // 低16位

    SET_IDT_ENTRY(idt[0], EXCEPTION_0);   // #DE 除零错误
    SET_IDT_ENTRY(idt[1], EXCEPTION_1);   // #DB 调试异常
    SET_IDT_ENTRY(idt[2], EXCEPTION_2);   // NMI 不可屏蔽中断
    SET_IDT_ENTRY(idt[3], EXCEPTION_3);   // #BP 断点
    SET_IDT_ENTRY(idt[4], EXCEPTION_4);   // #OF 溢出
    SET_IDT_ENTRY(idt[5], EXCEPTION_5);   // #BR 边界检查
    SET_IDT_ENTRY(idt[6], EXCEPTION_6);   // #UD 无效操作码
    SET_IDT_ENTRY(idt[7], EXCEPTION_7);   // #NM 设备不可用
    SET_IDT_ENTRY(idt[8], EXCEPTION_8);   // #DF 双重错误 (有错误码)
    SET_IDT_ENTRY(idt[9], EXCEPTION_9);   // 协处理器段溢出
    SET_IDT_ENTRY(idt[10], EXCEPTION_10); // #TS 无效TSS (有错误码)
    SET_IDT_ENTRY(idt[11], EXCEPTION_11); // #NP 段不存在 (有错误码)
    SET_IDT_ENTRY(idt[12], EXCEPTION_12); // #SS 栈段错误 (有错误码)
    SET_IDT_ENTRY(idt[13], EXCEPTION_13); // #GP 通用保护 (有错误码)
    SET_IDT_ENTRY(idt[14], EXCEPTION_14); // #PF 页错误 (有错误码)
    // 15 是 Intel 保留
    SET_IDT_ENTRY(idt[16], EXCEPTION_16); // #MF x87 FPU 错误
    SET_IDT_ENTRY(idt[17], EXCEPTION_17); // #AC 对齐检查 (有错误码)
    SET_IDT_ENTRY(idt[18], EXCEPTION_18); // #MC 机器检查
    SET_IDT_ENTRY(idt[19], EXCEPTION_19); // #XM SIMD 浮点异常

    // 20-31 是 Intel 保留，复用 EXCEPTION_1
    SET_IDT_ENTRY(idt[20], EXCEPTION_1);
    // ... 21-31 类似
}
```

### 6.3 set_interrupts() 分析

```c
void set_interrupts() {
    // IRQ 号 + 32 = IDT 索引
    // 这是因为 8259 PIC 重映射了 IRQ

    SET_IDT_ENTRY(idt[32], PIT_handler);  // IRQ 0: 定时器
    SET_IDT_ENTRY(idt[33], KB_handler);   // IRQ 1: 键盘
    SET_IDT_ENTRY(idt[40], RTC_handler);  // IRQ 8: RTC

    // 注意：这些使用中断门 (reserved3 = 0)
    // 在 initialize_IDT() 中，i >= 32 时默认就是中断门
}
```

---

## 7. 20 个 CPU 异常列表

| 向量 | 助记符 | 名称                   | 类型         | 错误码   | 说明         |
|----|-----|----------------------|------------|-------|------------|
| 0  | #DE | Divide Error         | Fault      | 无     | 除零或商溢出     |
| 1  | #DB | Debug                | Fault/Trap | 无     | 调试异常       |
| 2  | -   | NMI                  | Interrupt  | 无     | 不可屏蔽中断     |
| 3  | #BP | Breakpoint           | Trap       | 无     | INT 3 指令   |
| 4  | #OF | Overflow             | Trap       | 无     | INTO 指令    |
| 5  | #BR | BOUND Range          | Fault      | 无     | BOUND 指令   |
| 6  | #UD | Invalid Opcode       | Fault      | 无     | 无效指令       |
| 7  | #NM | Device Not Available | Fault      | 无     | FPU 不可用    |
| 8  | #DF | Double Fault         | Abort      | 有(=0) | 处理异常时又发生异常 |
| 9  | -   | Coprocessor Overrun  | Fault      | 无     | 已废弃        |
| 10 | #TS | Invalid TSS          | Fault      | **有** | TSS 无效     |
| 11 | #NP | Segment Not Present  | Fault      | **有** | 段不存在       |
| 12 | #SS | Stack Segment Fault  | Fault      | **有** | 栈段错误       |
| 13 | #GP | General Protection   | Fault      | **有** | 通用保护错误     |
| 14 | #PF | Page Fault           | Fault      | **有** | 页错误        |
| 15 | -   | Reserved             | -          | -     | Intel 保留   |
| 16 | #MF | x87 FPU Error        | Fault      | 无     | FPU 错误     |
| 17 | #AC | Alignment Check      | Fault      | 有(=0) | 对齐检查       |
| 18 | #MC | Machine Check        | Abort      | 无     | 机器检查       |
| 19 | #XM | SIMD Floating-Point  | Fault      | 无     | SIMD 异常    |

**有错误码的异常**：8, 10, 11, 12, 13, 14, 17

---

## 8. 关键问题回答

### Q1: 为什么 seg_selector = KERNEL_CS？

**答**：处理函数位于内核代码段中。

当中断发生时，CPU 会：

1. 从 IDT 表项获取段选择子和偏移
2. 通过 GDT 查找该段的基地址
3. 基地址 + 偏移 = 处理函数的线性地址

KERNEL_CS (0x0010) 指向 GDT 中的内核代码段，基地址为 0。

#### 深入：段基址和偏移量存在哪里？

**偏移量**存在 **IDT 表项**中（`offset_15_00` + `offset_31_16`）。

**段基址**存在 **GDT 表项**中。

```
中断发生（例如 INT 0x80）
        │
        ▼
┌─────────────────────────────────────────────────────────────────┐
│  第一步：从 IDT 获取 段选择子 + 偏移量                           │
│                                                                 │
│  IDT[0x80] 表项（8字节）：                                       │
│  ┌──────────────┬──────────────┬─────────┬──────────────────┐   │
│  │ offset_31_16 │ 属性字节     │ 00      │ seg_selector     │   │
│  │ (高16位)     │ P|DPL|Type   │         │ = KERNEL_CS      │   │
│  │ = 0x0040     │              │         │ = 0x0010         │   │
│  ├──────────────┴──────────────┴─────────┼──────────────────┤   │
│  │                                       │ offset_15_00     │   │
│  │                                       │ (低16位)         │   │
│  │                                       │ = 0x1234         │   │
│  └───────────────────────────────────────┴──────────────────┘   │
│                                                                 │
│  偏移量 = (offset_31_16 << 16) | offset_15_00                   │
│        = (0x0040 << 16) | 0x1234                                │
│        = 0x00401234                                             │
└─────────────────────────────────────────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────────────────────────────────┐
│  第二步：用段选择子查 GDT，获取段基址                            │
│                                                                 │
│  seg_selector = 0x0010 = 0000 0000 0001 0000 (二进制)           │
│                          ├──────────┤├─┤├─┤                     │
│                             Index    TI RPL                     │
│                              = 2     =0  =0                     │
│                                                                 │
│  Index = 2  → 指向 GDT[2]                                       │
│  TI = 0     → 使用 GDT (不是 LDT)                               │
│  RPL = 0    → 请求特权级 0                                      │
│                                                                 │
│  GDT[2] = 0x00CF9A000000FFFF (KERNEL_CS 对应的描述符)           │
│  段基址 = 0x00000000                                            │
└─────────────────────────────────────────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────────────────────────────────┐
│  第三步：计算线性地址                                            │
│                                                                 │
│  线性地址 = 段基址 + 偏移量                                      │
│          = 0x00000000 + 0x00401234                              │
│          = 0x00401234                                           │
│                                                                 │
│  （因为基址=0，所以偏移量就是线性地址）                          │
└─────────────────────────────────────────────────────────────────┘
        │
        ▼
    CPU 跳转到 0x00401234 执行处理函数
```

#### GDT 的结构 (x86_desc.S)

```
GDT (全局描述符表)
│
├── Entry 0: 0x0000000000000000  (NULL，CPU 要求不可用)
├── Entry 1: 0x0000000000000000  (NULL)
├── Entry 2: 0x00CF9A000000FFFF  ← KERNEL_CS (0x0010)
├── Entry 3: 0x00CF92000000FFFF  ← KERNEL_DS (0x0018)
├── Entry 4: 0x00CFFA000000FFFF  ← USER_CS   (0x0023)
├── Entry 5: 0x00CFF2000000FFFF  ← USER_DS   (0x002B)
├── Entry 6: TSS 描述符
└── Entry 7: LDT 描述符
```

#### GDT 描述符解析

以 `KERNEL_CS = 0x00CF9A000000FFFF` 为例：

```
字节:     7        6        5        4        3        2        1        0
       0x00     0xCF     0x9A     0x00     0x00     0x00     0xFF     0xFF

┌─────────────────────────────────────────────────────────────────────────┐
│  Base 31:24  │ G │D/B│ 0 │AVL│Limit│ P │ DPL │ S │ Type │ Base 23:16  │
│     0x00     │ 1 │ 1 │ 0 │ 0 │ F   │ 1 │  0  │ 1 │ 1010 │    0x00     │
├─────────────────────────────────────────────────────────────────────────┤
│           Base 15:0            │         Segment Limit 15:0            │
│            0x0000              │              0xFFFF                   │
└─────────────────────────────────────────────────────────────────────────┘

段基址 = Base 31:24 | Base 23:16 | Base 15:0
       = 0x00 | 0x00 | 0x0000
       = 0x00000000  ← 基址为 0！

段限长 = (Limit 19:16 | Limit 15:0) × 粒度
       = 0xFFFFF × 4KB (因为 G=1)
       = 4GB
```

#### 为什么基址是 0？（平坦内存模型）

这个 OS 使用 **平坦内存模型 (Flat Memory Model)**：

```
┌─────────────────────────────────────────────────────┐
│  传统分段模型                平坦模型               │
│                                                     │
│  逻辑地址 = 段:偏移          逻辑地址 = 偏移        │
│  线性地址 = 基址 + 偏移      线性地址 = 0 + 偏移    │
│                                      = 偏移        │
│                                                     │
│  基址各不相同                所有段基址 = 0         │
│  段限长受限                  段限长 = 4GB           │
└─────────────────────────────────────────────────────┘
```

**结论**：所有段的基址都设为 0，限长都是 4GB，实际上**让分页成为唯一的内存保护方式**。

#### 信息存储位置总结

| 信息 | 存储位置 | 字段 |
|------|----------|------|
| **偏移量**（处理函数地址） | IDT 表项 | `offset_31_16` + `offset_15_00` |
| **段选择子** | IDT 表项 | `seg_selector` |
| **段基址** | GDT 表项 | Base 字段（拆成3部分） |
| **段限长** | GDT 表项 | Limit 字段（拆成2部分） |

### Q2: 为什么 size = 1？

**答**：表示 32 位门。

- size = 1：32 位门，处理函数地址是 32 位
- size = 0：16 位门，实模式遗留，现代系统不用

### Q3: 为什么默认 dpl = 0？

**答**：防止用户程序通过 INT n 伪造中断/异常。

DPL=0 意味着只有 Ring 0 代码能用软件触发这个中断。但硬件触发（如真正的页错误）会忽略 DPL 检查。

### Q4: 为什么异常用陷阱门？

**答**：异常处理可能耗时，需要允许响应紧急中断。

例如：页错误处理需要从磁盘加载数据，可能需要毫秒级时间。如果关中断，定时器、键盘都无法响应，系统会卡死。

### Q5: 为什么系统调用用陷阱门？

**答**：系统调用可能阻塞，需要允许中断。

例如：`read()` 可能等待用户输入，如果关中断，键盘中断无法响应，永远读不到数据。

### Q6: 为什么系统调用 DPL=3？

**答**：允许用户程序调用。

用户程序在 Ring 3 执行，如果 DPL=0，执行 INT 0x80 会因为 CPL(3) > DPL(0) 触发 #GP 错误。设置 DPL=3 后，用户程序可以正常调用系统服务。

---

## 9. SET_IDT_ENTRY 宏解析

```c
#define SET_IDT_ENTRY(str, handler)                              \
do {                                                             \
    str.offset_31_16 = ((uint32_t)(handler) & 0xFFFF0000) >> 16; \
    str.offset_15_00 = ((uint32_t)(handler) & 0xFFFF);           \
} while (0)
```

**作用**：将 32 位处理函数地址拆分存入 IDT 表项。

**例子**：假设 `EXCEPTION_0` 地址是 `0x00401234`

```
handler = 0x00401234

offset_31_16 = (0x00401234 & 0xFFFF0000) >> 16
             = 0x00400000 >> 16
             = 0x0040

offset_15_00 = 0x00401234 & 0xFFFF
             = 0x1234

IDT 表项中：
  offset_31_16 = 0x0040 (高16位)
  offset_15_00 = 0x1234 (低16位)

还原地址 = (0x0040 << 16) | 0x1234 = 0x00401234 ✓
```

**为什么地址要拆开存？**：这是 x86 的历史设计，IDT 表项格式从 286 保护模式沿用至今。

---

## 10. 完整流程图

```
系统启动
    │
    ▼
kernel.c: entry()
    │
    ▼
initialize_IDT()
    │
    ├─► 1. 初始化 256 个表项的公共字段
    │       - seg_selector = KERNEL_CS
    │       - size = 1 (32位门)
    │       - present = 1
    │       - dpl = 0 (默认)
    │       - reserved3 = 0 (默认中断门)
    │
    ├─► 2. 异常 (0-31) 改为陷阱门
    │       - reserved3 = 1
    │
    ├─► 3. 系统调用 (0x80) 特殊设置
    │       - reserved3 = 1 (陷阱门)
    │       - dpl = 3 (用户可调用)
    │
    ├─► 4. set_exceptions()
    │       - 填入 EXCEPTION_0 ~ EXCEPTION_19 的地址
    │
    ├─► 5. set_interrupts()
    │       - 填入 PIT_handler, KB_handler, RTC_handler 地址
    │
    └─► 6. SET_IDT_ENTRY(idt[0x80], syscall)
            - 填入系统调用处理函数地址

    （lidt 在 x86_desc.S 中已执行，加载 IDT 到 IDTR）
```

---

## 11. 调试技巧

### 使用 GDB 查看 IDT

```bash
# 启动 QEMU 调试模式
qemu-system-i386 -s -S -hda mp3.img -m 64

# 另一个终端
gdb
(gdb) target remote localhost:1234
(gdb) symbol-file student-distrib/kernel

# 查看 IDT 表项
(gdb) print idt[0]              # 除零异常
(gdb) print idt[14]             # 页错误
(gdb) print idt[0x80]           # 系统调用
(gdb) print idt[33]             # 键盘中断

# 查看具体字段
(gdb) print idt[0].seg_selector
(gdb) print idt[0].dpl
(gdb) print idt[0].reserved3    # 0=中断门, 1=陷阱门

# 查看整个 IDT 数组
(gdb) x/16x &idt                # 前 16 字节（2个表项）
```

---

## 12. 总结

| 概念               | 要点                              |
|------------------|---------------------------------|
| **IDT**          | 256 个表项，每个 8 字节，告诉 CPU 中断处理函数地址 |
| **中断门**          | reserved3=0，进入时关中断，用于硬件中断       |
| **陷阱门**          | reserved3=1，进入时不关中断，用于异常和系统调用   |
| **DPL**          | 决定谁能用 INT n 触发，0=仅内核，3=用户也可以    |
| **seg_selector** | 指向内核代码段 (KERNEL_CS = 0x0010)    |
| **offset**       | 处理函数地址，分高16位和低16位存储             |

---

**文档版本**：1.0
**最后更新**：2025-12-07
**相关文件**：

- `student-distrib/idt_init.c`
- `student-distrib/x86_desc.h`
- `student-distrib/interrupt_handler.S`
- `student-distrib/exception_handler.c`
