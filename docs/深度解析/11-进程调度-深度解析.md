# 进程调度深度解析

## 概述

进程调度负责在多个运行中的进程之间分配 CPU 时间。本系统使用**基于 PIT (Programmable Interval Timer) 的轮转调度**
，在三个终端的进程之间进行切换。

---

## PIT (可编程间隔定时器)

### 硬件概述

PIT (8253/8254 芯片) 是一个硬件定时器，可以产生周期性中断：

```
┌─────────────────────────────────────────────────────┐
│                    PIT 8253/8254                     │
│  ┌─────────────┐                                    │
│  │  Channel 0  │──── IRQ 0 ──── PIC ──── CPU       │
│  │  (定时器)    │                                    │
│  └─────────────┘                                    │
│  ┌─────────────┐                                    │
│  │  Channel 1  │ (DRAM 刷新，不使用)                 │
│  └─────────────┘                                    │
│  ┌─────────────┐                                    │
│  │  Channel 2  │ (PC 扬声器，不使用)                 │
│  └─────────────┘                                    │
└─────────────────────────────────────────────────────┘
```

### I/O 端口

| 端口   | 名称         | 功能           |
|------|------------|--------------|
| 0x40 | DATA_PORT0 | Channel 0 数据 |
| 0x43 | CMD_PORT   | 命令/模式寄存器     |

### PIT 初始化

```c
#define PIT_MAX_FREQ 1193180   // PIT 基础频率 (Hz)
#define PIT_FREQ     11932     // 分频值 → 约 100 Hz
#define CMD_REG_VAL  0x36      // 模式 3，方波发生器

void pit_init() {
    // 1. 设置命令寄存器
    outb(CMD_REG_VAL, CMD_PORT);

    // 2. 设置分频值 (低字节 + 高字节)
    outb(PIT_FREQ & 0xFF, DATA_PORT0);      // 低 8 位
    outb(PIT_FREQ >> 8, DATA_PORT0);        // 高 8 位

    // 3. 启用 IRQ 0
    enable_irq(PIT_IRQ_NUM);
}
```

**频率计算**：

```
输出频率 = 基础频率 / 分频值
        = 1193180 / 11932
        ≈ 100 Hz

即每 10ms 产生一次中断
```

### CMD_REG_VAL (0x36) 解析

```
0x36 = 0011 0110

位 7-6: 00 = 选择 Channel 0
位 5-4: 11 = 先写低字节，再写高字节
位 3-1: 011 = 模式 3 (方波发生器)
位 0:   0 = 二进制计数
```

---

## 调度机制

### 核心概念

| 变量           | 含义         | 示例               |
|--------------|------------|------------------|
| curr_term    | 当前显示的终端    | 用户看到终端 1         |
| running_term | 当前执行的终端    | CPU 正在执行终端 2 的进程 |
| next_term    | 下一个要执行的终端  | 即将切换到终端 0        |
| cur_pid      | 当前执行的进程 ID | read/write 使用    |

### 调度流程

```
                    PIT 中断 (每 10ms)
                           │
                           ▼
              pit_interrupt_handler()
                           │
                           ├── send_eoi(0)
                           │
                           ├── 检查是否有多个终端在运行
                           │   if (term[1].running_pid != -1 ||
                           │       term[2].running_pid != -1)
                           │
                           ├── get_next_process()
                           │   └── 轮转查找下一个活动终端
                           │
                           └── schedule(next_process)
                                   │
                                   ▼
                           ┌───────────────────┐
                           │ 1. 视频内存重映射    │
                           │ 2. 保存当前进程状态  │
                           │ 3. 恢复下一进程状态  │
                           │ 4. 切换页表         │
                           │ 5. 恢复 TSS        │
                           │ 6. 切换栈并返回     │
                           └───────────────────┘
```

### 获取下一个进程

```c
uint32_t get_next_process() {
    int i;
    next_term = running_term;

    // 轮转搜索下一个有运行进程的终端
    for (i = 0; i < NUM_TERMS; i++) {
        next_term = (next_term + 1) % NUM_TERMS;
        if (term[next_term].running_pid != -1) {
            break;
        }
    }

    return term[next_term].running_pid;
}
```

**轮转示例**：

```
当前状态:
  终端 0: shell (pid=0) ← running_term
  终端 1: cat (pid=1)
  终端 2: -1 (空)

调用 get_next_process():
  next_term = (0 + 1) % 3 = 1
  term[1].running_pid = 1 ≠ -1 → 找到！
  返回 1

下次调用:
  next_term = (1 + 1) % 3 = 2
  term[2].running_pid = -1 → 跳过
  next_term = (2 + 1) % 3 = 0
  term[0].running_pid = 0 ≠ -1 → 找到！
  返回 0
```

---

## schedule 函数详解

```c
void schedule(uint32_t process) {
    // 1. 视频内存映射
    uint8_t* screen_start;
    vidmap(&screen_start);  // 映射 132MB → 显存

    term_info new_terminal = term[next_term];

    // 如果不是当前显示的终端，重映射到备份区
    if (new_terminal.term_id != curr_term) {
        remap_vid((int32_t)screen_start, (int32_t)new_terminal.vid_backup);
    }

    // 2. 保存当前进程的 TSS 信息
    term[running_term].esp0 = tss.esp0;
    term[running_term].ss0 = tss.ss0;

    // 3. 获取当前和下一个 PCB
    pcb_t* curr_pcb = get_specific_pcb((uint8_t)term[running_term].running_pid);
    pcb_t* new_pcb = get_specific_pcb((uint8_t)process);

    // 4. 保存当前进程的 ESP/EBP
    asm volatile(
        "movl %%esp, %%eax;"
        "movl %%ebp, %%ebx;"
        : "=a"(curr_pcb->curr_esp), "=b"(curr_pcb->curr_ebp)
    );

    // 5. 更新 running_term
    running_term = next_term;

    // 6. 切换页表
    remap(_128MB, _8MB + process * _4MB);

    // 7. 恢复 TSS
    tss.ss0 = new_terminal.ss0;
    tss.esp0 = new_terminal.esp0;

    // 8. 更新当前 PID
    cur_pid = process;

    // 9. 恢复下一进程的 ESP/EBP 并切换
    asm volatile(
        "movl %%eax, %%esp;"
        "movl %%ebx, %%ebp;"
        "leave;"
        "ret;"
        :
        : "a"(new_pcb->curr_esp), "b"(new_pcb->curr_ebp)
    );
}
```

### 上下文切换图解

```
进程 A 正在运行                    进程 B 等待调度
     │                                │
     │   PIT 中断                      │
     ▼                                │
┌──────────────┐                      │
│ 保存 A 的状态  │                      │
│ curr_esp     │                      │
│ curr_ebp     │                      │
└──────────────┘                      │
     │                                │
     │   切换页表                       │
     │   更新 TSS                      │
     │                                │
     ▼                                ▼
┌──────────────┐               ┌──────────────┐
│ 恢复 B 的状态  │               │ 继续执行      │
│ curr_esp     │──────────────▶│              │
│ curr_ebp     │               │              │
└──────────────┘               └──────────────┘
```

### 为什么使用 leave; ret; ？

```c
asm volatile(
    "movl %%eax, %%esp;"   // ESP = new_pcb->curr_esp
    "movl %%ebx, %%ebp;"   // EBP = new_pcb->curr_ebp
    "leave;"               // ESP = EBP; pop EBP
    "ret;"                 // pop EIP, 跳转执行
);
```

**原因**：当进程 B 之前被中断时，它正在某个函数中执行。保存的 `curr_esp/curr_ebp` 指向那个时刻的栈。通过恢复这些寄存器并执行
`leave; ret;`，我们模拟了从那个函数正常返回的行为，从而回到进程 B 被中断的位置继续执行。

---

## 多终端调度示例

### 场景设置

```
终端 0: 运行 shell，用户在输入命令
终端 1: 运行 cat，正在读取文件
终端 2: 运行 fish，正在显示动画
当前显示: 终端 0 (curr_term = 0)
```

### 调度时间线

```
时间    running_term   curr_term   操作
────────────────────────────────────────────────────────
T0      0             0           终端0的shell在运行
                                  用户看到终端0
T1      0             0           PIT中断
        │                         schedule(1)
        ▼
T2      1             0           终端1的cat在运行
                                  用户看到终端0
                                  cat输出到备份区
T3      1             0           PIT中断
        │                         schedule(2)
        ▼
T4      2             0           终端2的fish在运行
                                  用户看到终端0
                                  fish动画写到备份区
T5      2             0           PIT中断
        │                         schedule(0)
        ▼
T6      0             0           回到终端0的shell
                                  用户看到终端0
```

### 用户切换终端

```
时间    running_term   curr_term   操作
────────────────────────────────────────────────────────
T6      0             0           用户按 Alt+F2
                                  launch_term(1)
                                  switch_terminal(0,1)
T7      0             1           curr_term 变为 1
                                  用户看到终端1
                                  终端0内容已备份
T8      1             1           PIT中断
                                  running_term轮转
                                  cat继续运行
                                  输出直接到显存
```

---

## 视频内存管理

### 问题

当 `running_term ≠ curr_term` 时，非当前显示终端的输出不应直接写入显存，否则会覆盖当前显示的内容。

### 解决方案

```c
// schedule 中
if (new_terminal.term_id != curr_term) {
    // 将 vidmap 的虚拟地址重新映射到备份区
    remap_vid((int32_t)screen_start, (int32_t)new_terminal.vid_backup);
}
```

### 内存映射示意

```
curr_term = 0, running_term = 1

终端 1 的进程调用 vidmap():
  虚拟地址 132MB → 物理地址 term[1].vid_backup (0xBA000)

终端 0 的进程调用 vidmap():
  虚拟地址 132MB → 物理地址 VIDEO (0xB8000)

结果:
  - 终端 0 的输出直接显示在屏幕上
  - 终端 1 的输出写入备份区，用户看不到
  - 当用户切换到终端 1 时，备份区内容会恢复到显存
```

---

## TSS 在调度中的作用

### TSS 结构中的关键字段

```c
typedef struct tss_t {
    // ...
    uint16_t ss0;     // 内核栈段选择子
    uint32_t esp0;    // 内核栈顶
    // ...
} tss_t;
```

### 为什么需要更新 TSS？

当用户程序发生中断/异常时，CPU 会：

1. 从 TSS 获取 SS0:ESP0
2. 切换到内核栈
3. 压入用户态寄存器

每个进程有自己的内核栈，所以切换进程时必须更新 TSS，确保中断时使用正确的内核栈。

```c
// schedule 中
tss.ss0 = new_terminal.ss0;        // 通常是 KERNEL_DS
tss.esp0 = new_terminal.esp0;      // 进程的内核栈顶
```

### 内核栈布局

```
进程 0 内核栈:                进程 1 内核栈:
┌─────────────┐ 8MB-4       ┌─────────────┐ 8MB-8KB-4
│  中断帧      │ ← tss.esp0  │  中断帧      │ ← tss.esp0
│  (当进程0    │             │  (当进程1    │
│   在运行时)  │             │   在运行时)  │
├─────────────┤             ├─────────────┤
│  调用栈      │             │  调用栈      │
├─────────────┤             ├─────────────┤
│   PCB 0     │             │   PCB 1     │
└─────────────┘ 8MB-8KB     └─────────────┘ 8MB-16KB
```

---

## 调度的触发条件

### 1. PIT 中断 (时间片轮转)

```c
void pit_interrupt_handler() {
    send_eoi(PIT_IRQ_NUM);
    cli();

    // 只有多个终端在运行时才需要调度
    if (term[1].running_pid != -1 || term[2].running_pid != -1) {
        next_process = get_next_process();
        schedule(next_process);
    }

    sti();
}
```

### 2. 终端切换 (launch_term)

当用户按 Alt+F1/F2/F3 切换终端时，如果目标终端没有运行进程，会启动新 shell：

```c
int32_t launch_term(uint32_t term_id) {
    // ...
    if (term[term_id].running_pid == -1) {
        // 第一次启动，创建新 shell
        execute((uint8_t*)"shell");
    }
    // ...
}
```

---

## 调度相关数据结构

### term_info 中的调度字段

```c
typedef struct {
    uint32_t term_id;        // 终端 ID
    int32_t running_pid;     // 该终端的运行进程 (-1 表示无)

    uint16_t ss0;            // 该终端进程的内核栈段
    uint32_t esp0;           // 该终端进程的内核栈顶

    uint8_t* vid_backup;     // 显存备份地址
    // ...
} term_info;

term_info term[3];  // 三个终端
```

### PCB 中的调度字段

```c
typedef struct pcb {
    // ...
    uint32_t curr_esp;       // 调度时保存的 ESP
    uint32_t curr_ebp;       // 调度时保存的 EBP

    uint32_t esp;            // execute 时保存的 ESP (用于 halt)
    uint32_t ebp;            // execute 时保存的 EBP (用于 halt)
    // ...
} pcb_t;
```

**区别**：

- `esp/ebp`: 在 execute 时保存，用于 halt 返回
- `curr_esp/curr_ebp`: 在 schedule 时保存，用于调度切换

---

## 总结

| 概念           | 说明                        |
|--------------|---------------------------|
| PIT          | 100Hz 定时器，每 10ms 产生中断触发调度 |
| 轮转调度         | 按终端 0→1→2→0 顺序轮转          |
| 上下文切换        | 保存/恢复 ESP、EBP、TSS、页表      |
| 视频内存隔离       | 非当前终端的输出重定向到备份区           |
| running_term | CPU 当前执行的终端               |
| curr_term    | 用户当前看到的终端                 |

调度的核心流程：

```
PIT中断 → get_next_process() → schedule()
                                    │
                                    ├── 保存当前进程状态
                                    ├── 切换页表
                                    ├── 更新 TSS
                                    ├── 恢复下一进程状态
                                    └── leave; ret; 继续执行
```
