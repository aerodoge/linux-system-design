# 测试用例编写指南

## 概述

系统级测试与普通程序测试不同：
- 没有标准测试框架
- 错误可能导致系统崩溃
- 需要手动验证结果
- 测试顺序很重要

本指南帮助你系统地测试 MP3 的每个模块。

## 测试框架

### 基本测试结构

```c
// tests.c

#include "tests.h"
#include "lib.h"

// 测试计数器
static int tests_run = 0;
static int tests_passed = 0;

// 测试宏
#define TEST(name) void test_##name()

#define ASSERT(condition) do { \
    if (!(condition)) { \
        printf("[FAIL] %s:%d: %s\n", __FILE__, __LINE__, #condition); \
        return; \
    } \
} while(0)

#define ASSERT_EQ(expected, actual) do { \
    if ((expected) != (actual)) { \
        printf("[FAIL] Expected %d, got %d\n", (expected), (actual)); \
        return; \
    } \
} while(0)

#define RUN_TEST(name) do { \
    printf("Running test_%s... ", #name); \
    tests_run++; \
    test_##name(); \
    tests_passed++; \
    printf("[PASS]\n"); \
} while(0)

// 测试入口
void run_tests() {
    printf("========== Running Tests ==========\n");

    // 在这里添加测试
    // RUN_TEST(idt_init);
    // RUN_TEST(paging);
    // ...

    printf("===================================\n");
    printf("Tests: %d/%d passed\n", tests_passed, tests_run);
}
```

### 调用测试

```c
// kernel.c
void entry(...) {
    // 初始化...

    #ifdef RUN_TESTS
    run_tests();
    #endif

    // 正常启动...
}
```

---

## Checkpoint 1 测试

### IDT 测试

```c
/* 测试 1: IDT 是否正确加载 */
TEST(idt_loaded) {
    // 检查 IDTR 是否指向正确地址
    struct {
        uint16_t limit;
        uint32_t base;
    } __attribute__((packed)) idtr;

    asm volatile("sidt %0" : "=m"(idtr));

    // 256 个入口 * 8 字节 - 1
    ASSERT_EQ(256 * 8 - 1, idtr.limit);
    ASSERT(idtr.base != 0);

    printf("IDT base: 0x%x, limit: %d\n", idtr.base, idtr.limit);
}

/* 测试 2: 除零异常 */
TEST(divide_by_zero) {
    printf("Testing divide by zero (should print exception)...\n");

    // 这会触发除零异常
    // 异常处理应该打印消息并停止，而不是崩溃
    volatile int x = 1;
    volatile int y = 0;
    volatile int z = x / y;  // 触发异常

    // 如果到达这里，测试失败（异常处理有问题）
    printf("[FAIL] Should have triggered exception!\n");
}

/* 测试 3: 系统调用入口 */
TEST(syscall_entry) {
    // 测试 int 0x80 是否正确设置
    // 简单调用一个系统调用，检查是否正常返回

    int result;
    asm volatile(
        "movl $0, %%eax\n"  // 无效的系统调用号
        "int $0x80\n"
        "movl %%eax, %0\n"
        : "=r"(result)
        :
        : "eax"
    );

    // 应该返回 -1（无效系统调用）
    ASSERT_EQ(-1, result);
}
```

### 分页测试

```c
/* 测试 1: 分页是否启用 */
TEST(paging_enabled) {
    uint32_t cr0;
    asm volatile("movl %%cr0, %0" : "=r"(cr0));

    // 检查 PG 位 (bit 31)
    ASSERT(cr0 & 0x80000000);
    printf("CR0 = 0x%x (PG bit set)\n", cr0);
}

/* 测试 2: 内核空间可访问 */
TEST(kernel_memory_accessible) {
    // 测试内核代码区
    volatile uint32_t* kernel_code = (uint32_t*)0x400000;
    volatile uint32_t value = *kernel_code;  // 应该不会崩溃

    // 测试内核数据区
    volatile uint32_t* kernel_data = (uint32_t*)0x500000;
    value = *kernel_data;  // 应该不会崩溃

    printf("Kernel memory accessible\n");
}

/* 测试 3: 显存可访问 */
TEST(video_memory_accessible) {
    volatile char* video = (char*)0xB8000;

    // 保存原值
    char original = video[0];

    // 写入测试值
    video[0] = 'T';
    ASSERT_EQ('T', video[0]);

    // 恢复
    video[0] = original;

    printf("Video memory accessible\n");
}

/* 测试 4: 空指针解引用（应该触发页错误） */
TEST(null_pointer_fault) {
    printf("Testing NULL pointer (should page fault)...\n");

    volatile int* null_ptr = NULL;
    volatile int value = *null_ptr;  // 应该触发页错误

    printf("[FAIL] Should have page faulted!\n");
}

/* 测试 5: 无效地址访问 */
TEST(invalid_address_fault) {
    printf("Testing invalid address (should page fault)...\n");

    // 未映射的地址
    volatile int* bad_addr = (int*)0x10000000;
    volatile int value = *bad_addr;  // 应该触发页错误

    printf("[FAIL] Should have page faulted!\n");
}
```

### PIC 测试

```c
/* 测试 1: 键盘中断 */
TEST(keyboard_interrupt) {
    printf("Press any key within 5 seconds...\n");

    volatile int key_pressed = 0;
    extern volatile int keyboard_interrupt_count;

    int start_count = keyboard_interrupt_count;

    // 等待键盘中断
    int timeout = 5000000;
    while (timeout-- > 0 && keyboard_interrupt_count == start_count) {
        // 忙等待
    }

    if (keyboard_interrupt_count > start_count) {
        printf("Keyboard interrupt received!\n");
    } else {
        printf("[FAIL] No keyboard interrupt received\n");
    }
}

/* 测试 2: RTC 中断 */
TEST(rtc_interrupt) {
    printf("Testing RTC interrupt...\n");

    extern volatile int rtc_interrupt_count;

    int start_count = rtc_interrupt_count;

    // 等待几个 RTC 中断
    int timeout = 1000000;
    while (timeout-- > 0 && rtc_interrupt_count < start_count + 5) {
        // 忙等待
    }

    printf("RTC interrupts: %d\n", rtc_interrupt_count - start_count);
    ASSERT(rtc_interrupt_count > start_count);
}
```

---

## Checkpoint 2 测试

### 终端测试

```c
/* 测试 1: terminal_write */
TEST(terminal_write_basic) {
    const char* test_str = "Hello, Terminal!";
    int len = strlen(test_str);

    int written = terminal_write(1, test_str, len);

    ASSERT_EQ(len, written);
}

/* 测试 2: terminal_write 空字符串 */
TEST(terminal_write_empty) {
    int written = terminal_write(1, "", 0);
    ASSERT_EQ(0, written);
}

/* 测试 3: terminal_write NULL 缓冲区 */
TEST(terminal_write_null) {
    int written = terminal_write(1, NULL, 10);
    ASSERT_EQ(-1, written);
}

/* 测试 4: terminal_read (需要用户交互) */
TEST(terminal_read_interactive) {
    printf("Type something and press Enter: ");

    char buf[128];
    int n = terminal_read(0, buf, 128);

    printf("Read %d bytes: ", n);
    terminal_write(1, buf, n);

    ASSERT(n > 0);
}

/* 测试 5: 滚屏 */
TEST(terminal_scroll) {
    printf("Testing scroll...\n");

    // 打印足够多行触发滚屏
    int i;
    for (i = 0; i < 30; i++) {
        printf("Line %d\n", i);
    }

    printf("Scroll test done (check screen)\n");
}
```

### RTC 测试

```c
/* 测试 1: rtc_open */
TEST(rtc_open) {
    int result = rtc_open(NULL);
    ASSERT_EQ(0, result);
}

/* 测试 2: rtc_read (阻塞测试) */
TEST(rtc_read_blocks) {
    rtc_open(NULL);

    printf("Testing RTC read (should block until interrupt)...\n");

    int buf;
    int start_time = get_tick_count();  // 如果有时钟计数
    int result = rtc_read(0, &buf, 4);
    int end_time = get_tick_count();

    printf("RTC read returned after %d ticks\n", end_time - start_time);
    ASSERT_EQ(0, result);
}

/* 测试 3: rtc_write 频率设置 */
TEST(rtc_write_frequency) {
    rtc_open(NULL);

    // 测试有效频率
    int freqs[] = {2, 4, 8, 16, 32, 64, 128, 256, 512, 1024};
    int i;
    for (i = 0; i < 10; i++) {
        int result = rtc_write(0, &freqs[i], 4);
        ASSERT_EQ(0, result);
        printf("Set frequency to %d Hz\n", freqs[i]);
    }

    // 测试无效频率
    int bad_freq = 100;  // 不是 2 的幂
    int result = rtc_write(0, &bad_freq, 4);
    ASSERT_EQ(-1, result);
}

/* 测试 4: RTC 频率验证 */
TEST(rtc_frequency_verify) {
    rtc_open(NULL);

    int freq = 32;
    rtc_write(0, &freq, 4);

    printf("Counting RTC interrupts at %d Hz for ~1 second...\n", freq);

    // 计数 1 秒内的中断
    int count = 0;
    int timeout = 10000000;  // 大约 1 秒
    int buf;

    while (count < freq && timeout-- > 0) {
        rtc_read(0, &buf, 4);
        count++;
    }

    printf("Received %d interrupts (expected %d)\n", count, freq);
    // 允许一些误差
    ASSERT(count >= freq - 2 && count <= freq + 2);
}
```

### 文件系统测试

```c
/* 测试 1: read_dentry_by_name */
TEST(fs_read_dentry_by_name) {
    dentry_t dentry;

    // 测试存在的文件
    int result = read_dentry_by_name("shell", &dentry);
    ASSERT_EQ(0, result);
    ASSERT_EQ(2, dentry.file_type);  // 普通文件

    // 测试不存在的文件
    result = read_dentry_by_name("nonexistent", &dentry);
    ASSERT_EQ(-1, result);
}

/* 测试 2: read_dentry_by_index */
TEST(fs_read_dentry_by_index) {
    dentry_t dentry;

    // 测试索引 0 (.)
    int result = read_dentry_by_index(0, &dentry);
    ASSERT_EQ(0, result);

    printf("Entry 0: %s (type=%d)\n", dentry.name, dentry.file_type);
}

/* 测试 3: read_data */
TEST(fs_read_data) {
    dentry_t dentry;
    read_dentry_by_name("frame0.txt", &dentry);

    uint8_t buf[100];
    int n = read_data(dentry.inode, 0, buf, 100);

    ASSERT(n > 0);
    printf("Read %d bytes from frame0.txt\n", n);

    // 打印内容
    buf[n] = '\0';
    printf("Content: %s\n", buf);
}

/* 测试 4: 读取可执行文件头 */
TEST(fs_read_executable) {
    dentry_t dentry;
    read_dentry_by_name("shell", &dentry);

    uint8_t buf[4];
    read_data(dentry.inode, 0, buf, 4);

    // 检查 ELF 魔数
    ASSERT_EQ(0x7F, buf[0]);
    ASSERT_EQ('E', buf[1]);
    ASSERT_EQ('L', buf[2]);
    ASSERT_EQ('F', buf[3]);

    printf("shell is a valid ELF file\n");
}

/* 测试 5: 目录读取 */
TEST(fs_directory_read) {
    printf("Listing all files:\n");

    dentry_t dentry;
    int i = 0;
    while (read_dentry_by_index(i, &dentry) == 0) {
        printf("  %d: %s (type=%d, inode=%d)\n",
               i, dentry.name, dentry.file_type, dentry.inode);
        i++;
    }

    printf("Total: %d entries\n", i);
    ASSERT(i > 0);
}

/* 测试 6: 大文件读取 */
TEST(fs_large_file) {
    dentry_t dentry;
    read_dentry_by_name("verylargetextwithverylongname.txt", &dentry);

    // 获取文件大小
    inode_t* inode = get_inode(dentry.inode);
    printf("File size: %d bytes\n", inode->length);

    // 读取整个文件
    uint8_t* buf = (uint8_t*)malloc(inode->length + 1);
    int n = read_data(dentry.inode, 0, buf, inode->length);

    ASSERT_EQ(inode->length, n);
    printf("Successfully read %d bytes\n", n);

    free(buf);
}
```

---

## Checkpoint 3 测试

### 系统调用测试

```c
/* 测试 1: open/close */
TEST(syscall_open_close) {
    // 打开文件
    int fd = open("frame0.txt");
    ASSERT(fd >= 2 && fd <= 7);  // fd 0,1 是 stdin/stdout
    printf("Opened frame0.txt, fd = %d\n", fd);

    // 关闭文件
    int result = close(fd);
    ASSERT_EQ(0, result);

    // 再次关闭应该失败
    result = close(fd);
    ASSERT_EQ(-1, result);
}

/* 测试 2: read 文件 */
TEST(syscall_read_file) {
    int fd = open("frame0.txt");
    ASSERT(fd >= 2);

    char buf[100];
    int n = read(fd, buf, 100);
    ASSERT(n > 0);

    buf[n] = '\0';
    printf("Read from file: %s\n", buf);

    close(fd);
}

/* 测试 3: write (只能写终端) */
TEST(syscall_write) {
    // 写入 stdout
    char* msg = "Hello from syscall!\n";
    int n = write(1, msg, strlen(msg));
    ASSERT_EQ(strlen(msg), n);

    // 尝试写入文件（应该失败，文件系统是只读的）
    int fd = open("frame0.txt");
    n = write(fd, "test", 4);
    ASSERT_EQ(-1, n);  // 应该失败
    close(fd);
}

/* 测试 4: 文件描述符限制 */
TEST(syscall_fd_limit) {
    int fds[8];
    int i;

    // 打开最多的文件 (fd 0,1 已被 stdin/stdout 占用)
    for (i = 0; i < 6; i++) {
        fds[i] = open("frame0.txt");
        printf("Opened fd %d\n", fds[i]);
        ASSERT(fds[i] >= 2);
    }

    // 再打开应该失败
    int fd = open("frame0.txt");
    ASSERT_EQ(-1, fd);
    printf("Correctly rejected 7th file open\n");

    // 关闭所有
    for (i = 0; i < 6; i++) {
        close(fds[i]);
    }
}

/* 测试 5: getargs */
TEST(syscall_getargs) {
    // 这需要在用户程序中测试
    // 从 shell 运行: testprogram arg1 arg2

    char buf[128];
    int result = getargs(buf, 128);

    if (result == 0) {
        printf("Args: %s\n", buf);
    } else {
        printf("No args\n");
    }
}
```

### execute/halt 测试

```c
/* 测试 1: execute 有效程序 */
TEST(execute_valid) {
    printf("Executing 'ls'...\n");
    int result = execute("ls");
    printf("ls returned %d\n", result);
    ASSERT_EQ(0, result);
}

/* 测试 2: execute 无效程序 */
TEST(execute_invalid) {
    printf("Executing nonexistent program...\n");
    int result = execute("nonexistent");
    ASSERT_EQ(-1, result);
}

/* 测试 3: execute 带参数 */
TEST(execute_with_args) {
    printf("Executing 'cat frame0.txt'...\n");
    int result = execute("cat frame0.txt");
    printf("cat returned %d\n", result);
}

/* 测试 4: halt 返回值 */
TEST(halt_return_value) {
    // 这需要专门的测试程序
    // test_halt.c:
    // int main() { return 42; }

    int result = execute("test_halt");
    ASSERT_EQ(42, result);
}

/* 测试 5: execute 嵌套 */
TEST(execute_nested) {
    // shell -> program1 -> program2 -> halt -> program1 -> halt -> shell
    // 需要手动测试
    printf("Test nested execute manually:\n");
    printf("  From shell, run a program that runs another program\n");
}
```

---

## Checkpoint 4 测试

### 多终端测试

```c
/* 测试 1: 终端切换 */
TEST(terminal_switch) {
    printf("Press Alt+F1, Alt+F2, Alt+F3 to test switching\n");
    printf("Each terminal should maintain its own content\n");

    // 手动测试
}

/* 测试 2: 终端隔离 */
TEST(terminal_isolation) {
    printf("Test terminal isolation:\n");
    printf("1. In terminal 0, type some text\n");
    printf("2. Switch to terminal 1\n");
    printf("3. Terminal 1 should not show terminal 0's text\n");
    printf("4. Switch back to terminal 0\n");
    printf("5. Text should be preserved\n");
}

/* 测试 3: 多终端 shell */
TEST(multi_terminal_shell) {
    printf("Test multiple shells:\n");
    printf("1. Terminal 0 should have shell\n");
    printf("2. Switch to terminal 1, should have its own shell\n");
    printf("3. Run a program in terminal 0\n");
    printf("4. Terminal 1 should not be affected\n");
}
```

---

## Checkpoint 5 测试

### 调度测试

```c
/* 测试 1: 基本调度 */
TEST(scheduler_basic) {
    printf("Test basic scheduling:\n");
    printf("1. Run 'counter' in terminal 0\n");
    printf("2. Run 'counter' in terminal 1\n");
    printf("3. Both should run concurrently\n");
}

/* 测试 2: 调度公平性 */
TEST(scheduler_fairness) {
    printf("Test scheduler fairness:\n");
    printf("1. Run 'pingpong' in all 3 terminals\n");
    printf("2. All should make progress\n");
}

/* 测试 3: fish 测试 */
TEST(fish) {
    printf("Running fish...\n");
    int result = execute("fish");
    printf("fish returned %d\n", result);
}
```

---

## 用户程序测试

### 创建测试程序

```c
// test_hello.c - 最简单的测试
#include "syscall.h"

int main() {
    write(1, "Hello, World!\n", 14);
    return 0;
}

// test_args.c - 测试 getargs
#include "syscall.h"

int main() {
    char buf[128];
    if (getargs(buf, 128) == 0) {
        write(1, "Args: ", 6);
        write(1, buf, strlen(buf));
        write(1, "\n", 1);
    } else {
        write(1, "No args\n", 8);
    }
    return 0;
}

// test_file.c - 测试文件操作
#include "syscall.h"

int main() {
    int fd = open("frame0.txt");
    if (fd < 0) {
        write(1, "Open failed\n", 12);
        return 1;
    }

    char buf[100];
    int n = read(fd, buf, 100);
    write(1, buf, n);

    close(fd);
    return 0;
}

// test_rtc.c - 测试 RTC
#include "syscall.h"

int main() {
    int fd = open("rtc");
    int freq = 32;
    write(fd, &freq, 4);

    int i;
    int buf;
    for (i = 0; i < 10; i++) {
        read(fd, &buf, 4);
        write(1, "tick\n", 5);
    }

    close(fd);
    return 0;
}

// test_vidmap.c - 测试 vidmap
#include "syscall.h"

int main() {
    uint8_t* video;
    if (vidmap(&video) != 0) {
        write(1, "vidmap failed\n", 14);
        return 1;
    }

    // 在左上角写入 'V'
    video[0] = 'V';
    video[1] = 0x0A;  // 绿色

    return 0;
}
```

### 压力测试

```c
// stress_open.c - 文件打开压力测试
int main() {
    int i;
    for (i = 0; i < 100; i++) {
        int fd = open("frame0.txt");
        if (fd < 0) {
            // 期望在某个点失败
        } else {
            close(fd);
        }
    }
    return 0;
}

// stress_execute.c - execute 压力测试
int main() {
    int i;
    for (i = 0; i < 10; i++) {
        execute("hello");
    }
    return 0;
}

// infinite_loop.c - 无限循环（测试调度）
int main() {
    while (1) {
        // 占用 CPU
    }
    return 0;
}
```

---

## 测试检查清单

### Checkpoint 1
- [ ] IDT 正确加载
- [ ] 除零异常正确处理
- [ ] 页错误正确处理
- [ ] 分页启用
- [ ] 内核内存可访问
- [ ] 显存可访问
- [ ] 无效地址触发页错误
- [ ] 键盘中断工作
- [ ] RTC 中断工作

### Checkpoint 2
- [ ] terminal_read 正确阻塞
- [ ] terminal_write 正确输出
- [ ] 终端滚屏工作
- [ ] RTC 频率设置
- [ ] 文件系统目录读取
- [ ] 文件系统文件读取
- [ ] 大文件读取

### Checkpoint 3
- [ ] open/close 工作
- [ ] read 文件工作
- [ ] write 终端工作
- [ ] getargs 工作
- [ ] execute 有效程序
- [ ] execute 无效程序返回 -1
- [ ] halt 返回正确值
- [ ] shell 正常运行

### Checkpoint 4
- [ ] 终端切换 (Alt+Fx)
- [ ] 终端内容隔离
- [ ] 键盘输入隔离
- [ ] 多个 shell 独立运行

### Checkpoint 5
- [ ] 调度器工作
- [ ] 多程序并发运行
- [ ] fish 程序运行

---

## 自动化测试脚本

### Makefile 目标

```makefile
# Makefile

test: kernel
	qemu-system-i386 $(QEMU_FLAGS) -append "tests=1"

test-gdb: kernel
	qemu-system-i386 $(QEMU_FLAGS) -s -S -append "tests=1"

test-specific: kernel
	qemu-system-i386 $(QEMU_FLAGS) -append "tests=paging,idt"
```

### 测试驱动脚本

```bash
#!/bin/bash
# run_tests.sh

echo "Building kernel..."
make clean && make

echo "Running tests..."
timeout 30 qemu-system-i386 \
    -hda student-distrib/mp3.img \
    -m 256 \
    -name test \
    -nographic \
    -append "tests=1" \
    2>&1 | tee test_output.log

echo "Checking results..."
if grep -q "All tests passed" test_output.log; then
    echo "SUCCESS"
    exit 0
else
    echo "FAILURE"
    grep "\[FAIL\]" test_output.log
    exit 1
fi
```

---

## 总结

| 阶段 | 测试重点 | 方法 |
|-----|---------|------|
| CP1 | IDT, 分页, PIC | 触发异常/中断验证 |
| CP2 | 终端, RTC, FS | 读写操作验证 |
| CP3 | 系统调用, 进程 | 用户程序测试 |
| CP4 | 多终端 | 手动切换测试 |
| CP5 | 调度 | 并发程序测试 |

测试原则：
1. **先单元后集成** - 先测试单个模块，再测试组合
2. **正常路径优先** - 先测试正常情况，再测试边界/错误情况
3. **保持简单** - 每个测试只验证一个功能点
4. **可重复** - 测试结果应该一致
5. **记录结果** - 保存测试输出供分析
