# 进程管理深度解析

## 概述

进程是程序的执行实例。本操作系统支持最多6个并发进程，分布在3个终端中。进程管理包括：

1. **execute** - 创建新进程
2. **halt** - 终止进程
3. **PCB** - 进程控制块
4. **内存布局** - 进程的虚拟/物理地址空间

---

## PCB (进程控制块)

### 数据结构

```c
typedef struct pcb {
    file_desc_t fd_table[8];   // 文件描述符表
    uint8_t pid;               // 进程ID(0-5)
    struct pcb* parent;        // 父进程PCB指针
    uint32_t term_id;          // 所属终端(0, 1, 2)

    // 上下文切换时保存的寄存器
    uint32_t esp;              // execute时的内核栈指针
    uint32_t ebp;              // execute时的内核栈基址
    uint32_t curr_esp;         // 调度时的当前栈指针
    uint32_t curr_ebp;         // 调度时的当前栈基址

    int8_t arg[1024];          // 程序参数(如 "readme.txt")

    uint16_t ss0;              // 内核栈段
    uint32_t esp0;             // 内核栈顶
} pcb_t;
```

### PCB在内存中的位置

PCB位于进程的内核栈底部：

```
物理内存布局 (内核空间 4MB-8MB):

┌─────────────────────────────┐ 8MB
│      进程 0 内核栈            │
│  ┌─────────────────────┐    │ 8MB - 4
│  │     栈空间           │    │ ↑
│  │        ↓            │    │ │ 栈向下增长
│  │                     │    │ │
│  ├─────────────────────┤    │ │
│  │      PCB 0          │    │ 8MB - 8KB
│  └─────────────────────┘    │
├─────────────────────────────┤ 8MB - 8KB
│      进程 1 内核栈            │
│  ┌─────────────────────┐    │
│  │     栈空间           │    │
│  ├─────────────────────┤    │
│  │      PCB 1          │    │ 8MB - 16KB
│  └─────────────────────┘    │
├─────────────────────────────┤
│           ...               │
├─────────────────────────────┤
│      进程 5 内核栈            │
│  ┌─────────────────────┐    │
│  │      PCB 5          │    │ 8MB - 48KB
│  └─────────────────────┘    │
└─────────────────────────────┘ 4MB
```

### PCB地址计算

```c
pcb_t* get_specific_pcb(uint8_t pid) {
    uint32_t addr = _8MB - _8KB * (1 + pid);
    return (pcb_t*)addr;
}

// 示例:
// pid=0: 8MB - 8KB  = 0x7FE000
// pid=1: 8MB - 16KB = 0x7FC000
// pid=2: 8MB - 24KB = 0x7FA000
```

---

## execute - 执行新程序

### 执行流程 (6步)

```
execute("cat readme.txt")
           │
           ▼
    ┌──────────────────────────────────────────┐
    │ 1. Parse - 解析命令                       │
    │    "cat readme.txt"                      │
    │         ↓                                │
    │    parsed_command = "cat"                │
    │    argument = "readme.txt"               │
    └──────────────────────────────────────────┘
           │
           ▼
    ┌──────────────────────────────────────────┐
    │ 2. Executable Check - 可执行文件检查       │
    │    - 在文件系统中查找 "cat"                │
    │    - 读取前4字节，检查ELF魔数               │
    │      0x7F 'E' 'L' 'F' (0x7F454C46)       │
    │    - 读取字节24-27，获取入口点地址           │
    └──────────────────────────────────────────┘
           │
           ▼
    ┌──────────────────────────────────────────┐
    │ 3. Paging - 设置页表                      │
    │    - 分配新的PID                          │
    │    - 创建虚拟地址映射:                      │
    │      虚拟128MB → 物理 (8MB + pid*4MB)     │
    └──────────────────────────────────────────┘
           │
           ▼
    ┌──────────────────────────────────────────┐
    │ 4. User-level Program Loader - 加载程序   │
    │    - 从文件系统读取整个程序                  │
    │    - 复制到虚拟地址0x08048000              │
    └──────────────────────────────────────────┘
           │
           ▼
    ┌──────────────────────────────────────────┐
    │ 5. Create PCB - 创建进程控制块             │
    │    - 初始化fd_table (stdin, stdout)       │
    │    - 设置父进程指针                        │
    │    - 保存参数                             │
    │    - 保存当前ESP/EBP                      │
    └──────────────────────────────────────────┘
           │
           ▼
    ┌──────────────────────────────────────────┐
    │ 6. Context Switch - 上下文切换             │
    │    - 设置TSS (SS0, ESP0)                  │
    │    - 构造iret栈帧                         │
    │    - 执行iret进入用户态                    │
    └──────────────────────────────────────────┘
```

### 代码详解

#### Step 1: 解析命令

```c
// 输入: "cat readme.txt"
int i = 0;

// 跳过前导空格
while(command[i] == ' ') i++;

int start_point = i;
int length_cmd = strlen((int8_t*)command);

// 提取命令名
for(; i < length_cmd; i++) {
    if(command[i] == ' ' || command[i] == '\0') break;
    parsed_command[i - start_point] = command[i];
}
// parsed_command = "cat"

// 提取参数
start_point = i + 1;
while (command[start_point] == ' ') start_point++;

int end_point = start_point;
while (command[end_point] != ' ' && command[end_point] != '\0') {
    end_point++;
}

for (i = start_point; i < end_point; i++) {
    argument[i - start_point] = command[i];
}
argument[end_point - start_point] = '\0';
// argument = "readme.txt"
```

#### Step 2: 可执行文件检查

```c
// 在文件系统中查找
dentry_t execute_dentry;
if (read_dentry_by_name((uint8_t*)parsed_command, &execute_dentry) != 0) {
    return -1;  // 文件不存在
}

// 读取前 4 字节检查 ELF 魔数
uint8_t buf[4];
read_data(execute_dentry.inode, 0, buf, 4);

// ELF 魔数: 0x7F, 'E', 'L', 'F'
if (buf[0] != 0x7F || buf[1] != 0x45 ||
    buf[2] != 0x4C || buf[3] != 0x46) {
    return -1;  // 不是 ELF 可执行文件
}

// 读取入口点地址 (字节 24-27)
read_data(execute_dentry.inode, 24, buf, 4);
uint32_t entry_point = *((uint32_t*)buf);
```

ELF 文件头结构：

```
┌─────────────────────────────────────────┐ 偏移 0
│  0x7F 'E' 'L' 'F'   (ELF 魔数)           │
├─────────────────────────────────────────┤ 偏移 4
│  ELF 类型、架构等信息                      │
├─────────────────────────────────────────┤ 偏移 24
│  Entry Point (入口地址)                  │ ← 我们读取这里
├─────────────────────────────────────────┤
│  ...                                    │
└─────────────────────────────────────────┘
```

#### Step 3: 设置分页

```c
// 获取可用的 PID
int8_t new_pid = get_available_pid();
if (new_pid < 0) return -2;  // 进程数已满

cur_pid = new_pid;

// 创建页表映射
// 虚拟地址128MB → 物理地址 (8MB + pid * 4MB)
remap(_128MB, _8MB + new_pid * _4MB);
```

虚拟内存布局：

```
┌───────────────────────────────────────────┐ 0x00000000
│        内核空间 (0-4MB)                    │
│        直接映射                            │
├───────────────────────────────────────────┤ 0x00400000 (4MB)
│        内核空间 (4MB-8MB)                  │
│        内核代码、PCB、内核栈                 │
├───────────────────────────────────────────┤ 0x00800000 (8MB)
│        进程 0 物理内存 (8-12MB)             │
├───────────────────────────────────────────┤ 0x00C00000 (12MB)
│        进程 1 物理内存 (12-16MB)            │
├───────────────────────────────────────────┤
│        ...                                │
└───────────────────────────────────────────┘

用户虚拟地址空间 (每个进程看到的):
┌───────────────────────────────────────────┐ 0x00000000
│        不可用                              │
├───────────────────────────────────────────┤ 0x08000000 (128MB)
│        用户程序空间 (4MB)                   │
│        映射到物理 (8MB + pid*4MB)          │
│  ┌─────────────────────────────────────┐  │
│  │ 0x08048000: 程序加载地址              │  │
│  │ ...                                 │  │
│  │ 0x083FFFFC: 用户栈底                 │  │
│  └─────────────────────────────────────┘  │
├───────────────────────────────────────────┤ 0x08400000 (132MB)
│        视频内存 (vidmap)                   │
└───────────────────────────────────────────┘
```

#### Step 4: 加载程序

```c
// 将程序从文件系统复制到虚拟地址 0x08048000
read_data(execute_dentry.inode, 0, (uint8_t*)LOAD_START, f_size);
// LOAD_START = 0x08048000
// f_size = 文件大小
```

#### Step 5: 创建PCB

```c
pcb_t* new_pcb = get_specific_pcb(new_pid);

// 保存参数
strcpy((int8_t*)new_pcb->arg, argument);

// 保存当前 ESP/EBP (用于 halt 返回)
asm volatile(
    "movl %%ebp, %%eax;"
    "movl %%esp, %%ebx;"
    : "=a"(new_pcb->ebp), "=b"(new_pcb->esp)
);

// 初始化 PCB
init_pcb(new_pcb, new_pid);
```

```c
void init_pcb(pcb_t* pcb, uint8_t pid) {
    // 设置父进程
    if (get_parent_pcb(pid) == NULL) {
        pcb->parent = NULL;  // 第一个进程没有父进程
    } else {
        pcb->parent = get_parent_pcb(pid);
    }

    pcb->pid = pid;
    pcb->term_id = curr_term;

    // 初始化 stdin/stdout
    pcb->fd_table[0].op_table_ptr = stdin_table;
    pcb->fd_table[1].op_table_ptr = stdout_table;
    pcb->fd_table[0].flags = 1;
    pcb->fd_table[1].flags = 1;
}
```

#### Step 6: 上下文切换 (iret)

```c
// 设置 TSS
tss.ss0 = KERNEL_DS;
tss.esp0 = _8MB - _8KB * new_pid - 4;  // 内核栈顶

// 构造 iret 栈帧并跳转到用户态
asm volatile(
    "cli;"

    // 设置用户数据段
    "mov $0x2B, %%ax;"     // USER_DS | 3
    "mov %%ax, %%ds;"

    // 压入 SS (用户栈段)
    "pushl $0x2B;"

    // 压入 ESP (用户栈指针)
    "movl $0x83FFFFC, %%eax;"  // 128MB + 4MB - 4
    "pushl %%eax;"

    // 压入 EFLAGS (开启中断)
    "pushfl;"
    "popl %%edx;"
    "orl $0x200, %%edx;"       // 设置 IF 位
    "pushl %%edx;"

    // 压入 CS (用户代码段)
    "pushl $0x23;"             // USER_CS | 3

    // 压入 EIP (程序入口点)
    "pushl %0;"

    // iret 返回用户态
    "iret;"

    // halt 返回点
    "RET_FROM_IRET:;"
    "leave;"
    "ret;"
    :
    : "r"(entry_point)
    : "%edx", "%eax"
);
```

iret 前的栈布局：

```
         ┌──────────────┐
         │    SS        │  0x2B (USER_DS | 3)
         ├──────────────┤
         │    ESP       │  0x83FFFFC (用户栈顶)
         ├──────────────┤
         │   EFLAGS     │  IF=1 (中断使能)
         ├──────────────┤
         │    CS        │  0x23 (USER_CS | 3)
         ├──────────────┤
    ESP →│    EIP       │  entry_point (程序入口)
         └──────────────┘

iret 执行后:
- EIP, CS, EFLAGS 从栈弹出
- 检测到特权级变化 (0 → 3)
- ESP, SS 也从栈弹出
- 跳转到用户程序入口执行
```

---

## halt - 终止进程

### 终止流程

```
用户程序调用 halt(status)
           │
           ▼
┌─────────────────────────────────────────┐
│ 1. 获取当前PCB和父PCB                     │
│    cur_pcb = get_specific_pcb(cur_pid)  │
│    parent_pcb = cur_pcb->parent         │
└─────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────┐
│ 2. 释放资源                              │
│    - 清除 pid_array[pid]                │
│    - 关闭所有打开的文件                    │
└─────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────┐
│ 3. 特殊情况: 基础 shell                   │
│    if (parent == NULL)                  │
│        重新启动 shell                    │
└─────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────┐
│ 4. 恢复父进程环境                         │
│    - 恢复父进程的页表映射                  │
│    - 恢复 TSS (esp0)                     │
│    - 更新 cur_pid                        │
└─────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────┐
│ 5. 返回到父进程                           │
│    - 恢复 ESP/EBP                        │
│    - 跳转到 RET_FROM_IRET                │
└─────────────────────────────────────────┘
```

### 代码详解

```c
int32_t halt_func(uint8_t status) {
    cli();

    // 获取当前 PCB
    pcb_t* cur_pcb = get_specific_pcb(cur_pid);
    pcb_t* parent_pcb = cur_pcb->parent;

    // 释放 PID
    pid_array[cur_pcb->pid] = 0;

    // 关闭所有打开的文件
    for (int i = 0; i < MAX_FILES; i++) {
        if (cur_pcb->fd_table[i].flags == 1) {
            close(i);
        }
    }

    // 如果没有父进程 (基础 shell)，重新启动
    if (cur_pcb->parent == NULL) {
        term[halt_term].running_pid = -1;
        execute((uint8_t*)"shell");
    }

    // 更新终端的运行进程
    term[halt_term].running_pid = parent_pcb->pid;

    // 恢复父进程的页表
    remap(_128MB, _8MB + parent_pcb->pid * _4MB);

    // 恢复 TSS
    tss.esp0 = (uint32_t)cur_pcb->esp;

    // 更新当前 PID
    cur_pid = parent_pcb->pid;

    sti();

    // 恢复 ESP/EBP，跳回 execute 的 iret 后
    asm volatile(
        "mov %0, %%eax;"
        "mov %1, %%esp;"
        "mov %2, %%ebp;"
        "jmp RET_FROM_IRET;"
        :
        : "r"((uint32_t)status), "r"(cur_pcb->esp), "r"(cur_pcb->ebp)
        : "%eax"
    );

    return 0;
}
```

### halt返回机制

```
execute() 中:
     ...
     iret;              ← 进入用户态
     RET_FROM_IRET:     ← halt 返回到这里
     leave;
     ret;               ← 返回到调用 execute 的地方

当子进程调用 halt:
1. halt 恢复 ESP/EBP 到 execute 时保存的值
2. jmp RET_FROM_IRET
3. leave; ret; 使 execute 返回
4. 返回值是 halt 的 status 参数
```

---

## 进程内存布局总结

```
┌─────────────────────────────────────────────────────────────────────┐
│                         物理内存布局                                  │
├─────────────────────────────────────────────────────────────────────┤
│  0MB - 4MB   │ 内核代码 (直接映射)                                     │
├──────────────┼──────────────────────────────────────────────────────┤
│  4MB - 8MB   │ 内核数据、PCB、内核栈                                   │
│              │   PCB0 @ 8MB-8KB, PCB1 @ 8MB-16KB, ...               │
├──────────────┼──────────────────────────────────────────────────────┤
│  8MB - 12MB  │ 进程 0 程序空间                                        │
├──────────────┼──────────────────────────────────────────────────────┤
│  12MB - 16MB │ 进程 1 程序空间                                        │
├──────────────┼──────────────────────────────────────────────────────┤
│  16MB - 20MB │ 进程 2 程序空间                                        │
├──────────────┼──────────────────────────────────────────────────────┤
│     ...      │ ...                                                  │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                    用户虚拟地址空间 (所有进程相同)                       │
├─────────────────────────────────────────────────────────────────────┤
│  0x08000000  │ 用户程序起始 (128MB)                                   │
│  0x08048000  │ 程序加载地址 (固定)                                     │
│     ...      │ 代码 + 数据                                           │
│  0x083FFFFC  │ 用户栈底 (128MB + 4MB - 4)                            │
├──────────────┼──────────────────────────────────────────────────────┤
│  0x08400000  │ 视频内存映射 (132MB, vidmap)                           │
└─────────────────────────────────────────────────────────────────────┘
```

---

## Shell运行命令的进程模型

**Shell 中运行命令会新开一个进程**。每个命令都是 shell 的子进程。

### 执行流程

```
用户在 shell 输入: cat readme.txt
                      │
                      ▼
shell 调用 execute("cat readme.txt")
                      │
                      ▼
┌─────────────────────────────────────────────────┐
│  execute_func() 创建新进程                        │
│                                                 │
│  1. new_pid = get_available_pid()  // 分配新 PID │
│  2. remap() 设置新进程的页表                       │
│  3. 加载 cat 程序到内存                            │
│  4. 创建新 PCB，parent 指向 shell 的 PCB           │
│  5. iret 切换到 cat 执行                          │
└─────────────────────────────────────────────────┘
                      │
                      ▼
             cat 进程运行 (pid=1)
             shell 进程暂停 (pid=0)
                      │
                      ▼
             cat 调用 halt(0)
                      │
                      ▼
┌─────────────────────────────────────────────┐
│  halt_func() 终止 cat 进程                    │
│                                             │
│  1. 关闭 cat 打开的文件                        │
│  2. 释放 pid_array[1]                        │
│  3. 恢复 shell 的页表                         │
│  4. cur_pid = parent_pcb->pid (回到 0)       │
│  5. 跳回 shell 的 execute 返回点              │
└─────────────────────────────────────────────┘
                      │
                      ▼
             shell 继续运行，等待下一个命令
```

### 进程层次结构

```
终端 0:
┌─────────────────────────────────────────────┐
│  shell (pid=0)                              │
│      │                                      │
│      ├── execute("cat") ──► cat (pid=1)     │
│      │                         │            │
│      │                      halt(0)         │
│      │◄────────────────────────┘            │
│      │                                      │
│      ├── execute("ls") ───► ls (pid=1)      │
│      │                         │            │
│      │                      halt(0)         │
│      │◄────────────────────────┘            │
│      │                                      │
│     ...                                     │
└─────────────────────────────────────────────┘
```

### PCB 的parent指针

```c
// cat 的 PCB
pcb_t cat_pcb = {
    .pid = 1,
    .parent = &shell_pcb,   // 指向 shell
    // ...
};

// shell 的 PCB (第一个进程)
pcb_t shell_pcb = {
    .pid = 0,
    .parent = NULL,         // 没有父进程
    // ...
};
```

当cat调用`halt()`时，通过`parent`指针找到shell，恢复shell的执行环境。

### 和 Linux 的区别

| 特性   | 391 OS          | Linux             |
|------|-----------------|-------------------|
| 创建进程 | execute 直接创建并切换 | fork 复制 + exec 替换 |
| 父子关系 | 父进程暂停等待         | 父进程可以继续运行         |
| 后台运行 | 不支持             | 支持 (& 符号)         |

391 OS 简化了设计：**execute = fork + exec + wait 合为一体**。父进程调用 execute 后会暂停，直到子进程 halt 返回。

---

## 完整进程层次示例

```
系统启动
    │
    └── init_term()
            │
            └── execute("shell")     [pid=0, 终端0]
                    │
                    ├── 用户输入: cat readme.txt
                    │       └── execute("cat readme.txt")  [pid=1]
                    │               │
                    │               └── halt(0) 返回
                    │
                    ├── 用户输入: exit
                    │       └── halt(0)
                    │               │
                    │               └── parent==NULL, 重启 shell
                    │
                    └── Alt+F2 切换到终端 1
                            │
                            └── execute("shell")  [pid=2, 终端1]
```

---

## 总结

| 概念      | 说明                                |
|---------|-----------------------------------|
| PCB     | 进程控制块，位于内核栈底部 (8MB - 8KB*(1+pid)) |
| PID     | 进程 ID，0-5，通过 pid_array 管理         |
| execute | 6 步流程：解析、检查、分页、加载、创建PCB、上下文切换     |
| halt    | 释放资源、恢复父进程环境、跳回 execute 后继续执行     |
| iret    | 从内核态返回用户态的关键指令，需要构造正确的栈帧          |
| 内存映射    | 虚拟 128MB 映射到物理 (8MB + pid*4MB)    |
