# 分页系统 (Paging) 深度解析

## 1. 为什么需要分页？

### 1.1 没有分页的问题

```
物理内存（没有分页）：
┌──────────────────────────────────────────────┐
│ 程序A (1MB) │ 空闲 │ 程序B (2MB) │ 空闲 │ 程序C │
└──────────────────────────────────────────────┘
                 ↑
            外部碎片
            虽然总空闲 > 3MB，但无法运行 3MB 的程序
```

### 1.2 分页的解决方案

```
虚拟内存 + 分页：

程序A的视角：               物理内存：
┌──────────────┐         ┌──────────────┐
│ 0x00000000   │ ──────► │ 物理页框 5    │
│ 0x00001000   │ ──────► │ 物理页框 100  │
│ 0x00002000   │ ──────► │ 物理页框 37   │
│    ...       │         │    ...       │
└──────────────┘         └──────────────┘

每个程序都以为自己独占0-4GB地址空间
物理页框可以不连续，消除外部碎片。
```

### 1.3 分页的好处

1. **消除外部碎片**：物理内存按固定大小分配
2. **进程隔离**：每个进程有独立地址空间
3. **内存保护**：通过权限位控制访问
4. **虚拟内存**：可以把不常用页面换到磁盘

---

## 2. x86 分页基础

### 2.1 关键概念

| 术语   | 英文               | 说明                    |
|------|------------------|-----------------------|
| 虚拟地址 | Virtual Address  | 程序使用的地址               |
| 物理地址 | Physical Address | 实际内存地址                |
| 页    | Page             | 虚拟内存的固定大小块（4KB 或 4MB） |
| 页框   | Page Frame       | 物理内存的固定大小块            |
| 页表   | Page Table       | 虚拟页→物理页框的映射表          |
| 页目录  | Page Directory   | 指向页表的表（二级结构）          |

### 2.2 为什么用两级页表？

**单级页表的问题**：

```
4GB 地址空间 ÷ 4KB 页 = 1M 个页表项
1M × 4 字节 = 4MB 页表

问题：每个进程都需要 4MB 页表，太浪费
```

#### 为什么单级页表不能按需分配？

**核心原因：页表是用索引直接访问的数组**

```
CPU 地址转换时：

虚拟地址 0xABCDE000
         │
         ▼
    页号 = 0xABCDE000 >> 12 = 0xABCDE = 703710
         │
         ▼
    直接访问 页表[703710]   ← 必须存在
         │
         ▼
    物理页框地址

关键：CPU硬件直接用页号作为数组索引，不是查找，是直接寻址
```

**为什么右移 12 位？**

```
12是页内偏移的位数，由页大小决定：

4KB = 4096字节 = 2^12字节
所以需要12位来表示页内的每个字节位置（0 ~ 4095）
```

**32位虚拟地址的拆分：**

```
32位虚拟地址：0xABCDE123

二进制：1010 1011 1100 1101 1110 0001 0010 0011
       ├─────────────────────┤├──────────────┤
              高 20 位              低 12 位
               页号               页内偏移

页号    = 高20位 = 0xABCDE = 703710  （哪一页）
页内偏移 = 低12位 = 0x123   = 291     （页内第几个字节）
```

**右移12位的作用：**

```
0xABCDE123 >> 12

相当于：
  0xABCDE123 / 4096
= 0xABCDE123 / 2^12
= 0xABCDE          ← 得到页号

右移12位 = 去掉低12位 = 去掉页内偏移 = 只保留页号
```

**不同页大小对应不同的位数：**

| 页大小 | 字节数            | 偏移位数 | 右移位数  |
|-----|----------------|------|-------|
| 4KB | 4096 = 2^12    | 12 位 | >> 12 |
| 4MB | 4194304 = 2^22 | 22 位 | >> 22 |
| 2MB | 2097152 = 2^21 | 21 位 | >> 21 |
| 1GB | 2^30           | 30 位 | >> 30 |

**类比：数组 vs 指针数组**

```
┌─────────────────────────────────────────────────────────────────┐
│  单级页表 = 普通数组                                               │
│                                                                 │
│  int page_table[1048576];  // 必须分配全部 1M 项                  │
│                                                                 │
│  访问方式：page_table[703710]                                    │
│       直接计算地址：页表基址 + 703710 × 4                          │
│                                                                 │
│  如果只分配前 1000 项：                                            │
│    page_table[703710] = ???  访问越界CPU 无法工作                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  两级页表 = 指针数组（稀疏）                                        │
│                                                                 │
│  int* page_directory[1024];   // 只需 4KB                        │
│  // 每项指向一个页表，或者 NULL                                     │
│                                                                 │
│  访问方式：                                                       │
│    dir_index = 703710 / 1024 = 687                              │
│    table_index = 703710 % 1024 = 702                            │
│                                                                 │
│    if (page_directory[687] == NULL)                             │
│        → 页错误不需要预先分配这个页表                               │
│    else                                                         │
│        → page_directory[687][702]                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**图解对比**

```
单级页表（数组，连续内存）：
┌─────────────────────────────────────────────────────────────────┐
│ [0] [1] [2] [3] ... [703710] ... [1048575]                      │
│  ✓   ✗   ✗   ✗  ...    ✓    ...     ✓                           │
│  │                     │            │                           │
│  └──── 全部必须存在 ─────┴────────────┘                           │
│        因为CPU直接用索引访问                                       │
│        page_table + index × 4                                   │
└─────────────────────────────────────────────────────────────────┘

两级页表（指针数组，可以有空洞）：
┌──────────────────┐
│ 页目录            │
│ [0]   → 页表0     │ 存在
│ [1]   → NULL     │ 不分配
│ [2]   → NULL     │ 不分配
│ ...   → NULL     │ 不分配
│ [687] → 页表687   │ 存在（因为访问了 703710）
│ ...   → NULL     │ 不分配
│ [1023]→ 页表1023  │ 存在
└──────────────────┘
     │
     │ 只分配用到的
     ▼
┌──────────────────┐    ┌──────────────────┐
│ 页表0 (4KB)       │    │ 页表687 (4KB)     │
│ [0] → 物理页      │    │ [702] → 物理页    │
│ [1-1023] 未用     │    │ 其他未用          │
└──────────────────┘    └──────────────────┘
```

**为什么两级能按需分配？**

```
┌─────────────────────────────────────────────────────────────────┐
│  秘密在于：PDE.present 位                                         │
│                                                                 │
│  CPU 查页目录时：                                                 │
│                                                                 │
│  页目录[687].present == 0 ?                                      │
│       │                                                         │
│       ├── 是 → 触发页错误 (#PF)                                   │
│       │        OS 可以选择：                                      │
│       │        1. 分配新页表，重试                                 │
│       │        2. 终止进程（非法访问）                             │
│       │                                                         │
│       └── 否 → 继续查页表                                         │
│                                                                 │
│  单级页表没有这个检查机会                                           │
│  CPU 直接算地址访问，没有"中间层"来拦截                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**总结**

| 结构   | 访问方式             | 能否按需分配 | 原因              |
|------|------------------|--------|-----------------|
| 单级页表 | 直接索引 `table[页号]` | ❌ 不能   | 数组必须连续，CPU 直接寻址 |
| 两级页表 | 先查目录再查表          | ✅ 能    | 目录项可以为空，触发页错误   |

**本质**：两级页表引入了一个"中间层"（页目录），这个中间层可以说"这块区域不存在"，从而避免分配对应的页表。

#### 追问：为什么不能只分配用到的页号？

**问题：数组的本质是连续内存**

```
假设我们想"只分配用到的"：
进程用了3个页：页号 0, 703710, 1048575
理想情况（你想的）：
┌─────┐     ┌─────────┐     ┌───────────┐
│ [0] │     │[703710] │     │[1048575]  │
└─────┘     └─────────┘     └───────────┘
  ↑              ↑               ↑
只分配这3个，节省内存
但是，CPU怎么找到[703710]？
```

**CPU地址计算方式（硬件固定）**

```
┌─────────────────────────────────────────────────────────────────┐
│  CPU 硬件的寻址方式（固定的，无法改变）：                             │
│                                                                 │
│  页表项地址 = 页表基址 + 页号 × 4                                   │
│                                                                 │
│  例如：                                                          │
│    页表基址 = 0x1000000                                           │
│    页号 = 703710                                                 │
│    页表项地址 = 0x1000000 + 703710 × 4 = 0x12AF378                │
│                                                                 │
│  CPU直接访问0x12AF378，不管那里有没有东西                           │
└─────────────────────────────────────────────────────────────────┘
```

**注意：为什么是×4而不是×4096？**

```
┌─────────────────────────────────────────────────────────────────┐
│  页表项 (PTE) ≠ 页 (Page)                                        │
│                                                                 │
│  页表项：存储映射信息，每项 4 字节                                   │
│  页：    实际的内存块，每页 4096 字节 (4KB)                         │
└─────────────────────────────────────────────────────────────────┘

页表是一个数组，每个元素是页表项 (PTE)：

页表 (page_table)
┌───────────────────────────────────────────────────────────────────┐
│ PTE[0] │ PTE[1] │ PTE[2] │ ... │ PTE[703710] │ ... │ PTE[1048575] │
│ 4byte  │ 4byte  │ 4byte  │     │    4byte    │     │    4byte     │
└───────────────────────────────────────────────────────────────────┘
   │         │                         │
   ▼         ▼                         ▼
┌──────┐  ┌──────┐                 ┌──────┐
│物理页 │  │物理页 │                 │物理页 │
│ 4KB  │  │ 4KB  │                 │ 4KB  │
└──────┘  └──────┘                 └──────┘

两步寻址过程：

虚拟地址 0xABCDE123
         │
         ▼
┌─────────────────────────────────────────────────────────────────┐
│  第一步：找到页表项 (PTE)                                          │
│                                                                 │
│  页号 = 0xABCDE123 >> 12 = 0xABCDE = 703710                      │
│  页表项地址 = 页表基址 + 703710 × 4                                │
│                                ↑                                │
│                            每个PTE是4字节                         │
│                                                                 │
│  读取 PTE，得到物理页框号，假设是 0x12345                            │
└─────────────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────────────┐
│  第二步：计算物理地址                                              │
│                                                                 │
│  页内偏移 = 0xABCDE123 & 0xFFF = 0x123                           │
│  物理地址 = 0x12345 × 4096 + 0x123 = 0x12345123                  │
│                     ↑                                           │
│               每个页是 4096 字节                                  │
└─────────────────────────────────────────────────────────────────┘

| 计算 | 乘数 | 原因 |
|------|------|------|
| 页表项地址 = 基址 + 页号 × **4** | 4 字节 | PTE 大小是 4 字节 |
| 物理地址 = 页框号 × **4096** + 偏移 | 4096 字节 | 页大小是 4KB |
```

**追问：页表基址 + 页号 × 4 的结果是物理地址吗？**

**不是** 这个结果是 **页表项 (PTE) 的地址**，不是最终的物理地址。

```
页表基址 + 页号 × 4 = 页表项的地址（PTE 在哪里）
                            │
                            ▼
                       读取 PTE 内容
                            │
                            ▼
                    PTE 里存的页框号 × 4096 + 偏移 = 物理地址（数据在哪里）
```

**完整的三步流程：**

```
虚拟地址 0xABCDE123
         │
         ▼
┌─────────────────────────────────────────────────────────────────┐
│  第一步：计算页表项地址（PTE 存在哪里）                               │
│                                                                 │
│  页号 = 0xABCDE123 >> 12 = 703710                                │
│  PTE 地址 = 页表基址 + 703710 × 4                                 │
│           = 0x1000000 + 2814840                                 │
│           = 0x12AF378                                           │
│                                                                 │
│  这是 PTE 自身的存放位置，不是数据的物理地址                          │
└─────────────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────────────┐
│  第二步：读取 PTE 内容（获取页框号）                                 │
│                                                                 │
│  CPU 访问内存地址 0x12AF378                                       │
│  读到 PTE 内容 = 0x12345067                                      │
│                  ├────├──┤                                      │
│                  页框号  属性位                                   │
│                 0x12345 0x067                                   │
│                (高20位)  (低12位)                                │
│                                                                 │
│  PTE 存的是"虚拟页 703710 对应物理页框 0x12345"                     │
└─────────────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────────────┐
│  第三步：计算最终物理地址（数据在哪里）                               │
│                                                                 │
│  页内偏移 = 0xABCDE123 & 0xFFF = 0x123                           │
│  物理地址 = 页框号 × 4096 + 偏移                                   │
│          = 0x12345 × 4096 + 0x123                               │
│          = 0x12345000 + 0x123                                   │
│          = 0x12345123   ← 这才是数据的物理地址                     │
└─────────────────────────────────────────────────────────────────┘
```

**类比理解：查字典**

```
┌─────────────────────────────────────────────────────────────────┐
│  虚拟地址 = "apple" 这个单词                                       │
│                                                                 │
│  第一步：找到字典中 "apple" 条目的位置                               │
│         条目地址 = 字典基址 + 索引 × 条目大小                        │
│         （找到字典里记录 apple 的那一行在哪）                        │
│                                                                 │
│  第二步：读取条目内容                                              │
│         条目内容 = "页码: 123"                                    │
│         （读出 apple 对应的页码）                                  │
│                                                                 │
│  第三步：翻到对应页                                                │
│         物理地址 = 页码 × 每页大小 + 行内偏移                       │
│         （翻到第 123 页，找到具体内容）                             │
└─────────────────────────────────────────────────────────────────┘
```

**总结：两个地址的区别**

| 计算              | 结果是什么       | 用途            |
|-----------------|-------------|---------------|
| 页表基址 + 页号 × 4   | **PTE 的地址** | 找到页表项在内存中的位置  |
| 页框号 × 4096 + 偏移 | **物理地址**    | 找到实际数据在内存中的位置 |

**注意：PTE 低 12 位 ≠ 虚拟地址低 12 位**

```
┌─────────────────────────────────────────────────────────────────┐
│  虚拟地址的低 12 位 = 页内偏移（数据在页内的位置）                     │
│  PTE 的低 12 位     = 属性标志位（页的权限和状态）                    │
│                                                                 │
│  这是完全不同的两个概念                                             │
└─────────────────────────────────────────────────────────────────┘

虚拟地址：0xABCDE123
         ├─────├──┤
          页号   页内偏移（数据位置）
        0xABCDE  0x123

PTE 内容：0x12345067
         ├─────├──┤
         页框号  属性位（权限控制）
        0x12345  0x067
```

**PTE低12位（属性位）详解：**

```
0x067 = 0000 0110 0111 (二进制)

  11  10  9   8   7   6   5   4   3   2   1   0
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐
│ 0 │ 0 │ 0 │ 0 │ 0 │ 1 │ 1 │ 0 │ 0 │ 1 │ 1 │ 1 │ = 0x067
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘
                      │   │       │   │   │   │
                      │   │       │   │   │   └── P = 1 (页存在)
                      │   │       │   │   └────── R/W = 1 (可读写)
                      │   │       │   └────────── U/S = 1 (用户可访问)
                      │   │       └────────────── PWT = 0
                      │   └────────────────────── A = 1 (已访问)
                      └────────────────────────── D = 1 (已写入/脏页)
```

**为什么PTE低12位可以存属性？**

```
┌─────────────────────────────────────────────────────────────────┐
│  因为物理页框是 4KB 对齐的                                         │
│                                                                 │
│  物理页框地址总是 0x?????000（低 12 位必定是 0）                     │
│                                                                 │
│  例如：                                                          │
│    页框 0 起始地址：0x00000000                                    │
│    页框 1 起始地址：0x00001000                                    │
│    页框 2 起始地址：0x00002000                                    │
│    ...                                                          │
│    页框 0x12345 起始地址：0x12345000                              │
│                                                                 │
│  既然低 12 位总是 0，不如拿来存有用的信息（属性位）                    │
│  这是一种巧妙的空间复用                                             │
└─────────────────────────────────────────────────────────────────┘
```

**如果只分配部分会怎样？**

```
假设只分配了 [0]：

内存布局：
         页表基址
            │
            ▼
   0x1000000 ┌─────┐
             │ [0] │ ← 只分配了这一个 (4字节)
   0x1000004 └─────┘
             │ ??? │ ← 未分配可能是其他数据
             │ ??? │
             │ ... │
   0x12AF378 │ ??? │ ← CPU 访问这里找 [703710]
             │ ... │    但这里是未分配的内存
                       可能是：
                       1. 其他变量
                       2. 代码
                       3. 随机垃圾
                       → 系统崩溃
```

**为什么不能用哈希表/链表？**

```
┌─────────────────────────────────────────────────────────────────┐
│  问题：CPU 硬件是固定的                                            │
│                                                                 │
│  CPU 地址转换是硬件电路实现的：                                     │
│                                                                 │
│    1. 取虚拟地址的高 20 位作为页号                                  │
│    2. 页号 × 4 + 页表基址 = 页表项地址                              │
│    3. 读取该地址的内容作为物理页框号                                 │
│                                                                 │
│  这是焊死在 CPU 里的逻辑，不是软件可以改的                            │
│                                                                 │
│  你不能让 CPU 去"查找"或"遍历"——那样太慢了                           │
│  每条指令都要地址转换，必须是 O(1) 的直接寻址                         │
└─────────────────────────────────────────────────────────────────┘
```

**两级页表的巧妙之处**

```
两级页表不是改变了CPU的寻址方式，而是：

把一个大数组 → 拆成 1024 个小数组

┌─────────────────────────────────────────────────────────────────┐
│  单级：一个 1M 项的大数组                                          │
│                                                                 │
│  table[页号]                                                     │
│  必须分配完整的 1M × 4 = 4MB                                      │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  两级：1024 个 1K 项的小数组                                       │
│                                                                 │
│  directory[页号 / 1024][页号 % 1024]                             │
│                                                                 │
│  directory 必须完整分配（1024 × 4 = 4KB）✓                         │
│  但每个 table 可以不分配                                           │
│    - directory[i] = NULL 表示这 4MB 范围不存在                     │
│    - CPU 检查 present 位，为 0 就触发页错误                         │
│    - 不会去访问不存在的页表                                         │
└─────────────────────────────────────────────────────────────────┘
```

**结论**

| 问题           | 答案                  |
|--------------|---------------------|
| 能不能只分配用到的页号？ | ❌ 不能，CPU 用索引直接寻址    |
| 能不能用哈希表/链表？  | ❌ 不能，CPU 硬件固定       |
| 两级页表怎么解决？    | 把大数组拆成小数组，未用的小数组不分配 |

**核心思想**：CPU 必须用数组，但两级页表把"一个 4MB 数组"变成了"1024 个 4KB 数组"，未使用的 4KB 数组可以不分配。

**两级页表的优势**：

```
页目录：1024 项 × 4 字节 = 4KB
页表：1024 项 × 4 字节 = 4KB（每个）

只有用到的虚拟地址才分配页表
大部分进程只需要几个页表 = 几十 KB
```

#### 图解：单级 vs 两级页表

**单级页表（浪费）**

一个进程只用了3个区域，但必须分配完整的页表：

```
虚拟地址空间 (4GB)              单级页表 (必须 4MB)
┌─────────────────┐            ┌─────────────────┐
│ Code (4KB)      │ ─────────► │ PTE 0     ✓     │ ─► 物理页
├─────────────────┤            ├─────────────────┤
│                 │            │ PTE 1     ✗     │ 空的，但占空间
│    unused       │            │ PTE 2     ✗     │ 空的
│    ...          │            │ ...       ✗     │ 空的
│  (almost 4GB)   │            │ ...       ✗     │ 全都要分配
│                 │            │ ...       ✗     │
├─────────────────┤            ├─────────────────┤
│ Heap (8KB)      │ ─────────► │ PTE xxx   ✓     │ ─► 物理页
├─────────────────┤            │ PTE xxx+1 ✓     │ ─► 物理页
│    unused       │            │ ...       ✗     │
├─────────────────┤            ├─────────────────┤
│ Stack (4KB)     │ ─────────► │ PTE 1048575 ✓   │ ─► 物理页
└─────────────────┘            └─────────────────┘

页表大小 = 1M 项 × 4 字节 = 4MB（固定）
实际只用4项，浪费99.9996%
```

**两级页表（节省）**

同样的进程，只分配用到的页表：

```
虚拟地址空间           页目录 (4KB)              页表 (按需分配)
┌─────────────┐       ┌─────────────┐
│ Code (4KB)  │       │ PDE 0   ✓   │──────────►┌─────────────┐ 页表 0 (4KB)
│ 0x00000000  │       ├─────────────┤           │ PTE 0   ✓   │─► 物理页
├─────────────┤       │ PDE 1   ✗   │ NULL      │ PTE 1-1023  │ (未用但在同一页表)
│             │       │ PDE 2   ✗   │ NULL      └─────────────┘
│  unused     │       │ ...     ✗   │ NULL
│  (0-1GB)    │       │ (not alloc) │
│             │       │             │
├─────────────┤       ├─────────────┤
│ Heap (8KB)  │       │ PDE 256 ✓   │──────────►┌─────────────┐ 页表 256 (4KB)
│ 0x40000000  │       ├─────────────┤           │ PTE 0   ✓   │─► 物理页
│ (1GB )      │       │ PDE 257 ✗   │ NULL      │ PTE 1   ✓   │─► 物理页
├─────────────┤       │ ...     ✗   │ NULL      └─────────────┘
│             │       │             │
│  unsed      │       │             │
│             │       │             │
├─────────────┤       ├─────────────┤
│ Stack (4KB) │       │ PDE 1023 ✓  │──────────►┌─────────────┐ 页表 1023 (4KB)
│ 0xFFFFF000  │       └─────────────┘           │ PTE 1023 ✓  │─► 物理页
│ (4GB top)   │                                 └─────────────┘
└─────────────┘

总内存 = 页目录 4KB + 3 个页表 × 4KB = 16KB
相比单级页表 4MB，节省了 99.6%
```

**数学对比**

```
┌────────────────────────────────────────────────────────────────┐
│                    单级页表 vs 两级页表                           │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  假设进程使用 3 个不连续区域（代码、堆、栈）                          │
│                                                                │
│  ┌──────────────┬─────────────────┬─────────────────┐          │
│  │              │    单级页表      │    两级页表      │           │
│  ├──────────────┼─────────────────┼─────────────────┤          │
│  │ 页目录       │      无         │ 4KB (必须)       │           │
│  │ 页表         │ 4MB (必须全部)   │ 12KB (3个页表)   │           │
│  ├──────────────┼─────────────────┼─────────────────┤          │
│  │ 总计         │    4MB          │     16KB        │           │
│  │ 节省         │      -          │    99.6%        │           │
│  └──────────────┴─────────────────┴─────────────────┘          │
│                                                                │
│  关键：PDE.present = 0 时，不需要分配对应的页表                     │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

**核心思想**

```
┌─────────────────────────────────────────────────────────────┐
│  两级页表的魔法：                                              │
│                                                             │
│  页目录项 (PDE) 的 present 位 = 0                             │
│       │                                                     │
│       ▼                                                     │
│  该 PDE 覆盖的 4MB 虚拟空间完全不用                             │
│       │                                                     │
│       ▼                                                     │
│  不需要分配 4KB 的页表                                         │
│                                                             │
│  ─────────────────────────────────────────                  │
│                                                             │
│  每个 PDE 管理 4MB 空间：                                     │
│    - 1024 个 PDE × 4MB = 4GB                                │
│    - 大部分 PDE.present = 0（不分配页表）                      │
│    - 只有用到的区域才分配页表                                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2.3 地址转换过程

```
32位虚拟地址：
┌──────────────┬──────────────┬──────────────┐
│   DIR (10)   │  TABLE (10)  │ OFFSET (12)  │
│   目录索引    │   页表索引    │   页内偏移    │
└──────────────┴──────────────┴──────────────┘
    bits 31-22     bits 21-12      bits 11-0

转换步骤：
1. CR3 寄存器 → 页目录物理地址
2. 页目录[DIR] → 页表物理地址
3. 页表[TABLE] → 页框物理地址
4. 物理地址 = 页框地址 + OFFSET
```

**图示**：

```
           CR3
            │
            ▼
     ┌─────────────┐
     │  Page Dir   │ 1024 项
     │ ┌─────────┐ │
     │ │ PDE 0   │─┼──► 页表 0
     │ │ PDE 1   │─┼──► 页表 1 (或 4MB 大页)
     │ │  ...    │ │
     │ │ PDE 1023│ │
     │ └─────────┘ │
     └─────────────┘
            │
         DIR索引
            │
            ▼
     ┌─────────────┐
     │  Page Table │ 1024 项
     │ ┌─────────┐ │
     │ │ PTE 0   │─┼──► 物理页框
     │ │ PTE 1   │ │
     │ │  ...    │ │
     │ │ PTE 1023│ │
     │ └─────────┘ │
     └─────────────┘
            │
        TABLE索引
            │
            ▼
     ┌─────────────┐
     │  Frame      │ 4KB
     │             │
     │   + OFFSET  │──► 最终物理地址
     │             │
     └─────────────┘
```

#### 完整示例：两级页表寻址过程

**虚拟地址：0x40001234**

```
第一步：拆分虚拟地址（10 + 10 + 12 位）

0x40001234 = 0100 0000 0000 0000 0001 0010 0011 0100

 31         22 21         12 11            0
┌─────────────┬─────────────┬───────────────┐
│ 0100 0000 00│00 0000 0001 │0010 0011 0100 │
└─────────────┴─────────────┴───────────────┘
   目录索引        页表索引      页内偏移
   = 0x100        = 0x001       = 0x234
   = 256          = 1           = 564
```

```
第二步：查页目录（找到页表在哪里）

CR3 = 页目录基址 = 0x100000

PDE 地址 = 页目录基址 + 目录索引 × 4
         = 0x100000 + 256 × 4
         = 0x100000 + 0x400
         = 0x100400

CPU 访问 0x100400，读取 PDE 内容 = 0x00201007
                                  ├────├──┤
                                  页表地址 属性
                                  0x00201 0x007

属性 0x007 = 0000 0111
             P=1 (存在), R/W=1 (可写), U/S=1 (用户可访问)

页表基址 = 0x00201 << 12 = 0x00201000
```

```
第三步：查页表（找到物理页框在哪里）

PTE 地址 = 页表基址 + 页表索引 × 4
         = 0x201000 + 1 × 4
         = 0x201004

CPU 访问 0x201004，读取 PTE 内容 = 0x00305067
                                  ├────├──┤
                                  页框号  属性
                                 0x00305 0x067

属性 0x067 = 0110 0111
             P=1, R/W=1, U/S=1, A=1(已访问), D=1(脏页)

物理页框基址 = 0x00305 << 12 = 0x00305000
```

```
第四步：计算最终物理地址

物理地址 = 物理页框基址 + 页内偏移
         = 0x00305000 + 0x234
         = 0x00305234

虚拟地址 0x40001234 → 物理地址 0x00305234
```

**完整流程图：**

```
虚拟地址 0x40001234
         │
         │ 拆分
         ▼
┌────────────┬────────────┬──────────────┐
│ DIR = 256  │ TABLE = 1  │ OFFSET=0x234 │
└────────────┴────────────┴──────────────┘
      │             │              │
      │             │              │
      ▼             │              │
┌──────────────┐    │              │
│ CR3=0x100000 │    │              │
│  Page Dir    │    │              │
│ ┌──────────┐ │    │              │
│ │ PDE[0]   │ │    │              │
│ │ ...      │ │    │              │
│ │ PDE[256] │─┼────┼──┐           │
│ │ ...      │ │    │  │           │
│ └──────────┘ │    │  │           │
└──────────────┘    │  │           │
                    │  │           │
      ┌─────────────┘  │           │
      │                ▼           │
      │      ┌──────────────┐      │
      │      │   Page Table │      │
      │      │   0x201000   │      │
      │      │ ┌──────────┐ │      │
      │      │ │ PTE[0]   │ │      │
      └──────┼►│ PTE[1]   │─┼──┐   │
             │ │ ...      │ │  │   │
             │ └──────────┘ │  │   │
             └──────────────┘  │   │
                               │   │
                               ▼   │
                    ┌──────────────┐
                    │    Frame     │
                    │   0x305000   │
                    │              │
                    │   + 0x234 ◄──┘
                    │      │       │
                    └──────┼───────┘
                           │
                           ▼
                   物理地址 0x305234
```

**对比：单级 vs 两级寻址**

| 步骤 | 单级页表                  | 两级页表                      |
|----|-----------------------|---------------------------|
| 1  | 页号 = 虚拟地址 >> 12       | 拆成 DIR + TABLE + OFFSET   |
| 2  | PTE 地址 = 基址 + 页号 × 4  | PDE 地址 = 页目录基址 + DIR × 4  |
| 3  | 读 PTE 得页框号            | 读 PDE 得页表基址               |
| 4  | 物理地址 = 页框 × 4096 + 偏移 | PTE 地址 = 页表基址 + TABLE × 4 |
| 5  | -                     | 读 PTE 得页框号                |
| 6  | -                     | 物理地址 = 页框 × 4096 + 偏移     |

两级页表多了一次内存访问（查页目录），但节省了大量内存

---

## 3. 页目录项 (PDE) 结构

### 3.1 两种 PDE 类型

x86 支持两种页大小：

| 类型        | PS 位 | 映射范围         | 用途          |
|-----------|------|--------------|-------------|
| 4KB 页 PDE | 0    | 指向页表         | 精细控制（如视频内存） |
| 4MB 页 PDE | 1    | 直接指向 4MB 物理块 | 大块内存（如内核）   |

### 3.2 4KB 页 PDE (指向页表)

```c
// paging.h 中的定义
typedef union PDE_4KB {
    uint32_t pointer;
    struct {
        uint32_t p          : 1;   // Present (存在位)
        uint32_t rw         : 1;   // Read/Write (读写位)
        uint32_t us         : 1;   // User/Supervisor (用户/内核)
        uint32_t pwt        : 1;   // Page Write-Through
        uint32_t pcd        : 1;   // Page Cache Disable
        uint32_t a          : 1;   // Accessed (访问位)
        uint32_t reserved   : 1;   // 保留 (必须为 0)
        uint32_t ps         : 1;   // Page Size (0 = 4KB)
        uint32_t g          : 1;   // Global
        uint32_t avail      : 3;   // OS 可用
        uint32_t page_table_base_addr : 20; // 页表地址 [31:12]
    } __attribute__((packed));
} PDE_4KB_t;
```

**位字段布局**：

```
 31                   12 11  9 8 7 6 5 4 3 2 1 0
 ┌───────────────────────┬─────┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
 │ Page Table Addr[31:12]│Avail│G│0│0│A│D│W│U│R│P│
 └───────────────────────┴─────┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
                                │ │ │   │ │ │ │ └─ Present
                                │ │ │   │ │ │ └─── R/W
                                │ │ │   │ │ └───── U/S
                                │ │ │   │ └─────── PWT
                                │ │ │   └───────── PCD
                                │ │ └───────────── Accessed
                                │ └─────────────── PS (must be 0)
                                └───────────────── Global
```

### 3.3 4MB 页 PDE (直接映射)

```c
typedef union PDE_4MB {
    uint32_t pointer;
    struct {
        uint32_t p          : 1;   // Present
        uint32_t rw         : 1;   // Read/Write
        uint32_t us         : 1;   // User/Supervisor
        uint32_t pwt        : 1;   // Page Write-Through
        uint32_t pcd        : 1;   // Page Cache Disable
        uint32_t a          : 1;   // Accessed
        uint32_t d          : 1;   // Dirty (脏位)
        uint32_t ps         : 1;   // Page Size (1 = 4MB)
        uint32_t g          : 1;   // Global
        uint32_t avail      : 3;   // OS 可用
        uint32_t pat        : 1;   // Page Attribute Table
        uint32_t reserved   : 9;   // 保留 (必须为 0)
        uint32_t page_base_addr : 10; // 物理地址 [31:22]
    } __attribute__((packed));
} PDE_4MB_t;
```

**位字段布局**：

```
  31       22 21        13 12 11  9 8 7 6 5 4 3 2 1 0
 ┌───────────┬───────────┬───┬─────┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
 │Addr[31:22]│Reserved   │PAT│Avail│G│1│D│A│C│W│U│R│P│
 └───────────┴───────────┴───┴─────┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
                                    │ │             └─ Present
                                    │ └───────────── PS (must be 1)
                                    └─────────────── Global
```

### 3.4 关键字段说明

| 字段                 | 说明                |
|--------------------|-------------------|
| **P (Present)**    | 1=页存在，0=访问触发 #PF  |
| **R/W**            | 1=可读写，0=只读        |
| **U/S**            | 1=用户可访问，0=仅内核     |
| **A (Accessed)**   | CPU 访问后自动设为 1     |
| **D (Dirty)**      | CPU 写入后自动设为 1     |
| **PS (Page Size)** | 0=4KB 页，1=4MB 页   |
| **G (Global)**     | 1=切换 CR3 时不刷新 TLB |

---

## 4. 页表项 (PTE) 结构

```c
typedef union PTE {
    uint32_t pointer;
    struct {
        uint32_t p          : 1;   // Present
        uint32_t rw         : 1;   // Read/Write
        uint32_t us         : 1;   // User/Supervisor
        uint32_t pwt        : 1;   // Page Write-Through
        uint32_t pcd        : 1;   // Page Cache Disable
        uint32_t a          : 1;   // Accessed
        uint32_t d          : 1;   // Dirty
        uint32_t pat        : 1;   // Page Attribute Table
        uint32_t g          : 1;   // Global
        uint32_t avail      : 3;   // OS 可用
        uint32_t page_base_addr : 20; // 物理页框地址 [31:12]
    } __attribute__((packed));
} PTE_t;
```

**位字段布局**：

```
  31                   12 11  9 8 7 6 5 4 3 2 1 0
 ┌───────────────────────┬─────┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
 │ Page Frame Addr[31:12]│Avail│G│0│D│A│C│W│U│R│P│
 └───────────────────────┴─────┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
```

---

## 5. Checkpoint 1 内存布局

### 5.1 需要映射的区域

```
物理内存布局：
┌───────────────────────────────────────────────────┐
│ 0x00000000 - 0x000FFFFF │ 低端内存 (1MB)           │
│   0x000B8000            │   VGA 视频内存           │
├───────────────────────────────────────────────────┤
│ 0x00100000 - 0x003FFFFF │ 扩展内存 (1-4MB)         │
├───────────────────────────────────────────────────┤
│ 0x00400000 - 0x007FFFFF │ 内核 (4-8MB)            │
├───────────────────────────────────────────────────┤
│ 0x00800000 - ...        │ 用户程序 (CP4 使用)       │
└───────────────────────────────────────────────────┘
```

### 5.2 Checkpoint 1 映射方案

```
页目录：
┌─────────────────────────────────────────────────────────┐
│ PDE[0]      │ 4KB 页       │ → 页表 → 0-4MB (包含视频内存) │
│ PDE[1]      │ 4MB 页       │ → 直接映射 4-8MB (内核)      │
│ PDE[2-1023] │ Not Present  │                            │
└─────────────────────────────────────────────────────────┘

为什么这样设计？
- 视频内存 (0xB8000) 只需要 4KB，用 4KB 页精确映射
- 内核代码很大 (4MB)，用 4MB 大页减少 TLB 压力
```

### 5.3 视频内存地址计算

```
视频内存虚拟地址：0x000B8000

拆分：
  31-22 (DIR):    0000 0000 00 = 0    → PDE[0]
  21-12 (TABLE):  00 1011 1000 = 0xB8 = 184 → PTE[184]
  11-0 (OFFSET):  0000 0000 0000 = 0

所以：
  页目录第 0 项 → 页表
  页表第 184 项 → 物理地址 0xB8000

0xB8000 / 4096 = 184 ✓
```

### 5.4 内核地址计算

```
内核虚拟地址：0x00400000 (4MB)

拆分：
  31-22 (DIR):    0000 0000 01 = 1    → PDE[1]

PDE[1] 使用 4MB 大页，直接映射到物理地址 4MB

page_base_addr = 0x00400000 >> 22 = 1
```

---

## 6. paging.c 代码详解

### 6.1 全局变量

```c
// 页目录物理地址，用于加载到 CR3
uint32_t page_dir_addr;

// 页目录数组 (4KB 对齐)
PD_t page_directory_array[NUMBER_PROCESS] __attribute__((aligned(four_KB)));

// 页表数组 (4KB 对齐)
PT_t page_table_array[NUMBER_PROCESS] __attribute__((aligned(four_KB)));
```

**为什么需要4KB对齐？**

CR3寄存器只存储页目录地址的高20位（低 12 位为 0），所以页目录必须4KB对齐。

### 6.2 set_up_PD_PT() 详解

```c
void set_up_PD_PT() {
    int i;

    // ========== 第一步：初始化页表 ==========
    for (i = 0; i < NUMBER_ENTRIES; i++) {
        // 视频内存及其备份 (0xB8, 0xB9, 0xBA, 0xBB)
        if (i >= VIDEO_ADDR && i <= VIDEO_ADDR + 3) {
            page_table_array[0].page_table[i].p = 1;  // Present
        } else {
            page_table_array[0].page_table[i].p = 0;  // Not Present
        }

        page_table_array[0].page_table[i].rw = 1;   // 可读写
        page_table_array[0].page_table[i].us = 0;   // 仅内核
        page_table_array[0].page_table[i].pwt = 0;  // Write-back
        page_table_array[0].page_table[i].pcd = 0;  // 允许缓存
        page_table_array[0].page_table[i].a = 0;    // 未访问
        page_table_array[0].page_table[i].d = 0;    // 未写入
        page_table_array[0].page_table[i].pat = 0;
        page_table_array[0].page_table[i].g = 0;    // 非全局
        page_table_array[0].page_table[i].avail = 0;

        // 恒等映射：虚拟地址 = 物理地址
        // 页框地址 = 索引 (因为每个页框 4KB)
        page_table_array[0].page_table[i].page_base_addr = i;
    }

    // ========== 第二步：设置 PDE[0] - 4KB 页 ==========
    page_directory_array[0].page_directory[0].kb.p = 1;    // Present
    page_directory_array[0].page_directory[0].kb.rw = 1;   // 可读写
    page_directory_array[0].page_directory[0].kb.us = 0;   // 仅内核
    page_directory_array[0].page_directory[0].kb.pwt = 0;
    page_directory_array[0].page_directory[0].kb.pcd = 0;
    page_directory_array[0].page_directory[0].kb.a = 0;
    page_directory_array[0].page_directory[0].kb.reserved = 0;
    page_directory_array[0].page_directory[0].kb.ps = 0;   // 4KB 页
    page_directory_array[0].page_directory[0].kb.g = 0;
    page_directory_array[0].page_directory[0].kb.avail = 0;

    // 页表地址（右移 12 位得到高 20 位）
    page_directory_array[0].page_directory[0].kb.page_table_base_addr =
        ((uint32_t)page_table_array[0].page_table >> shift);

    // ========== 第三步：设置 PDE[1] - 4MB 页（内核）==========
    page_directory_array[0].page_directory[1].mb.p = 1;    // Present
    page_directory_array[0].page_directory[1].mb.rw = 1;   // 可读写
    page_directory_array[0].page_directory[1].mb.us = 0;   // 仅内核
    page_directory_array[0].page_directory[1].mb.pwt = 0;
    page_directory_array[0].page_directory[1].mb.pcd = 0;
    page_directory_array[0].page_directory[1].mb.a = 0;
    page_directory_array[0].page_directory[1].mb.d = 0;
    page_directory_array[0].page_directory[1].mb.ps = 1;   // 4MB 页
    page_directory_array[0].page_directory[1].mb.g = 1;    // 全局页
    page_directory_array[0].page_directory[1].mb.avail = 0;
    page_directory_array[0].page_directory[1].mb.pat = 0;
    page_directory_array[0].page_directory[1].mb.reserved = 0;

    // 4MB 页地址（右移 22 位得到高 10 位）
    // 0x400000 >> 22 = 1
    page_directory_array[0].page_directory[1].mb.page_base_addr = 1;

    // ========== 第四步：其余 PDE 设为 Not Present ==========
    for (i = 2; i < NUMBER_ENTRIES; i++) {
        page_directory_array[0].page_directory[i].mb.p = 0;  // Not Present
        // ... 其他字段初始化 ...
    }
}
```

### 6.3 enable_paging() 详解

```c
void enable_paging() {
    // 保存页目录物理地址
    page_dir_addr = (uint32_t)(&page_directory_array[0]);

    asm volatile (
        // ===== 第一步：设置 CR3 (页目录基址) =====
        "movl page_dir_addr, %%eax;"
        "andl $0xFFFFFFE7, %%eax;"    // 清除 PCD 和 PWT 位
        "movl %%eax, %%cr3;"

        // ===== 第二步：设置 CR4 (启用 PSE) =====
        "movl %%cr4, %%eax;"
        "orl $0x00000010, %%eax;"     // 设置 PSE 位 (bit 4)
        "movl %%eax, %%cr4;"          // 启用 4MB 页支持

        // ===== 第三步：设置 CR0 (启用分页) =====
        "movl %%cr0, %%eax;"
        "orl $0x80000000, %%eax;"     // 设置 PG 位 (bit 31)
        "movl %%eax, %%cr0;"          // 启用分页

        :                             // 无输出
        :                             // 无输入
        : "%eax", "cc"                // 破坏的寄存器
    );
}
```

### 6.4 flush_TLB() 详解

```c
void flush_TLB() {
    asm volatile (
        "mov %%cr3, %%eax;"    // 读取 CR3
        "mov %%eax, %%cr3;"    // 写回 CR3
        :::"%eax"
    );
}
```

**为什么这样能刷新 TLB？**

写入 CR3 会使 CPU 认为页目录改变了，自动刷新非全局（G=0）的 TLB 表项。

#### GCC 内联汇编语法详解

这段代码使用了 **GCC 内联汇编 (Inline Assembly)**，让我们详细分析。

**术语澄清：GCC内联汇编 ≠ 新的汇编语法**

```
┌─────────────────────────────────────────────────────────────────┐
│  实际上只有两种汇编语法：                                           │
│                                                                 │
│  • Intel 语法：mov eax, cr3    （目的在前，源在后）                  │
│  • AT&T 语法： mov %cr3, %eax  （源在前，目的在后）                  │
│                                                                 │
│  "GCC内联汇编"不是第三种汇编语法，而是指：                            │
│  在 C 语言中嵌入汇编的「包装格式」                                   │
└─────────────────────────────────────────────────────────────────┘

具体来说：

asm volatile (
    "mov %%cr3, %%eax"    ← 里面用的是 AT&T 语法
    :                      ← 这些冒号分隔的部分
    :                      ← 是 GCC 的 C 包装语法
    : "%eax"               ← 不是汇编语法
);

┌─────────────────────────────────────────────────────────────────┐
│  为什么需要 %% ？                                                 │
│                                                                 │
│  这是 GCC 内联汇编的转义规则：                                      │
│                                                                 │
│  • 普通 AT&T 汇编文件（.S）中：%eax                                │
│  • GCC 内联汇编中：         %%eax                                 │
│                                                                 │
│  因为 GCC 用 %0, %1 表示操作数占位符，                              │
│  所以真正的寄存器需要用 %% 转义                                     │
└─────────────────────────────────────────────────────────────────┘

术语总结：

| 术语         | 含义                        |
|-------------|---------------------------|
| Intel 语法   | 汇编指令格式（目的在前）       |
| AT&T 语法    | 汇编指令格式（源在前）         |
| GCC 内联汇编 | C 语言嵌入汇编的包装格式       |
|             | （内部使用 AT&T 语法）        |
```

**为什么要加 volatile？**

```
┌─────────────────────────────────────────────────────────────────┐
│  volatile 告诉编译器：不要优化这段汇编代码                           │
└─────────────────────────────────────────────────────────────────┘

问题场景（没有 volatile）：

void flush_TLB() {
    asm (
        "mov %%cr3, %%eax;"
        "mov %%eax, %%cr3;"
        :::"%eax"
    );
}

编译器看到这段代码会想：
  - 读CR3到eax
  - 把eax写回CR3
  - 值没变？这是无用操作，删掉 ← 优化掉了

┌─────────────────────────────────────────────────────────────────┐
│  关键：写入 CR3 的「副作用」是刷新 TLB                               │
│                                                                 │
│  编译器不知道：                                                    │
│  - mov cr3, eax 会触发CPU刷新TLB缓存                          │
│  - 这个"副作用"才是我们真正想要的                                   │
│                                                                 │
│  编译器只看到：读出来又写回去，值没变 → 删掉                          │
│  但实际上：这个操作会清空TLB                                     │
└─────────────────────────────────────────────────────────────────┘

加 volatile 后：

asm volatile (...)   // 告诉编译器：这段代码有副作用，不能删

| 情况           | 没有 volatile | 有 volatile |
|---------------|--------------|-------------|
| 看起来无效的代码 | 可能被删除    | 保留         |
| 代码顺序        | 可能被重排    | 保持原顺序   |
| 重复调用        | 可能合并成一次 | 每次都执行   |

类比：访问硬件寄存器

volatile int* status = (volatile int*)0xB8000;
*status;  // 看起来没用，但实际上会触发硬件读取
          // 不加 volatile，编译器可能删掉这行
```

**基本语法格式：**

```c
asm volatile (
    "汇编指令"
    : 输出操作数
    : 输入操作数
    : 破坏描述（clobber list）
);
```

**三个冒号 `:::` 是什么意思？**

```
flush_TLB 中的写法：

asm volatile (
    "mov %%cr3, %%eax;"
    "mov %%eax, %%cr3;"
    :::"%eax"              ← 三个冒号连在一起
);

┌─────────────────────────────────────────────────────────────────┐
│  三个冒号分隔四个部分：                                             │
│                                                                 │
│  asm volatile (                                                 │
│      "汇编指令"                                                   │
│      : 输出操作数      ← 第一个冒号后（这里为空）                    │
│      : 输入操作数      ← 第二个冒号后（这里为空）                    │
│      : 破坏描述        ← 第三个冒号后                              │
│  );                                                             │
└─────────────────────────────────────────────────────────────────┘

所以 :::"%eax" 等价于：

asm volatile (
    "mov %%cr3, %%eax;"
    "mov %%eax, %%cr3;"
    :           // 输出：空（无返回值）
    :           // 输入：空（无参数）
    : "%eax"    // 破坏：eax 被修改
);

| 部分           | 内容     | 含义                |
|---------------|---------|---------------------|
| 第一个 : 之后  | （空）   | 无输出操作数         |
| 第二个 : 之后  | （空）   | 无输入操作数         |
| 第三个 : 之后  | "%eax"  | eax 寄存器被修改     |

为什么要声明 "%eax" 被破坏？

告诉编译器：这段汇编修改了 eax。
如果编译器之前在 eax 里存了重要的值，它需要先保存到别处！
```

**为什么要先读 CR3 再写回去？**

```
┌─────────────────────────────────────────────────────────────────┐
│  flush_TLB() 的目的：只刷新 TLB，不更换页目录                       │
└─────────────────────────────────────────────────────────────────┘

两种场景对比：

| 场景        | 目的               | CR3 值      |
|------------|-------------------|-------------|
| 进程切换    | 换页目录 + 刷 TLB   | CR3 改成新值 |
| flush_TLB() | 只刷 TLB，不换页目录 | CR3 值不变   |

flush_TLB() 的使用场景：

  同一个进程内，修改了页表映射，需要刷新 TLB

  例如：
    1. 修改某个 PTE 的权限（只读 → 可写）
    2. 重新映射某个虚拟地址到新的物理页

  此时：
    - 页目录没变，还是当前进程的
    - 但 TLB 缓存了旧的映射，需要刷新

为什么要读出来再写回去：

  mov %%cr3, %%eax   // 读 CR3（当前页目录地址）
  mov %%eax, %%cr3   // 写回同一个值
                     // 值没变，但「写 CR3」这个动作触发 TLB 刷新

如果不读直接写：

  mov ???, %%cr3     // ← 写什么？你不知道当前 CR3 是多少！

总结：

  flush_TLB() = 保持 CR3 不变，只触发刷新动作

  读 CR3 → 写回 CR3
           └── 值没变，但写入动作触发 TLB 刷新
```

**进程切换时的代码不同：**

```c
// flush_TLB()：只刷新 TLB，不换页目录
void flush_TLB() {
    asm volatile (
        "mov %%cr3, %%eax;"   // 读当前值
        "mov %%eax, %%cr3;"   // 写回同一个值
        :::"%eax"
    );
}

// 进程切换：写入新的 CR3
void switch_to_process(uint32_t new_page_dir) {
    asm volatile (
        "mov %0, %%cr3"       // 直接写入新值
        :                     // 无输出
        : "r"(new_page_dir)   // 输入：新页目录地址
    );
}
```

**对比：**

| 操作          | CR3 值 | 代码     | 原因          |
|-------------|-------|--------|-------------|
| flush_TLB() | 不变    | 读 → 写回 | 不知道当前值，需要先读 |
| 进程切换        | 改成新值  | 直接写新值  | 已知新进程的页目录地址 |

**逐部分解析：**

```
┌─────────────────────────────────────────────────────────────────┐
│  asm volatile (                                                 │
│      "mov %%cr3, %%eax;"   // 汇编指令 1                         │
│      "mov %%eax, %%cr3;"   // 汇编指令 2                         │
│      :                     // 输出操作数（空）                    │
│      :                     // 输入操作数（空）                    │
│      : "%eax"              // 破坏描述：eax 被修改               │
│  );                                                             │
└─────────────────────────────────────────────────────────────────┘
```

**为什么有两个 %% ？**

```
┌─────────────────────────────────────────────────────────────────┐
│  GCC 内联汇编中，% 有特殊含义（用于引用操作数）                     │
│                                                                 │
│  %0, %1, %2 ... = 引用输出/输入操作数                            │
│                                                                 │
│  所以要表示真正的寄存器名，需要用 %% 转义：                        │
│                                                                 │
│  %%eax = 寄存器 eax    ✓                                        │
│  %%cr3 = 寄存器 cr3    ✓                                        │
│  %eax  = 错误会被解释为操作数引用                               │
└─────────────────────────────────────────────────────────────────┘
```

**各部分详解：**

| 部分         | 作用                | 示例                             |
|------------|-------------------|--------------------------------|
| `asm`      | 告诉编译器这是内联汇编       | -                              |
| `volatile` | 禁止编译器优化这段代码       | 即使看起来没用也不能删除                   |
| 汇编指令       | AT&T 语法（源在前，目的在后） | `mov %%cr3, %%eax` = cr3 → eax |
| 输出操作数      | 把结果存到 C 变量        | `"=r"(result)`                 |
| 输入操作数      | 把 C 变量作为输入        | `"r"(value)`                   |
| 破坏描述       | 告诉编译器哪些寄存器被修改     | `"%eax"`, `"memory"`, `"cc"`   |

**AT&T vs Intel 语法：**

```
AT&T (GCC 默认):   mov  源, 目的     mov %%cr3, %%eax  (cr3 → eax)
Intel (NASM):      mov  目的, 源     mov eax, cr3      (cr3 → eax)
```

**更多示例：**

```c
// 示例 1：读取 CR2（有输出）
uint32_t get_cr2() {
    uint32_t result;
    asm volatile (
        "mov %%cr2, %0"      // %0 引用第一个操作数（result）
        : "=r"(result)       // 输出：result = cr2
        :                    // 无输入
        :                    // 无破坏
    );
    return result;
}

// 示例 2：设置 CR3（有输入）
void set_cr3(uint32_t value) {
    asm volatile (
        "mov %0, %%cr3"      // %0 引用第一个操作数（value）
        :                    // 无输出
        : "r"(value)         // 输入：value
        :                    // 无破坏
    );
}
```

**约束字符速查表：**

| 约束  | 含义        |
|-----|-----------|
| `r` | 任意通用寄存器   |
| `a` | eax 寄存器   |
| `b` | ebx 寄存器   |
| `c` | ecx 寄存器   |
| `d` | edx 寄存器   |
| `m` | 内存操作数     |
| `i` | 立即数       |
| `=` | 只写（输出）    |
| `+` | 读写（输入+输出） |

**破坏描述常用值：**

| 值          | 含义           |
|------------|--------------|
| `"%eax"`   | eax 寄存器被修改   |
| `"memory"` | 内存被修改        |
| `"cc"`     | 条件码/标志寄存器被修改 |

---

## 7. 控制寄存器详解

x86 有多个控制寄存器，用于控制 CPU 的各种模式和功能：

| 寄存器     | 名称           | 作用                     |
|---------|--------------|------------------------|
| **CR0** | 控制寄存器 0      | 控制 CPU 模式（保护模式、分页开关）   |
| **CR1** | -            | 保留未使用                  |
| **CR2** | 页错误地址        | 发生 #PF 时，保存引起错误的虚拟地址   |
| **CR3** | 页目录基址 (PDBR) | 存储页目录的物理地址             |
| **CR4** | 控制寄存器 4      | 扩展功能控制（如 PSE 启用 4MB 页） |

### 7.1 CR0 - 控制寄存器 0

```
  31 30 29          18 16 15           5 4 3 2 1 0
 ┌──┬──┬──┬─────────┬──┬──┬────────────┬─┬─┬─┬─┬──┐
 │PG│CD│NW│         │AM│  │            │NE│ET│TS│EM│PE│
 └──┴──┴──┴─────────┴──┴──┴────────────┴─┴─┴─┴─┴──┘
  │                                              │
  │                                              └── PE: Protection Enable
  └── PG: Paging Enable (启用分页)

重要位：
- PG (bit 31): 1=启用分页，0=禁用
- PE (bit 0): 1=保护模式，0=实模式
```

### 7.2 CR3 - 页目录基址寄存器 (PDBR)

CR3 也叫 **PDBR (Page Directory Base Register)**，告诉 CPU 页目录在物理内存的哪个位置。

```
  31                  12 11    5 4 3 2   0
 ┌──────────────────────┬───────┬─┬─┬─────┐
 │  Page Directory Base │  IGN  │P│P│ IGN │
 │      (高 20 位)       │       │C│W│     │
 │                      │       │D│T│     │
 └──────────────────────┴───────┴─┴─┴─────┘
  │                              │ │
  │                              │ └── PWT: 页目录的缓存写策略
  │                              └──── PCD: 页目录是否禁用缓存
  └── 页目录物理地址（必须 4KB 对齐，所以低 12 位为 0）
```

**CR3 的作用：**

```
┌─────────────────────────────────────────────────────────────────┐
│  CPU 做地址转换时：                                               │
│                                                                 │
│  1. 从 CR3 读取页目录的物理地址                                     │
│  2. 用虚拟地址的 DIR 索引查页目录                                   │
│  3. 继续查页表...                                                 │
│                                                                 │
│  如果没有 CR3，CPU 不知道页目录在哪里                                │
└─────────────────────────────────────────────────────────────────┘
```

**CR3 的特殊性：**

```
┌─────────────────────────────────────────────────────────────────┐
│  1. 写入 CR3 会自动刷新 TLB                                       │
│                                                                 │
│     mov eax, 新页目录地址                                         │
│     mov cr3, eax      ← 此时 CPU 清空 TLB 缓存（非全局页）          │
│                                                                 │
│  2. 每个进程有自己的页目录                                          │
│                                                                 │
│     进程切换时：                                                  │
│     - 保存旧进程的 CR3                                            │
│     - 加载新进程的 CR3                                            │
│     → 地址空间自动切换                                             │
│                                                                 │
│  3. CR3 存的是物理地址，不是虚拟地址                                 │
│                                                                 │
│     因为查页目录是地址转换的第一步，                                 │
│     此时还没有虚拟→物理的映射，必须直接用物理地址                      │
└─────────────────────────────────────────────────────────────────┘
```

### 7.3 CR4 - 控制寄存器 4

```
  31                                    5 4 3 2 1 0
 ┌──────────────────────────────────────┬─┬─┬─┬─┬─┐
 │                                      │P│D│T│P│V│
 │                                      │S│E│S│V│M│
 │                                      │E│ │D│I│E│
 └──────────────────────────────────────┴─┴─┴─┴─┴─┘
                                         │
                                         └── PSE (bit 4): Page Size Extension
                                             1=允许 4MB 页

必须设置 PSE=1 才能使用 4MB 大页
```

### 7.4 CR2 - 页错误线性地址

```
当发生页错误 (#PF) 时，CR2 保存引起错误的虚拟地址。

用于调试：
    uint32_t fault_addr;
    asm volatile("mov %%cr2, %0" : "=r"(fault_addr));
    printf("Page fault at address: 0x%x\n", fault_addr);
```

---

## 8. 地址转换示例

### 8.1 示例 1：访问视频内存

```
虚拟地址：0x000B8000

步骤1：拆分地址
  二进制：0000 0000 0000 1011 1000 0000 0000 0000
  DIR    = 0000000000 (10位) = 0
  TABLE  = 0010111000 (10位) = 184 (0xB8)
  OFFSET = 000000000000 (12位) = 0

步骤2：查页目录
  CR3 → 页目录
  页目录[0] → 页表地址 (PDE.ps = 0，使用页表)

步骤3：查页表
  页表[184] → 物理页框地址
  page_base_addr = 184 (0xB8)
  物理页框 = 0xB8 << 12 = 0xB8000

步骤4：计算物理地址
  物理地址 = 0xB8000 + 0 = 0xB8000 ✓

虚拟地址 0xB8000 → 物理地址 0xB8000 (恒等映射)
```

### 8.2 示例 2：访问内核代码

```
虚拟地址：0x00401234

步骤 1：拆分地址
  二进制：0000 0000 0100 0000 0001 0010 0011 0100
  DIR    = 0000000001 (10位) = 1
  剩余   = 00 0000 0001 0010 0011 0100 = 0x1234

步骤 2：查页目录
  页目录[1] → PDE.ps = 1 (4MB 大页)
  page_base_addr = 1
  物理基址 = 1 << 22 = 0x400000

步骤 3：计算物理地址（4MB 页）
  对于 4MB 页，直接用低 22 位作为偏移
  偏移 = 0x00401234 & 0x3FFFFF = 0x1234
  物理地址 = 0x400000 + 0x1234 = 0x401234 ✓

虚拟地址 0x401234 → 物理地址 0x401234 (恒等映射)
```

---

## 9. 页错误 (#PF) 处理

### 9.1 何时发生页错误

1. **页不存在**：PDE 或 PTE 的 P 位为 0
2. **权限违规**：用户态访问内核页 (U/S=0)
3. **写只读页**：写入 R/W=0 的页
4. **保留位设置**：PDE/PTE 的保留位不为 0

### 9.2 页错误的错误码

```
  31                              5 4 3 2 1 0
 ┌─────────────────────────────────┬─┬─┬─┬─┬─┐
 │            Reserved             │I│R│U│W│P│
 └─────────────────────────────────┴─┴─┴─┴─┴─┘
                                    │ │ │ │ │
                                    │ │ │ │ └── P: 0=页不存在, 1=保护违规
                                    │ │ │ └──── W: 0=读访问, 1=写访问
                                    │ │ └────── U: 0=内核态, 1=用户态
                                    │ └──────── R: 0=正常, 1=保留位错误
                                    └────────── I: 0=数据访问, 1=取指令
```

### 9.3 调试页错误

```c
void page_fault_handler(uint32_t error_code) {
    uint32_t fault_addr;
    asm volatile("mov %%cr2, %0" : "=r"(fault_addr));

    printf("Page Fault!\n");
    printf("Fault Address: 0x%x\n", fault_addr);

    if (error_code & 0x1) {
        printf("  - Protection violation\n");
    } else {
        printf("  - Page not present\n");
    }

    if (error_code & 0x2) {
        printf("  - Write access\n");
    } else {
        printf("  - Read access\n");
    }

    if (error_code & 0x4) {
        printf("  - User mode\n");
    } else {
        printf("  - Kernel mode\n");
    }
}
```

---

## 10. TLB (Translation Lookaside Buffer)

### 10.1 什么是TLB？

**TLB** 中文称为转换旁路缓冲区（转译后备缓冲器、快表），是中央处理器（CPU）内存管理单元（MMU）中的一种小型硬件高速缓存，
专门用于存储虚拟地址到物理地址的快速映射，显著加快内存访问速度，避免了每次访问内存都需要先查找较慢的分页表，是现代处理器（如x86）中不可或缺的组件。

**为什么需要TLB？**

```
没有TLB时，每次访问内存都要查页表：

访问虚拟地址0x401234
    │
    ├─► 读内存：查页目录 (第1次访问内存)
    │
    ├─► 读内存：查页表   (第2次访问内存)
    │
    └─► 读内存：读数据   (第3次访问内存)

一次数据访问 = 3次内存访问，太慢了
```

**有TLB后：**

```
第一次访问虚拟地址 0x401234（TLB 未命中）：

    ├─► 读内存：查页目录    (第1次)
    ├─► 读内存：查页表      (第2次)
    ├─► 缓存到 TLB：0x401 → 0x801
    └─► 读内存：读数据      (第3次)

之后再访问 0x401xxx（TLB 命中）：

    ├─► 查 TLB：0x401 → 0x801  ✓ 命中
    └─► 读内存：读数据      (只需1次)

| 情况        | 内存访问次数                 |
|------------|----------------------------|
| TLB未命中   | 3次（页目录 + 页表 + 数据）    |
| TLB命中     | 1次（直接读数据）             |

因为程序有局部性（经常访问相同或相邻的地址），
所以TLB命中率通常>95%，绝大多数访问都只需要1次内存访问。
```

**TLB 缓存结构：**

```
TLB 中存的是 虚拟页号 → 物理页框号（不是完整地址）：

┌─────────────────────────────────────┐
│                TLB                  │
├─────────────────┬───────────────────┤
│    Page No.     │    Frame No.      │
├─────────────────┼───────────────────┤
│    0x401        │    0x801          │ ← 页号，不是地址
│    0x402        │    0x305          │
│    0x0B8        │    0x0B8          │
│    ...          │    ...            │
└─────────────────┴───────────────────┘

计算物理地址时：

虚拟地址 0x401234
         ├──├──┤
         页号 偏移
        0x401 0x234

TLB 查找：0x401 → 0x801（页框号）

物理地址 = 页框号 << 12 + 偏移
         = 0x801 × 4096 + 0x234
         = 0x801000 + 0x234
         = 0x801234
```

**为什么存页号而不是地址？**

| 存储内容 | 位数   | 原因            |
|------|------|---------------|
| 页框号  | 20 位 | 节省空间          |
| 页框地址 | 32 位 | 浪费，低 12 位总是 0 |

**为什么页框地址低12位总是0？**

因为页框是4KB对齐的：

```
4KB = 4096 = 2^12

物理内存被划分成连续的4KB块（页框）：

┌────────────────┐ 0x00000000  ← 页框 0 起始
│    Frame 0     │
│    (4KB)       │
├────────────────┤ 0x00001000  ← 页框 1 起始
│    Frame 1     │
│    (4KB)       │
├────────────────┤ 0x00002000  ← 页框 2 起始
│    Frame 2     │
│    (4KB)       │
├────────────────┤ 0x00003000
│    ...         │
├────────────────┤ 0x00801000  ← 页框 0x801 起始
│    Frame 0x801 │
└────────────────┘

每个页框的起始地址：
  页框 0:     0x00000000 = ....0000 0000 0000 0000
  页框 1:     0x00001000 = ....0001 0000 0000 0000
  页框 2:     0x00002000 = ....0010 0000 0000 0000
  页框 0x801: 0x00801000 = ....0001 0000 0000 0000
                              └──────────────────┘
                                  低 12 位总是 0

原因：
  页框起始地址 = 页框号 × 4096
               = 页框号 × 2^12
               = 页框号 << 12

  左移12位，低12位自然变成 0
```

| 概念   | 值          | 关系        |
|------|------------|-----------|
| 页框号  | 0x801      | 高 20 位    |
| 页框地址 | 0x00801000 | 页框号 << 12 |

低12位不存任何信息，存了也是浪费，所以只存高20位（页框号）就够了。

**TLB vs 页表：**

| 特性 | TLB        | 页表         |
|----|------------|------------|
| 位置 | CPU 内部     | 内存中        |
| 速度 | 极快（1周期）    | 慢（几十~几百周期） |
| 容量 | 很小（几十~几百条） | 很大（可覆盖4GB） |
| 作用 | 缓存常用映射     | 存储完整映射     |

**为什么修改页表后要刷新TLB？**

```
修改前：
  页表：虚拟页 0x401 → 物理页 0x801
  TLB： 虚拟页 0x401 → 物理页 0x801  ← 缓存了旧映射

修改页表：
  页表：虚拟页 0x401 → 物理页 0x900  ← 改成新映射

如果不刷新TLB：
  CPU访问 0x401xxx
  TLB命中：返回 0x801xxx  ← 错误用的还是旧映射

刷新TLB后：
  TLB清空，重新从页表加载
  CPU访问 0x401xxx → 0x900xxx  ✓ 正确
```

**为什么写CR3会刷新TLB？**

```
┌─────────────────────────────────────────────────────────────────┐
│  这是x86 CPU的硬件设计规定（Intel手册）：                            │
│                                                                 │
│  写入CR3时，CPU硬件自动执行：                                       │
│    1. 加载新的页目录基址                                           │
│    2. 刷新TLB中所有非全局（G=0）的条目                              │
│                                                                 │
│  这是CPU电路层面的行为，无法绕过                                     │
└─────────────────────────────────────────────────────────────────┘

为什么这样设计？考虑进程切换场景：

进程A (CR3 = 0x1000000)               进程B (CR3 = 0x2000000)
┌──────────────────────────┐          ┌───────────────────────────┐
│ virtual addr 0x400000    │          │ virtual addr 0x400000     │
│ → physical addr 0x800000 │          │ → physical addr 0x900000  │
└──────────────────────────┘          └───────────────────────────┘

TLB缓存了：0x400000 → 0x800000（进程A的映射）

切换到进程B时：
  mov eax, 0x2000000
  mov cr3, eax       ← 必须清空TLB

如果不清空TLB：
  进程B访问 0x400000
  TLB命中：返回 0x800000（进程A的物理页）
  → 进程B读到了进程A的数据
  → 安全漏洞 + 数据错误

所以 CPU 硬件强制：写CR3 = 刷新TLB
```

**进程切换时TLB的变化：**

```
进程A运行中
    │
    │ TLB缓存了进程A的映射
    │
    ▼
进程切换（OS 操作）
    │
    │ mov eax, 进程B的页目录地址
    │ mov cr3, eax    ← 写入CR3，清空TLB（只清空一次）
    │
    ▼
进程B开始运行
    │
    │ TLB是空的
    │ 进程B访问内存时，TLB未命中，重新从进程B的页表加载
    │ 逐渐缓存进程B的映射
    │
    ▼
进程B运行中，TLB缓存的是进程B的映射

| 时刻             | TLB 内容                  |
|-----------------|---------------------------|
| 进程A运行中       | 进程A的映射                |
| 切换时（写 CR3）  | 清空                       |
| 进程B刚开始       | 空的，逐渐填充              |
| 进程B运行中       | 进程B的映射                |

注意：进程切换时，只有OS执行一次mov cr3，不是A清空一次、B再清空一次。
```

**上下文切换 (Context Switch) 包含哪些内容？**

```
1. CPU 寄存器
┌─────────────────────────────────────────────────────────────────┐
│  通用寄存器：EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP               │
│  指令指针：  EIP（下一条要执行的指令地址）                            │
│  标志寄存器：EFLAGS（状态标志、控制标志）                             │
│  段寄存器：  CS, DS, ES, FS, GS, SS                               │
└─────────────────────────────────────────────────────────────────┘

2. 内存管理相关
┌─────────────────────────────────────────────────────────────────┐
│  CR3：页目录基址（切换地址空间）                                     │
│  TLB：清空后重新加载（这是性能开销的主要来源）                         │
└─────────────────────────────────────────────────────────────────┘

3. 进程控制块 (PCB)
┌─────────────────────────────────────────────────────────────────┐
│  进程状态：运行、就绪、阻塞                                         │
│  进程ID：PID                                                     │
│  优先级                                                          │
│  打开的文件描述符                                                  │
│  信号处理信息                                                     │
└─────────────────────────────────────────────────────────────────┘
```

**上下文切换的开销：**

| 操作       | 开销              |
|----------|-----------------|
| 保存/恢复寄存器 | 小（几十个周期）        |
| 切换CR3    | 中（清空 TLB）       |
| TLB重新填充  | 大（后续多次 TLB 未命中） |
| CPU缓存失效  | 大（新进程数据不在缓存中）   |

**为什么频繁切换影响性能？**

```
主要原因不是保存/恢复寄存器，而是：

1. TLB清空 → 之后每次内存访问都要查页表（慢）
2. CPU缓存失效 → 新进程的数据不在缓存中（慢）

这两个"预热"过程消耗大量时间
```

**总结：**

```
┌─────────────────────────────────────────────────────────────────┐
│  TLB = 地址转换的缓存                                             │
│                                                                 │
│  • 加速：避免每次都查页表（命中率 > 95%）                            │
│  • 问题：页表改了，TLB 可能还是旧的                                 │
│  • 解决：修改页表后调用 flush_TLB() 刷新                            │
│  • 原理：写 CR3 触发 CPU 硬件自动刷新 TLB                           │
└─────────────────────────────────────────────────────────────────┘
```

### 10.2 何时刷新TLB？

| 情况     | 操作            |
|--------|---------------|
| 修改页表后  | 调用flush_TLB() |
| 进程切换   | 自动（切换 CR3）    |
| 修改单个映射 | INVLPG 指令     |

### 10.3 全局页 (G=1)

内核页设置G=1后，切换CR3时不会刷新这些TLB表项。

```c
// 内核页设为全局
page_directory_array[0].page_directory[1].mb.g = 1;
```

**好处**：进程切换时不需要重新加载内核映射。

---

## 11. 完整流程图

```
kernel.c: entry()
    │
    ▼
init_paging()
    │
    ├─► set_up_PD_PT()
    │       │
    │       ├─► 初始化页表 (1024 项)
    │       │     - PTE[0xB8-0xBB].p = 1 (视频内存)
    │       │     - 其他 PTE.p = 0
    │       │     - 恒等映射
    │       │
    │       ├─► 设置 PDE[0] (4KB 页)
    │       │     - 指向页表
    │       │     - ps = 0
    │       │
    │       ├─► 设置 PDE[1] (4MB 页，内核)
    │       │     - 直接映射 4MB
    │       │     - ps = 1, g = 1
    │       │
    │       └─► 设置 PDE[2-1023] = Not Present
    │
    └─► enable_paging()
            │
            ├─► CR3 = 页目录地址
            │
            ├─► CR4.PSE = 1 (启用 4MB 页)
            │
            └─► CR0.PG = 1 (启用分页)

    分页已启
    CPU 现在通过页表转换所有地址
```

---

## 12. 调试技巧

### 12.1 GDB查看分页结构

```bash
# 查看页目录
(gdb) print page_directory_array[0].page_directory[0]
(gdb) print page_directory_array[0].page_directory[1]

# 查看页表项
(gdb) print page_table_array[0].page_table[0xB8]

# 查看 CR 寄存器
(gdb) print $cr0
(gdb) print $cr3
(gdb) print $cr4

# 查看内存
(gdb) x/4x &page_directory_array
```

### 12.2 QEMU Monitor 查看分页

```bash
# 在 QEMU 中按 Ctrl+Alt+2 进入 monitor
(qemu) info tlb
(qemu) info mem
```

### 12.3 常见问题排查

| 问题       | 可能原因                  |
|----------|-----------------------|
| 页错误在地址 0 | 空指针解引用，PDE[0] 未设置     |
| 无法访问视频内存 | PTE[0xB8].p = 0       |
| 内核崩溃     | PDE[1] 未正确设置          |
| 无限重启     | CR4.PSE 未设置，但用了 4MB 页 |

---

## 13. 总结

| 概念         | 要点                               |
|------------|----------------------------------|
| **两级页表**   | 页目录 → 页表 → 物理页框                  |
| **地址拆分**   | DIR(10) + TABLE(10) + OFFSET(12) |
| **4KB 页**  | PDE.ps=0，通过页表映射                  |
| **4MB 页**  | PDE.ps=1，直接映射，需要 CR4.PSE=1       |
| **CR3**    | 页目录物理地址                          |
| **CR0.PG** | 启用分页                             |
| **TLB**    | 地址转换缓存，修改页表后需刷新                  |
| **页错误**    | CR2 保存错误地址，错误码指示原因               |

---

## 14. 与CP4的联系

Checkpoint 4 会添加：

1. **用户程序内存映射**
    - 虚拟地址 128MB → 物理地址 8MB/12MB/...
    - PDE[32] 映射用户程序

2. **remap() 函数使用**
    - 每次 execute() 调用 remap() 设置新映射
    - 每次 halt() 恢复父进程映射

3. **vidmap 系统调用**
    - 用户程序访问视频内存
    - 使用 remap_vid() 函数

---

**文档版本**：1.0
**最后更新**：2025-12-07
**相关文件**：

- `student-distrib/paging.c`
- `student-distrib/paging.h`
