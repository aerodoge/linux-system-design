# 调试技巧深度解析

## 概述

操作系统调试比普通程序调试更困难，因为：
- 没有 printf 之前无法输出
- 崩溃可能导致整个系统挂起
- 中断/异常会改变执行流程
- 内存错误可能导致"静默"失败

本文档总结 ECE 391 MP3 调试的实用技巧。

## 调试工具

### 1. QEMU + GDB

**启动调试**：

```bash
# 终端 1: 启动 QEMU，等待 GDB 连接
make debug

# 终端 2: 启动 GDB
gdb kernel
(gdb) target remote localhost:1234
(gdb) continue
```

**常用 GDB 命令**：

| 命令 | 缩写 | 功能 |
|-----|------|------|
| `break function` | `b` | 在函数设断点 |
| `break *0x12345` | `b` | 在地址设断点 |
| `continue` | `c` | 继续执行 |
| `step` | `s` | 单步（进入函数） |
| `next` | `n` | 单步（跳过函数） |
| `stepi` | `si` | 单步一条指令 |
| `print var` | `p` | 打印变量 |
| `print/x var` | `p/x` | 十六进制打印 |
| `x/10x addr` | | 查看内存（10个十六进制字） |
| `x/10i addr` | | 反汇编（10条指令） |
| `info registers` | `i r` | 查看寄存器 |
| `backtrace` | `bt` | 查看调用栈 |
| `layout src` | | 显示源码窗口 |
| `layout asm` | | 显示汇编窗口 |
| `layout regs` | | 显示寄存器窗口 |

### 2. printf 调试

最简单但有效的方法：

```c
// 在关键位置添加 printf
printf("execute_func: pid=%d, cmd=%s\n", new_pid, parsed_command);
printf("schedule: switching from %d to %d\n", running_term, next_term);
```

**注意**：
- printf 只在终端驱动初始化后可用
- 在 `sti()` 之前，printf 可能不完整显示

### 3. 显存直接写入

在 printf 不可用时（如早期启动阶段）：

```c
// 直接写入显存
char* video = (char*)0xB8000;
video[0] = 'A';  // 左上角显示 'A'
video[1] = 0x0F; // 白色

// 或者写入特定位置
void debug_char(int pos, char c) {
    char* video = (char*)0xB8000;
    video[pos * 2] = c;
    video[pos * 2 + 1] = 0x0F;
}

// 使用
debug_char(0, '1');   // 第一步完成
debug_char(1, '2');   // 第二步完成
```

### 4. 魔数标记

在关键数据结构中放入魔数，检测内存损坏：

```c
#define PCB_MAGIC 0xDEADBEEF

typedef struct pcb {
    uint32_t magic;  // 应该始终是 PCB_MAGIC
    // ... 其他字段
} pcb_t;

// 初始化时
pcb->magic = PCB_MAGIC;

// 使用时检查
void use_pcb(pcb_t* pcb) {
    if (pcb->magic != PCB_MAGIC) {
        printf("PCB corrupted!\n");
        while(1);  // 停止执行
    }
}
```

## 常见问题及调试方法

### 1. 三重故障 (Triple Fault)

**症状**：QEMU 不断重启或直接退出

**可能原因**：
- IDT 未正确设置
- 分页错误（页目录/页表配置错误）
- 栈溢出
- 无效的 GDT/TSS

**调试方法**：

```bash
# 启动 QEMU 时添加调试选项
qemu-system-i386 -d int,cpu_reset -no-reboot ...
```

这会在中断/异常和 CPU 重置时打印信息。

**逐步排查**：
```c
// 在 kernel.c 中逐步注释初始化代码
void entry(...) {
    clear();
    printf("1\n");  // 能看到说明 printf 工作

    initialize_IDT();
    printf("2\n");  // 能看到说明 IDT 没问题

    init_paging();
    printf("3\n");  // 能看到说明分页没问题

    // ...
}
```

### 2. 页错误 (Page Fault)

**症状**：触发异常 14，系统停止

**调试方法**：

```c
// 在页错误处理中打印信息
void page_fault_handler() {
    uint32_t fault_addr;
    asm volatile("movl %%cr2, %0" : "=r"(fault_addr));

    printf("Page Fault!\n");
    printf("Fault address: 0x%x\n", fault_addr);
    printf("Error code: 0x%x\n", error_code);

    // 解析错误码
    printf("  P=%d (page %spresent)\n",
           error_code & 1, (error_code & 1) ? "" : "not ");
    printf("  W/R=%d (%s)\n",
           (error_code >> 1) & 1, (error_code & 2) ? "write" : "read");
    printf("  U/S=%d (%s mode)\n",
           (error_code >> 2) & 1, (error_code & 4) ? "user" : "kernel");

    while(1);
}
```

**常见原因**：
- 访问未映射的地址
- 用户态访问内核页
- 写入只读页

### 3. 通用保护错误 (GPF, 异常 13)

**症状**：触发异常 13

**常见原因**：
- 段选择子无效
- 特权级违规
- 访问超出段限长

**调试**：
```c
void gpf_handler() {
    printf("General Protection Fault!\n");
    printf("Error code: 0x%x\n", error_code);
    // error_code 是段选择子（如果由段错误引起）

    // 打印当前 CS:EIP
    printf("CS=0x%x, EIP=0x%x\n", cs, eip);
}
```

### 4. 中断不触发

**症状**：键盘/RTC/PIT 中断不工作

**排查步骤**：

```c
// 1. 检查 IDT 是否正确设置
printf("IDT entry 0x21: 0x%x 0x%x\n",
       idt[0x21].val[0], idt[0x21].val[1]);

// 2. 检查 PIC 掩码
extern uint8_t master_mask, slave_mask;
printf("PIC masks: master=0x%x, slave=0x%x\n",
       master_mask, slave_mask);

// 3. 检查是否 sti() 了
uint32_t eflags;
asm volatile("pushfl; popl %0" : "=r"(eflags));
printf("IF flag: %d\n", (eflags >> 9) & 1);

// 4. 在中断处理函数入口添加调试
void keyboard_handler() {
    printf("KB interrupt!\n");  // 看是否执行到这里
    // ...
}
```

### 5. 系统调用不工作

**症状**：用户程序调用 read/write 等无响应或返回错误

**排查**：

```c
// 在 syscall_handler 入口添加调试
void syscall_handler() {
    printf("Syscall: num=%d, args=%x,%x,%x\n",
           eax, ebx, ecx, edx);
}

// 检查系统调用号
// EAX 应该是 1-10
if (eax < 1 || eax > 10) {
    printf("Invalid syscall number: %d\n", eax);
}

// 检查文件描述符
if (fd < 0 || fd > 7) {
    printf("Invalid fd: %d\n", fd);
}
```

### 6. 进程切换失败

**症状**：execute 后程序不运行，或切换后系统崩溃

**排查**：

```c
// 检查 PCB 设置
printf("PCB[%d]: esp=%x, ebp=%x, parent=%x\n",
       pid, pcb->curr_esp, pcb->curr_ebp, pcb->parent);

// 检查 TSS
printf("TSS: ss0=%x, esp0=%x\n", tss.ss0, tss.esp0);

// 检查页表映射
printf("Page dir[32]: %x\n", page_directory[32]);

// 在 iret 前打印栈内容
void debug_iret_stack() {
    uint32_t* esp;
    asm volatile("movl %%esp, %0" : "=r"(esp));
    printf("IRET stack:\n");
    printf("  EIP: 0x%x\n", esp[0]);
    printf("  CS:  0x%x\n", esp[1]);
    printf("  EFLAGS: 0x%x\n", esp[2]);
    printf("  ESP: 0x%x\n", esp[3]);
    printf("  SS:  0x%x\n", esp[4]);
}
```

### 7. 内存损坏

**症状**：数据莫名其妙变化，随机崩溃

**排查方法**：

```c
// 1. 使用魔数
#define STACK_CANARY 0xCAFEBABE

// 在栈底放金丝雀值
uint32_t* stack_bottom = (uint32_t*)(0x800000 - pid * 0x2000);
*stack_bottom = STACK_CANARY;

// 定期检查
void check_stack() {
    if (*stack_bottom != STACK_CANARY) {
        printf("Stack overflow detected for pid %d!\n", pid);
    }
}

// 2. 在关键操作前后打印数据
printf("Before memcpy: src=%x, dst=%x, n=%d\n", src, dst, n);
memcpy(dst, src, n);
printf("After memcpy\n");
```

## 调试特定模块

### 调试分页

```c
// 打印页目录项
void dump_page_directory() {
    int i;
    for (i = 0; i < 1024; i++) {
        if (page_directory[i] & 1) {  // Present
            printf("PDE[%d]: 0x%x\n", i, page_directory[i]);
        }
    }
}

// 虚拟地址到物理地址转换
uint32_t virt_to_phys(uint32_t virt) {
    uint32_t pde_idx = virt >> 22;
    uint32_t pte_idx = (virt >> 12) & 0x3FF;
    uint32_t offset = virt & 0xFFF;

    uint32_t pde = page_directory[pde_idx];
    if (!(pde & 1)) {
        printf("PDE not present!\n");
        return 0;
    }

    if (pde & 0x80) {  // 4MB page
        return (pde & 0xFFC00000) | (virt & 0x3FFFFF);
    }

    uint32_t* pt = (uint32_t*)(pde & 0xFFFFF000);
    uint32_t pte = pt[pte_idx];
    if (!(pte & 1)) {
        printf("PTE not present!\n");
        return 0;
    }

    return (pte & 0xFFFFF000) | offset;
}
```

### 调试文件系统

```c
// 列出所有文件
void list_files() {
    dentry_t dentry;
    int i = 0;
    while (read_dentry_by_index(i, &dentry) == 0) {
        printf("%d: %s (type=%d, inode=%d)\n",
               i, dentry.name, dentry.file_type, dentry.inode);
        i++;
    }
}

// 检查文件内容
void dump_file(const char* name) {
    dentry_t dentry;
    if (read_dentry_by_name(name, &dentry) != 0) {
        printf("File not found: %s\n", name);
        return;
    }

    uint8_t buf[100];
    int n = read_data(dentry.inode, 0, buf, 100);
    printf("First %d bytes of %s:\n", n, name);
    int i;
    for (i = 0; i < n; i++) {
        printf("%02x ", buf[i]);
        if ((i + 1) % 16 == 0) printf("\n");
    }
}
```

### 调试终端

```c
// 打印键盘缓冲区状态
void dump_keyboard_buffer() {
    printf("Keyboard buffer (%d chars): ", length_key);
    int i;
    for (i = 0; i < length_key; i++) {
        printf("%c", keyboard_buffer[i]);
    }
    printf("\n");
}

// 打印终端状态
void dump_term_info(int term_id) {
    printf("Terminal %d:\n", term_id);
    printf("  running_pid: %d\n", term[term_id].running_pid);
    printf("  cursor: (%d, %d)\n",
           term[term_id].cursor_x, term[term_id].cursor_y);
    printf("  vid_backup: 0x%x\n", term[term_id].vid_backup);
}
```

## QEMU 调试技巧

### 查看寄存器

```bash
# 在 QEMU 控制台 (Ctrl+Alt+2)
info registers
```

### 查看内存

```bash
# 查看物理内存
xp /10x 0xB8000

# 查看 GDT
info gdt

# 查看 IDT
info idt
```

### 单步调试

```bash
# 在 GDB 中
(gdb) si        # 单步一条指令
(gdb) ni        # 单步，跳过 call
(gdb) finish    # 执行到函数返回
```

### 条件断点

```bash
# 只在特定条件触发
(gdb) break schedule if next_term == 2
(gdb) break read_func if fd == 0
```

### 观察点

```bash
# 当变量改变时停止
(gdb) watch cur_pid
(gdb) watch *(int*)0x800000  # 监视内存地址
```

## 调试清单

遇到问题时，按此清单排查：

### 启动阶段问题

- [ ] GDT 是否正确加载？
- [ ] IDT 是否正确设置？
- [ ] 分页是否正确启用？
- [ ] PIC 是否初始化？
- [ ] 中断是否开启 (sti)？

### 中断问题

- [ ] IDT 入口是否正确？
- [ ] PIC 掩码是否正确？
- [ ] EOI 是否发送？
- [ ] 中断处理函数是否正确？

### 进程问题

- [ ] PCB 是否正确初始化？
- [ ] 页表是否正确设置？
- [ ] TSS esp0 是否正确？
- [ ] 用户栈是否正确设置？

### 系统调用问题

- [ ] 系统调用号是否正确？
- [ ] 参数是否正确传递？
- [ ] 文件描述符是否有效？
- [ ] 返回值是否正确？

## 总结

调试技巧：

| 技巧 | 适用场景 |
|-----|---------|
| GDB | 单步调试、查看变量 |
| printf | 快速定位问题区域 |
| 显存写入 | 早期启动阶段 |
| 魔数 | 检测内存损坏 |
| QEMU 控制台 | 查看硬件状态 |

调试心得：
1. **二分法定位** - 注释一半代码，确定问题在哪半
2. **最小复现** - 找到触发问题的最简单操作
3. **打印一切** - 怀疑的地方都加 printf
4. **检查假设** - 你认为正确的可能是错的
5. **读文档** - Intel 手册是最终权威
