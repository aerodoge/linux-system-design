# 键盘驱动深度解析

## 概述

键盘驱动是操作系统与用户交互的核心组件。当用户按下键盘时，键盘控制器产生中断，CPU 执行中断处理程序，将按键转换为字符并显示在屏幕上。

## 硬件基础

### PS/2 键盘接口

```
+-------------+          +-------------+          +-------------+
|   键盘      |  ------> |  键盘控制器  |  ------> |    CPU      |
| (物理设备)   |  扫描码   |   (8042)    |   IRQ1   | (中断处理)   |
+-------------+          +-------------+          +-------------+
                              |
                              v
                         端口 0x60 (数据)
                         端口 0x64 (状态/命令)
```

### 关键端口

| 端口   | 名称         | 功能        |
|------|------------|-----------|
| 0x60 | KB_DATA    | 读取扫描码     |
| 0x64 | KB_COMMAND | 读取状态/发送命令 |

### 中断号

键盘使用 **IRQ 1**，对应 IDT 中的中断向量 **0x21** (33)。

## 扫描码 (Scancode)

### 什么是扫描码？

扫描码是键盘硬件发送的原始按键编码，**不是 ASCII 码**！

```
按键 'A' 按下  →  扫描码 0x1E
按键 'A' 释放  →  扫描码 0x9E (0x1E | 0x80)
```

**规律**：释放扫描码 = 按下扫描码 | 0x80（最高位置1）

### 常用扫描码表

| 按键          | 按下扫描码 | 释放扫描码 |
|-------------|-------|-------|
| A           | 0x1E  | 0x9E  |
| Enter       | 0x1C  | 0x9C  |
| Backspace   | 0x0E  | 0x8E  |
| Left Shift  | 0x2A  | 0xAA  |
| Right Shift | 0x36  | 0xB6  |
| Ctrl        | 0x1D  | 0x9D  |
| Alt         | 0x38  | 0xB8  |
| CapsLock    | 0x3A  | 0xBA  |
| Tab         | 0x0F  | 0x8F  |
| F1          | 0x3B  | 0xBB  |
| F2          | 0x3C  | 0xBC  |
| F3          | 0x3D  | 0xBD  |

### 扫描码到 ASCII 的映射

代码中使用二维数组处理四种模式：

```c
static uint8_t scancode_map[KEY_MODES][KEY_COUNT] = {
    // mode 0: 无 Caps, 无 Shift
    {'\0', '\0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', '\0', '\0',
     'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']', '\0', '\0', 'a', 's',
     'd', 'f', 'g', 'h', 'j', 'k', 'l' , ';', '\'', '`', '\0', '\\', 'z', 'x', 'c', 'v',
     'b', 'n', 'm',',', '.', '/', '\0', '*', '\0', ' ', '\0'},

    // mode 1: 无 Caps, 有 Shift
    {'\0', '\0', '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', ...
     'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '{', '}', ...},

    // mode 2: 有 Caps, 无 Shift
    {... 'Q', 'W', 'E', 'R', 'T', 'Y', ... '1', '2', '3' ...},  // 字母大写，数字不变

    // mode 3: 有 Caps, 有 Shift
    {... 'q', 'w', 'e', 'r', 't', 'y', ... '!', '@', '#' ...}   // 字母小写，数字变符号
};
```

**四种模式的逻辑**：

| key_mode | Caps | Shift | 字母 | 数字键 |
|----------|------|-------|----|-----|
| 0        | OFF  | OFF   | 小写 | 数字  |
| 1        | OFF  | ON    | 大写 | 符号  |
| 2        | ON   | OFF   | 大写 | 数字  |
| 3        | ON   | ON    | 小写 | 符号  |

注意 mode 2 和 mode 3 的巧妙设计：**Caps + Shift = 抵消字母的大小写效果**！

## 键盘中断处理流程

### 整体流程图

```
键盘按下
    │
    ▼
IRQ1 中断触发
    │
    ▼
keyboard_interrupt_handler()
    │
    ├── cli()                    // 关中断
    │
    ├── inb(KB_DATA)             // 读取扫描码
    │
    ├── send_eoi(KEYBOARD_IRQ)   // 发送 EOI
    │
    ├── 扫描码处理
    │   │
    │   ├── 释放码？ ──────────> 更新状态 (Shift/Ctrl/Alt UP)
    │   │
    │   └── 按下码？ ──────────> process_char(scancode)
    │
    └── sti()                    // 开中断
```

### 代码详解

```c
void keyboard_interrupt_handler(){
    cli();                              // 1. 关中断，防止嵌套

    int scancode = 0;
    int c = inb(KB_DATA);               // 2. 从端口 0x60 读取扫描码
    send_eoi(KEYBOARD_IRQ);             // 3. 告诉 PIC 中断已处理

    if(c != 0) {
        scancode = c;

        // 4. 检查是否是有效扫描码（释放码 >= 0x80，超出 KEY_COUNT）
        if(scancode >= KEY_COUNT || scancode < 0) {
            // 处理释放码 (release code)
            if (scancode == LSHIFT_UP || scancode == RSHIFT_UP) {
                // 如果当前不在 Shift 状态，忽略（防止重复处理）
                if(key_mode == 2 || key_mode == 0) {
                    sti();
                    return;
                }
                // 更新 key_mode
                if(key_mode == 3) key_mode = 2;      // Caps ON, Shift OFF
                else key_mode = 0;                   // Caps OFF, Shift OFF
                sti();
                return;
            }
            if (scancode == CTRL_UP) {
                ctrl_pressed = UNPRESSED;
                sti();
                return;
            }
            if (scancode == ALT_UP) {
                alt_pressed = UNPRESSED;
                sti();
                return;
            }
            sti();
            return;
        }

        // 5. 处理按下码
        i = process_char(scancode);
    }

    sti();                              // 6. 开中断

    // 7. 处理特殊返回值
    if (i == 4) {
        halt(1);                        // Ctrl+C: 终止当前程序
    }
    else if(i != 0) {
        launch_term(i-1);               // Alt+F1/F2/F3: 切换终端
    }
}
```

## key_mode 状态机

### 状态定义

```c
static uint8_t key_mode = 0;    // 当前模式
static int cap_on = UNPRESSED;  // CapsLock 状态
static int ctrl_pressed = UNPRESSED;
static int alt_pressed = UNPRESSED;
```

### 状态转换图

```
    ┌───────┐    CapsLock     ┌───────┐
    │ mode 0│ ───────────────>│ mode 2│
    │无Caps │                 │有Caps │
    │无Shift│<─────────────── │无Shift│
    └───────┘    CapsLock     └───────┘
        │ ▲                       │ ▲
        │ │ Shift 释放            │ │ Shift 释放
        │ │                       │ │
 Shift  │ │                       │ │  Shift
  按下  ▼ │                       ▼ │   按下
    ┌───────┐    CapsLock     ┌───────┐
    │ mode 1│ ───────────────>│ mode 3│
    │无Caps │                 │有Caps │
    │有Shift│<─────────────── │有Shift│
    └───────┘    CapsLock     └───────┘
```

**状态转换表**：

| 当前状态   | 事件       | 新状态    |
|--------|----------|--------|
| mode 0 | Shift 按下 | mode 1 |
| mode 1 | Shift 释放 | mode 0 |
| mode 2 | Shift 按下 | mode 3 |
| mode 3 | Shift 释放 | mode 2 |
| mode 0 | CapsLock | mode 2 |
| mode 2 | CapsLock | mode 0 |
| mode 1 | CapsLock | mode 3 |
| mode 3 | CapsLock | mode 1 |

### CapsLock 处理

```c
case CAP:
    if(cap_on) {
        cap_on = UNPRESSED;
        // shift 未按下: mode 2 → mode 0
        // shift 已按下: mode 3 → mode 1
        if(key_mode == 2) key_mode = 0;
        else key_mode = 1;
    }
    else {
        cap_on = PRESSED;
        // shift 未按下: mode 0 → mode 2
        // shift 已按下: mode 1 → mode 3
        if(key_mode == 0) key_mode = 2;
        else key_mode = 3;
    }
    return 0;
```

**关键理解**：

- Shift 是**瞬时状态**（按住才有效）
- CapsLock 是**切换状态**（按一次切换，再按一次切回）

## 特殊按键处理

### 1. Backspace (退格)

```c
void handle_backspace(){
    // 检查边界
    if(current_location == 0) return;
    if(length_key == 0) return;

    // 特殊处理 Tab
    if(keyboard_buffer[length_key-1] == '\t') {
        current_location -= 8;  // Tab 占 4 个空格 × 2 字节
    }
    // 特殊处理换行
    else if(keyboard_buffer[length_key-1] == '\n') {
        // 复杂逻辑：找回上一行的光标位置
        if(length_key > 1 && keyboard_buffer[length_key-2] == '\n')
            current_location -= TERMINAL_WIDTH*2;
        else {
            // 回退到上一行最后一个字符
            while(video_pointer[current_location] != keyboard_buffer[length_key-2]) {
                current_location--;
            }
            current_location += 2;  // 移到空位
        }
    }
    // 普通字符
    else {
        current_location -= 2;
        video_pointer[current_location] = NULL_KEY;
        // 根据当前终端设置不同的颜色属性
        if(curr_term == 0)
            video_pointer[current_location+1] = ATTRIB_TERM1;
        else if(curr_term == 1)
            video_pointer[current_location+1] = ATTRIB_TERM2;
        else
            video_pointer[current_location+1] = ATTRIB_TERM3;
    }

    keyboard_buffer[length_key-1] = NULL_KEY;
    length_key--;
    update_cursor(current_location/2);
}
```

**多终端颜色**：每个终端有不同的颜色属性 (ATTRIB_TERM1/2/3)，退格时需要保持正确的颜色。

### 2. Tab (制表符)

```c
void handle_tab() {
    int tab_len = 4;  // Tab = 4 个空格

    if(length_key == KEYBOARD_BUFFER_SIZE) return;

    for(int i = 0; i < tab_len; i++) {
        if(current_location == TERMINAL_WIDTH * TERMINAL_HEIGHT)
            handle_scroll();
        video_pointer[current_location++] = ' ';       // 空格字符
        video_pointer[current_location++] = BLACK;     // 颜色属性
        if(current_location == TERMINAL_WIDTH * TERMINAL_HEIGHT * 2)
            handle_scroll();
        update_cursor(current_location/2);
    }
}
```

### 3. Enter (回车)

```c
void handle_enter() {
    if(length_key == KEYBOARD_BUFFER_SIZE) return;

    int cur_y = current_location / (TERMINAL_WIDTH * 2);

    // 最后一行需要滚屏
    if((cur_y + 1) == TERMINAL_HEIGHT) {
        handle_scroll();
    }
    else {
        // 移动到下一行开头
        current_location = (cur_y + 1) * TERMINAL_WIDTH * 2;
    }

    update_cursor(current_location/2);
    term[curr_term].has_enter = 1;  // 设置标志，唤醒 terminal_read
}
```

### 4. Ctrl+L (清屏) 和 Ctrl+C (终止)

```c
case LETTER_L:
    if(ctrl_pressed) {
        clear();                    // 清空显存
        current_location = 0;       // 光标回到开头
        ctrl_pressed = UNPRESSED;
        update_cursor(current_location/2);
        clear_keyboard_buffer();    // 清空键盘缓冲区
        return 0;
    }
    // 注意：没有 break，会 fall through！
case LETTER_C:
    if(ctrl_pressed) {
        ctrl_pressed = UNPRESSED;
        return 4;  // 返回特殊值，在 handler 中调用 halt(1)
    }
    // 注意：没有 break，会 fall through！
default:
    c = scancode_map[key_mode][scode];
    if(length_key == KEYBOARD_BUFFER_SIZE - 1)
        return 0;
    keyboard_buffer[length_key++] = c;
    break;
```

**重要：Fall-through 设计**

`LETTER_L` 和 `LETTER_C` 都**没有 `break`**！这是有意的设计：

- 如果按了 Ctrl+L，清屏后 `return 0`
- 如果只按了 'l'（没按 Ctrl），fall through 到 `default`，当作普通字母
- 同理，'c' 键如果没按 Ctrl，也会 fall through 当作普通字母

### 5. Alt+F1/F2/F3 (终端切换)

```c
case F1:
    if (alt_pressed == PRESSED) {
        return 1;  // 切换到终端 1
    }
    return 0;
case F2:
    if (alt_pressed == PRESSED) {
        return 2;  // 切换到终端 2
    }
    return 0;
case F3:
    if (alt_pressed == PRESSED) {
        return 3;  // 切换到终端 3
    }
    return 0;
```

## 键盘缓冲区

### 缓冲区结构

```c
char keyboard_buffer[KEYBOARD_BUFFER_SIZE] = {0};  // 128 字节
volatile unsigned int length_key = 0;               // 当前长度
```

### 为什么需要 volatile？

```c
volatile unsigned int length_key = 0;
```

`length_key` 会被中断处理程序修改，主程序也会读取它。没有 `volatile` 的话，编译器可能优化成只读一次缓存值：

```c
// 没有 volatile，编译器可能优化成：
int cached = length_key;
while(cached == 0) { }  // 死循环！

// 有 volatile，每次都从内存读取：
while(length_key == 0) { }  // 正确等待
```

### 缓冲区操作

```c
// 写入缓冲区（在 process_char 中）
keyboard_buffer[length_key++] = c;

// 清空缓冲区
void clear_keyboard_buffer() {
    cli();
    for(int i = 0; i <= length_key; i++) {
        keyboard_buffer[i] = NULL_KEY;
    }
    length_key = 0;
    sti();
}

// 等待输入（阻塞直到按下 Enter）
void read_buffer() {
    while(term[running_term].has_enter == 0) {}
    term[running_term].has_enter = 0;
}
```

## 屏幕滚动

### handle_scroll() 实现

```c
void handle_scroll() {
    // 将第 1~24 行上移到第 0~23 行
    for(int i = TERMINAL_WIDTH*2; i < TERMINAL_HEIGHT*TERMINAL_WIDTH*2; i += 2) {
        video_pointer[i - TERMINAL_WIDTH*2] = video_pointer[i];
    }

    // 清空最后一行
    for(int i = (TERMINAL_HEIGHT-1)*TERMINAL_WIDTH*2;
        i < TERMINAL_HEIGHT*TERMINAL_WIDTH*2; i += 2) {
        video_pointer[i] = NULL_KEY;
    }

    // 光标移到最后一行开头
    current_location = (TERMINAL_HEIGHT-1) * TERMINAL_WIDTH * 2;
}
```

### 显存布局复习

```
显存地址 0xB8000:
┌────────────────────────────────────────┐
│ 第0行: 字符0 属性0 字符1 属性1 ... (160字节) │
├────────────────────────────────────────┤
│ 第1行: ...                              │
├────────────────────────────────────────┤
│ ...                                    │
├────────────────────────────────────────┤
│ 第24行: 最后一行                         │
└────────────────────────────────────────┘

总大小: 80 × 25 × 2 = 4000 字节
```

## 多终端支持

### 每个终端独立的键盘缓冲区

```c
// 在 terminal.h 中
typedef struct term_info {
    char term_key_buf[KEYBOARD_BUFFER_SIZE];  // 键盘缓冲区备份
    int len_key_buf;                          // 缓冲区长度
    int has_enter;                            // 是否按下了 Enter
    // ... 其他字段
} term_info_t;

term_info_t term[3];  // 三个终端
```

### 终端切换时的缓冲区处理

```c
void clear_keyboard_backup(uint32_t term_id) {
    cli();
    for(int i = 0; i <= term[term_id].len_key_buf; i++) {
        term[term_id].term_key_buf[i] = NULL_KEY;
    }
    term[term_id].len_key_buf = 0;
    sti();
}
```

## 初始化

```c
void init_keyboard(){
    enable_irq(KEYBOARD_IRQ);  // 启用 IRQ1
    length_key = 0;            // 清空缓冲区
}
```

## 常见问题解答

### Q1: 为什么要先 send_eoi 再处理按键？

```c
int c = inb(KB_DATA);
send_eoi(KEYBOARD_IRQ);  // 为什么这么早发 EOI？
// ... 后续处理
```

**答案**：尽早发送 EOI 可以让 PIC 尽快接受下一个中断。如果在所有处理完成后才发 EOI，可能会丢失快速连续的按键。

### Q2: 为什么释放码 = 按下码 | 0x80？

这是 PS/2 键盘协议的规定。使用最高位区分按下和释放，既节省扫描码空间，又便于软件处理。

### Q3: 为什么 Tab 存为 '\t' 而不是 4 个空格？

存储 '\t' 只占用 1 字节，显示时扩展为 4 个空格。退格时只需检查上一个字符是否为 '\t'，就知道要删除 4 个显示位置。

### Q4: key_mode 为什么用数字 0-3 而不是位掩码？

```c
// 可以用位掩码：
#define SHIFT_MASK 0x01
#define CAPS_MASK  0x02
uint8_t key_mode = 0;
// mode = (cap_on << 1) | shift_on;

// 代码中直接用 0-3，因为：
// 1. 直接作为 scancode_map 的索引，无需计算
// 2. 状态转换逻辑简单，不需要位运算
```

## process_char 完整结构

```c
int process_char(int scode) {
    uint8_t c;
    switch(scode) {
        case BACKSPACE:     handle_backspace(); return 0;
        case TAB:           /* 处理 Tab */ return 0;
        case CAP:           /* 切换 CapsLock */ return 0;
        case LSHIFT_DOWN:
        case RSHIFT_DOWN:   /* 更新 key_mode */ return 0;
        case ALT_DOWN:      alt_pressed = PRESSED; return 0;
        case F1:            if(alt_pressed) return 1; return 0;
        case F2:            if(alt_pressed) return 2; return 0;
        case F3:            if(alt_pressed) return 3; return 0;
        case CTRL_DOWN:     ctrl_pressed = PRESSED; return 0;
        case ENTER:         /* 处理 Enter */ return 0;
        case LETTER_L:      if(ctrl_pressed) { /* 清屏 */ return 0; }
                            // fall through!
        case LETTER_C:      if(ctrl_pressed) return 4;
                            // fall through!
        default:
            c = scancode_map[key_mode][scode];
            if(length_key == KEYBOARD_BUFFER_SIZE - 1) return 0;
            keyboard_buffer[length_key++] = c;
            break;
    }

    // 显示字符并更新光标
    if(current_location < TERMINAL_WIDTH * TERMINAL_HEIGHT * 2) {
        putc(c);
        if(current_location == TERMINAL_WIDTH * TERMINAL_HEIGHT * 2)
            handle_scroll();
        update_cursor(current_location/2);
    } else {
        handle_scroll();
        putc(c);
        update_cursor(current_location/2);
    }
    return 0;
}
```

**返回值含义**：

| 返回值 | 含义             |
|-----|----------------|
| 0   | 正常处理完成         |
| 1   | Alt+F1，切换到终端 0 |
| 2   | Alt+F2，切换到终端 1 |
| 3   | Alt+F3，切换到终端 2 |
| 4   | Ctrl+C，终止当前程序  |

## 总结

键盘驱动的核心流程：

```
1. 初始化: enable_irq(1)
              │
              ▼
2. 中断触发: 用户按键 → IRQ1 → IDT[0x21] → handler
              │
              ▼
3. 读取扫描码: inb(0x60)
              │
              ▼
4. 发送 EOI: send_eoi(1)
              │
              ▼
5. 扫描码分类:
   ├── 释放码 (≥0x80): 更新 Shift/Ctrl/Alt 状态
   └── 按下码 (<0x80): process_char()
              │
              ▼
6. 字符处理:
   ├── 特殊键: Backspace/Tab/Enter/Ctrl+L/Ctrl+C/Alt+Fn
   └── 普通键: scancode_map[key_mode][scancode] → ASCII
              │
              ▼
7. 更新显示: putc(c), update_cursor()
              │
              ▼
8. 更新缓冲区: keyboard_buffer[length_key++] = c
```
