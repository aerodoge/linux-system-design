**# 多终端深度解析

## 概述

多终端是 Checkpoint 4 的核心功能，允许用户通过 Alt+F1/F2/F3 在三个独立的终端之间切换。每个终端有独立的：

- 显示内容（视频内存备份）
- 光标位置
- 键盘缓冲区
- 运行的进程

## 核心数据结构

### term_info 结构体

```c
// terminal.h
typedef struct {
    uint32_t term_id;           // 终端 ID (0, 1, 2)
    int32_t running_pid;        // 当前运行的进程 PID，-1 表示无进程
    uint32_t cursor_x;          // 光标 X 坐标
    uint32_t cursor_y;          // 光标 Y 坐标
    int cursor_location;        // 光标在视频内存中的位置
    uint8_t* vid_backup;        // 视频内存备份地址
    unsigned int len_key_buf;   // 键盘缓冲区长度
    int has_enter;              // 是否按下回车
    char term_key_buf[128];     // 键盘缓冲区备份
    char term_last_buf[128];    // 上一次命令备份
    uint16_t ss0;               // 内核栈段选择子
    uint32_t esp0;              // 内核栈指针
    uint32_t rtc_freq;          // RTC 频率
} term_info;

term_info term[NUM_TERM];  // 3 个终端的信息
```

### 关键全局变量

```c
uint32_t curr_term;     // 当前显示的终端 (用户看到的)
uint32_t running_term;  // 当前运行的终端 (CPU 正在执行的)
```

**curr_term vs running_term 的区别**：

| 变量             | 含义              | 更新时机       |
|----------------|-----------------|------------|
| `curr_term`    | 用户当前看到的终端       | Alt+Fx 切换时 |
| `running_term` | CPU 正在执行的进程所属终端 | 调度器切换时     |

这两个变量可以不同！例如：用户看着终端 0，但 CPU 正在后台执行终端 1 的进程。

## 视频内存管理

### 内存布局

```
0xB8000 (VIDEO)   ─────────────────────────
    │  当前显示的视频内存 (4KB)              │
    │  直接映射到显示器                      │
0xB9000 (VIDEOA)  ─────────────────────────
    │  终端 0 的视频备份 (4KB)               │
0xBA000 (VIDEOB)  ─────────────────────────
    │  终端 1 的视频备份 (4KB)               │
0xBB000 (VIDEOC)  ─────────────────────────
    │  终端 2 的视频备份 (4KB)               │
0xBC000           ─────────────────────────
```

### 视频内存切换原理

```
终端切换 (Alt+F2 从终端0切到终端1):

切换前:
┌─────────────────────────────────────────────────┐
│  0xB8000 (显示器)  │  显示终端0的内容              │
│  0xB9000 (备份A)   │  空/旧数据                   │
│  0xBA000 (备份B)   │  终端1的历史内容              │
└─────────────────────────────────────────────────┘

1. 保存终端0: memcpy(0xB9000, 0xB8000, 4KB)
2. 恢复终端1: memcpy(0xB8000, 0xBA000, 4KB)

切换后:
┌─────────────────────────────────────────────────┐
│  0xB8000 (显示器)  │  显示终端1的内容              │
│  0xB9000 (备份A)   │  终端0的历史内容              │
│  0xBA000 (备份B)   │  空/旧数据                   │
└─────────────────────────────────────────────────┘
```

### 后台终端的输出处理

当进程在后台终端运行时，输出不能直接写到 0xB8000（那样会干扰当前显示的终端）：

```c
int32_t terminal_write(int32_t fd, const void* buf, int32_t nbytes) {
    if (running_term == curr_term) {
        // 前台终端：直接写显存
        for (i = 0; i < nbytes; i++) {
            putc(buffer[i]);  // 写到 0xB8000
        }
    } else {
        // 后台终端：写到对应的备份区
        for (i = 0; i < nbytes; i++) {
            putc_term(buffer[i], running_term);  // 写到备份
        }
    }
    return i + 1;
}
```

**putc vs putc_term**：

| 函数                      | 写入位置           | 使用场景   |
|-------------------------|----------------|--------|
| `putc()`                | 0xB8000 (显示器)  | 前台终端输出 |
| `putc_term(c, term_id)` | 终端的 vid_backup | 后台终端输出 |

## 终端切换流程

### Alt+Fx 按键处理

```c
// keyboard.c 中的 process_char()
if (alt_pressed) {
    switch (scancode) {
        case F1_SCANCODE: launch_term(0); break;
        case F2_SCANCODE: launch_term(1); break;
        case F3_SCANCODE: launch_term(2); break;
    }
}
```

### launch_term() 函数

```c
int32_t launch_term(uint32_t term_id) {
    cli();

    // 1. 已经是当前终端，不需要切换
    if (term_id == curr_term) {
        sti();
        return 0;
    }

    // 2. 目标终端没有运行进程 - 需要启动新 shell
    if (term[term_id].running_pid == -1) {
        switch_terminal(curr_term, term_id);

        // 保存当前进程的 ESP/EBP
        pcb_t* old_pcb = get_specific_pcb(term[running_term].running_pid);
        asm volatile(
            "movl %%ebp, %%eax;"
            "movl %%esp, %%ebx;"
            : "=a"(old_pcb->curr_ebp), "=b"(old_pcb->curr_esp)
        );

        curr_term = term_id;
        sti();
        execute((uint8_t*)"shell");  // 启动新 shell
    }
    // 3. 目标终端有运行进程 - 只切换显示
    else {
        switch_terminal(curr_term, term_id);
        curr_term = term_id;

        // 重新映射 vidmap
        uint8_t* screen_start;
        vidmap(&screen_start);
        if (running_term != curr_term) {
            remap_vid((int32_t)screen_start,
                      (int32_t)term[running_term].vid_backup);
        }
        sti();
    }
    return 0;
}
```

### switch_terminal() 函数

```c
int32_t switch_terminal(uint32_t old_term, uint32_t new_term) {
    save_term_info(old_term);     // 保存旧终端状态
    restore_term_info(new_term);  // 恢复新终端状态
    return 0;
}
```

### 状态保存与恢复

```c
// 保存终端状态
int32_t save_term_info(uint32_t old_term) {
    // 保存光标位置
    term[old_term].cursor_x = screen_x;
    term[old_term].cursor_y = screen_y;
    term[old_term].cursor_location = current_location;

    // 保存键盘缓冲区
    term[old_term].len_key_buf = length_key;
    memcpy(term[old_term].term_key_buf, keyboard_buffer, 128);
    clear_keyboard_buffer();

    // 保存视频内存
    memcpy(term[old_term].vid_backup, (uint8_t*)VIDEO, SCREEN_SIZE);

    return 0;
}

// 恢复终端状态
int32_t restore_term_info(uint32_t new_term) {
    // 恢复光标位置
    screen_x = term[new_term].cursor_x;
    screen_y = term[new_term].cursor_y;
    current_location = term[new_term].cursor_location;
    update_cursor(current_location / 2);

    // 恢复键盘缓冲区
    length_key = term[new_term].len_key_buf;
    memcpy(keyboard_buffer, term[new_term].term_key_buf, 128);

    // 恢复视频内存
    memcpy((uint8_t*)VIDEO, term[new_term].vid_backup, SCREEN_SIZE);

    return 0;
}
```

## 终端切换流程图

```
用户按下 Alt+F2 (从终端0切到终端1)
           │
           ▼
┌─────────────────────────────────────────────┐
│  keyboard 中断处理                           │
│  检测到 Alt+F2，调用 launch_term(1)           │
└─────────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────────┐
│  launch_term(1)                             │
│  1. 检查 term_id != curr_term                │
│  2. 检查 term[1].running_pid                 │
└─────────────────────────────────────────────┘
           │
    ┌──────┴──────┐
    │             │
    ▼             ▼
running_pid==-1  running_pid>=0
(无进程)         (有进程)
    │             │
    ▼             ▼
┌─────────────┐  ┌─────────────┐
│ 保存当前进程  │  │ 只切换显示   │
│ ESP/EBP     │  │ switch_     │
│ switch_     │  │ terminal()  │
│ terminal()  │  │ 更新vidmap  │
│ execute     │  │             │
│ ("shell")   │  │             │
└─────────────┘  └─────────────┘
    │             │
    └──────┬──────┘
           ▼
   用户看到终端1的内容
```

## 终端初始化

### prep_term() - 预初始化

```c
void prep_term() {
    int i;
    for (i = 0; i < NUM_TERM; i++) {
        term[i].running_pid = -1;  // 标记所有终端无进程
    }
}
```

在 `kernel.c` 的启动早期调用，在任何终端操作之前。

### init_term() - 完整初始化

```c
int32_t init_term() {
    // 设置终端 ID
    term[0].term_id = 0;
    term[1].term_id = 1;
    term[2].term_id = 2;

    // 分配视频备份地址
    term[0].vid_backup = (uint8_t*)VIDEOA;  // 0xB9000
    term[1].vid_backup = (uint8_t*)VIDEOB;  // 0xBA000
    term[2].vid_backup = (uint8_t*)VIDEOC;  // 0xBB000

    // 初始化每个终端的状态
    for (i = 0; i < 3; i++) {
        term[i].cursor_location = 0;
        term[i].cursor_x = 0;
        term[i].cursor_y = 0;
        clear_backup(i);           // 清空视频备份
        term[i].len_key_buf = 0;
        clear_keyboard_backup(i);  // 清空键盘备份
        term[i].has_enter = 0;
        term[i].rtc_freq = MAX_RTC_FREQ;
    }

    // 启动第一个终端
    curr_term = 0;
    restore_term_info(0);
    return execute((uint8_t*)"shell");  // 启动第一个 shell
}
```

## 终端与进程的关系

### 进程-终端绑定

每个进程属于一个特定的终端：

```
终端 0 (curr_term=0)          终端 1           终端 2
┌─────────────────┐    ┌─────────────────┐   ┌─────────────────┐
│  shell (pid=0)  │    │  shell (pid=1)  │   │  shell (pid=2)  │
│       ↓         │    │       ↓         │   │                 │
│   cat (pid=3)   │    │   ls  (pid=4)   │   │   (未启动)       │
└─────────────────┘    └─────────────────┘   └─────────────────┘

term[0].running_pid = 3  (最近在终端0执行的进程)
term[1].running_pid = 4
term[2].running_pid = -1  (无进程)
```

### 进程与终端的交互

```c
// terminal_read 从当前终端的键盘缓冲区读取
int32_t terminal_read(int32_t fd, void* buf, int32_t nbytes) {
    read_buffer();  // 等待用户输入（阻塞）
    // 从 keyboard_buffer 复制到 buf
    ...
}
```

只有当 `running_term == curr_term` 时，键盘输入才会直接送给正在运行的进程。

## 多终端的挑战

### 1. 键盘输入隔离

问题：用户在终端 0 输入时，不应该影响终端 1 的进程。

解决：每个终端有独立的键盘缓冲区备份 `term_key_buf`，切换时保存/恢复。

### 2. 显示输出隔离

问题：后台进程的输出不应该干扰前台显示。

解决：后台进程写到 `vid_backup`，只有切换到该终端时才显示。

### 3. 光标位置独立

问题：每个终端的光标位置应该独立。

解决：`cursor_x`, `cursor_y`, `cursor_location` 在切换时保存/恢复。

## 总结

多终端的核心机制：

| 组件                  | 作用             |
|---------------------|----------------|
| `term_info` 结构体     | 存储每个终端的所有状态    |
| `vid_backup`        | 保存非活动终端的屏幕内容   |
| `term_key_buf`      | 保存非活动终端的键盘缓冲   |
| `curr_term`         | 记录用户正在看的终端     |
| `running_term`      | 记录 CPU 正在执行的终端 |
| `launch_term()`     | 处理 Alt+Fx 切换请求 |
| `switch_terminal()` | 执行实际的状态保存/恢复   |

关键设计思想：**显示和执行分离** - 用户看到的终端和CPU执行的进程可以属于不同终端，通过调度器协调。**
