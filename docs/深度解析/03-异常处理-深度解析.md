# 异常处理 深度解析

## 1. 异常处理的整体流程

当CPU检测到异常时，发生以下流程：

```
异常发生（如除零）
      │
      ▼
┌─────────────────────────────────────────────────────────────┐
│                    CPU 自动完成                              │
│  1. 如果特权级改变（用户→内核）：                               │
│     - 从TSS获取内核栈 (SS0:ESP0)                             │
│     - 压入用户态SS, ESP                                      │
│  2. 压入EFLAGS                                              │
│  3. 压入CS, EIP（返回地址）                                   │
│  4. 如果有错误码，压入错误码                                   │
│  5. 从IDT[n]获取处理函数地址，跳转执行                          │
└─────────────────────────────────────────────────────────────┘
      │
      ▼
┌─────────────────────────────────────────────────────────────┐
│              汇编包装函数 (interrupt_handler.S)               │
│  1. pushal-保存通用寄存器                                     │
│  2. pushfl-保存EFLAGS                                       │
│  3. pushl异常号                                             │
│  4. 调用C函数                                                │
│  5. popfl, popal - 恢复寄存器                                │
│  6. iret - 中断返回                                          │
└─────────────────────────────────────────────────────────────┘
      │
      ▼
┌─────────────────────────────────────────────────────────────┐
│               C 语言处理函数 (exception_handler.c)            │
│  1. 打印异常信息                                              │
│  2. 打印寄存器状态（调试用）                                    │
│  3. 停止系统 / 终止进程                                        │
└─────────────────────────────────────────────────────────────┘
```

---

## 2. 为什么需要汇编包装？

### 2.1 问题：CPU压栈格式不统一

不同异常压入的内容不同：

```
无错误码的异常（如除零 #DE）：     有错误码的异常（如页错误 #PF）：
┌─────────────┐                  ┌─────────────┐
│   EFLAGS    │                  │   EFLAGS    │
│     CS      │                  │     CS      │
│    EIP      │ ← ESP            │    EIP      │
└─────────────┘                  │ Error Code  │ ← ESP
                                 └─────────────┘
```

### 2.2 问题：C函数无法直接处理

1. **C函数不知道是哪个异常** - 需要传递异常号
2. **C函数需要寄存器状态** - 需要保存所有寄存器
3. **栈格式不统一** - 需要统一处理

### 2.3 解决方案：汇编包装

```
汇编包装函数的作用：
1. 对无错误码的异常，压入假错误码0（统一格式）
2. 压入异常号（让 C 函数知道是哪个异常）
3. 保存所有寄存器（构造寄存器上下文）
4. 调用C函数
5. 恢复寄存器
6. 执行iret返回
```

---

## 3. 栈的状态变化（关键）

### 3.1 异常发生前后的栈变化

以页错误（有错误码）为例，从用户态触发：

```
用户态执行前：                异常发生后（CPU自动）：

用户栈                       内核栈（从TSS获取）
┌─────────┐                  ┌─────────────┐
│  ...    │                  │  User SS    │ +20
│  ...    │                  │  User ESP   │ +16
└─────────┘                  │  EFLAGS     │ +12
                             │  User CS    │ +8
                             │  User EIP   │ +4
                             │ Error Code  │ ← ESP
                             └─────────────┘
```

### 3.2 汇编包装后的栈

```
执行 EXCEPTION_14 后：

┌──────────────────┐
│    User SS       │ +60  ─┐
│    User ESP      │ +56   │ CPU 自动压入
│    EFLAGS (CPU)  │ +52   │ (特权级改变时)
│    User CS       │ +48   │
│    User EIP      │ +44  ─┘
│   Error Code     │ +40  ← CPU 压入（有错误码的异常）
│   EFLAGS (pushfl)│ +36  ─┐
│      EDI         │ +32   │
│      ESI         │ +28   │
│      EBP         │ +24   │ pushal 压入
│      ESP         │ +20   │ (8个通用寄存器)
│      EBX         │ +16   │
│      EDX         │ +12   │
│      ECX         │ +8    │
│      EAX         │ +4   ─┘
│   异常号 (14)     │ ← ESP  我们压入
└──────────────────┘
```

---

## 4. interrupt_handler.S代码详解

### 4.1 数据段定义

```asm
.data
    exc0 = 0        # 异常号常量
    exc1 = 1
    exc2 = 2
    # ... 其他异常号 ...
    exc14 = 14
    # ...
    RTC = -41       # 中断使用负数，后面取反
    KB = -34
    PIT = -33
    SYSCALL = 0x80
```

**为什么中断用负数？**

后面的 `interrupt_handler` 会检查：

- 负数 → 硬件中断，取反得到实际值
- 0-19 → 异常
- 0x80 → 系统调用

### 4.2 异常入口函数

```asm
.text
.globl EXCEPTION_0, EXCEPTION_1, ..., EXCEPTION_19
.globl RTC_handler, KB_handler, PIT_handler, syscall

# 除零异常入口
EXCEPTION_0:
    pushal          # 保存 8 个通用寄存器
    pushfl          # 保存 EFLAGS
    pushl $exc0     # 压入异常号 0
    jmp interrupt_handler

# 调试异常入口
EXCEPTION_1:
    pushal
    pushfl
    pushl $exc1
    jmp interrupt_handler

# ... 其他异常类似 ...

# 页错误入口（有错误码）
EXCEPTION_14:
    pushal          # 注意：错误码已经被 CPU 压入
    pushfl
    pushl $exc14
    jmp interrupt_handler
```

**注意**：代码中没有区分有/无错误码的异常！这是一个简化处理。更完整的实现应该：

- 无错误码：先 `pushl $0` 再 `pushal`
- 有错误码：直接 `pushal`

### 4.3 公共中断处理程序

```asm
interrupt_handler:
    # 获取栈顶的异常/中断号
    popl %edi               # EDI = 异常号或负的中断号

    # 判断是中断还是异常
    cmpl $0, %edi
    jl interrupt            # 负数 → 硬件中断

    # 判断是否是系统调用
    cmpl $SYSCALL, %edi
    je syscall_jump_sub     # 0x80 → 系统调用

    # 是异常，关中断后处理
    cli
    jmp handle

interrupt:
    notl %edi               # 取反：-41 → 40, -34 → 33, -33 → 32

handle:
    # 调用跳转表中的 C 函数
    call *int_jumptable(,%edi,4)    # 调用 int_jumptable[edi]

    # 恢复并返回
    popfl                   # 恢复 EFLAGS
    popal                   # 恢复通用寄存器
    iret                    # 中断返回
```

### 4.4 跳转表

```asm
int_jumptable:
    .long exception_0       # 索引 0: 除零
    .long exception_1       # 索引 1: 调试
    .long exception_2       # 索引 2: NMI
    # ... 索引 3-13 ...
    .long exception_14      # 索引 14: 页错误
    .long exception_15      # 索引 15: 保留
    # ... 索引 16-19 ...
    .rept 12                # 索引 20-31: 重复 12 次
    .long exception_1       # 复用 exception_1
    .endr
    .long pit_interrupt_handler     # 索引 32: PIT
    .long keyboard_interrupt_handler # 索引 33: 键盘
    # ... 索引 34-39: 空 ...
    .long rtc_interrupt_handler     # 索引 40: RTC
```

**`.rept N ... .endr`**：汇编宏，重复 N 次

### 4.5 系统调用处理

```asm
syscall_jump_sub:
    # 检查系统调用号是否有效 (1-10)
    cmpl $1, %eax
    jl invalid_sysnum       # < 1 无效
    cmpl $10, %eax
    jg invalid_sysnum       # > 10 无效

    # 压入参数（ebx, ecx, edx）
    pushl %edx              # 参数 3
    pushl %ecx              # 参数 2
    pushl %ebx              # 参数 1

    # 调用系统调用跳转表
    call *syscall_jumptable(,%eax,4)

    # 保存返回值
    movl %eax, ret_val
    addl $12, %esp          # 清理 3 个参数
    jmp finish_syscall

invalid_sysnum:
    movl $-1, ret_val       # 无效调用返回 -1

finish_syscall:
    popfl
    popal
    movl ret_val, %eax      # 返回值放入 EAX
    iret

syscall_jumptable:
    .long 0                 # 索引 0: 未使用
    .long halt_func         # 索引 1: halt
    .long execute_func      # 索引 2: execute
    .long read_func         # 索引 3: read
    .long write_func        # 索引 4: write
    .long open_func         # 索引 5: open
    .long close_func        # 索引 6: close
    .long getargs_func      # 索引 7: getargs
    .long vidmap_func       # 索引 8: vidmap
    .long set_handler_func  # 索引 9: set_handler
    .long sigreturn_func    # 索引 10: sigreturn
```

---

## 5. exception_handler.c 代码详解

### 5.1 辅助函数

```c
// 系统挂起（无限循环）
void squash() {
    while (1);  // 永不返回
}

// 打印错误地址
void print_err_addr() {
    uint32_t eip;
    // 获取当前指令地址（不是异常地址！）
    asm volatile("1: lea 1b, %0;": "=a"(eip));
    printf("Error Address: %h\n", eip);
}
```

**注意**：`print_err_addr()` 的实现有问题！它打印的是自己的地址，不是异常发生的地址。正确做法是从栈上读取 CPU 压入的 EIP。

### 5.2 异常处理函数

```c
void exception_0() {
    printf("Divide Error Exception\n");
    print_err_addr();
    squash();
}

void exception_14() {
    printf("Page Fault Exception\n");
    print_err_addr();
    squash();
}

// ... 其他类似 ...
```

### 5.3 改进版本（更完整的实现）

如果要打印更多调试信息，应该这样改进：

```c
// 寄存器上下文结构（与汇编压栈顺序匹配）
typedef struct {
    // pushal 压入的（逆序）
    uint32_t edi, esi, ebp, esp_dummy;
    uint32_t ebx, edx, ecx, eax;
    // pushfl 压入的
    uint32_t eflags_saved;
    // 异常号
    uint32_t int_no;
    // CPU 压入的
    uint32_t err_code;  // 仅有错误码的异常
    uint32_t eip;
    uint32_t cs;
    uint32_t eflags;
    // 特权级改变时压入
    uint32_t esp;
    uint32_t ss;
} regs_t;

void exception_handler(regs_t* regs) {
    printf("=== Exception %d ===\n", regs->int_no);
    printf("EIP: 0x%x  CS: 0x%x\n", regs->eip, regs->cs);
    printf("Error Code: 0x%x\n", regs->err_code);

    // 页错误特殊处理
    if (regs->int_no == 14) {
        uint32_t cr2;
        asm volatile("mov %%cr2, %0" : "=r"(cr2));
        printf("Fault Address (CR2): 0x%x\n", cr2);
    }

    printf("EAX: 0x%x  EBX: 0x%x\n", regs->eax, regs->ebx);
    printf("ECX: 0x%x  EDX: 0x%x\n", regs->ecx, regs->edx);

    while(1);
}
```

---

## 6. pushal 和 popal 指令

### 6.1 pushal (Push All)

按以下顺序压入 8 个 32 位寄存器：

```
pushal 等价于：
    push eax
    push ecx
    push edx
    push ebx
    push esp    (压入的是执行 pushal 前的 ESP)
    push ebp
    push esi
    push edi
```

### 6.2 popal (Pop All)

按相反顺序弹出（ESP 的值被忽略）：

```
popal 等价于：
    pop edi
    pop esi
    pop ebp
    add esp, 4  (跳过保存的 ESP)
    pop ebx
    pop edx
    pop ecx
    pop eax
```

### 6.3 栈布局

```
执行 pushal 后：

┌─────────┐ 高地址
│  EAX    │ ESP + 28
│  ECX    │ ESP + 24
│  EDX    │ ESP + 20
│  EBX    │ ESP + 16
│  ESP'   │ ESP + 12 (执行前的 ESP)
│  EBP    │ ESP + 8
│  ESI    │ ESP + 4
│  EDI    │ ESP      ← 当前 ESP
└─────────┘ 低地址
```

---

## 7. iret 指令

### 7.1 iret (Interrupt Return)

从中断/异常返回，弹出 CPU 自动压入的内容：

```
iret 等价于：
    pop eip     ; 返回地址
    pop cs      ; 代码段
    pop eflags  ; 标志寄存器

    ; 如果特权级改变（返回用户态）
    pop esp     ; 用户栈指针
    pop ss      ; 用户栈段
```

### 7.2 与 ret 的区别

| 指令     | 弹出内容                       | 用途      |
|--------|----------------------------|---------|
| `ret`  | EIP                        | 普通函数返回  |
| `iret` | EIP, CS, EFLAGS, (ESP, SS) | 中断/异常返回 |

---

## 8. 有错误码 vs 无错误码

### 8.1 哪些异常有错误码？

| 异常号 | 名称                  | 错误码      |
|-----|---------------------|----------|
| 8   | Double Fault        | 有 (总是 0) |
| 10  | Invalid TSS         | 有        |
| 11  | Segment Not Present | 有        |
| 12  | Stack Segment Fault | 有        |
| 13  | General Protection  | 有        |
| 14  | Page Fault          | 有        |
| 17  | Alignment Check     | 有 (总是 0) |

### 8.2 错误码格式

**通用错误码（异常 10-13）**：

```
  31                16 15            3 2 1 0
 ┌────────────────────┬──────────────┬─┬─┬─┐
 │      Reserved      │ Segment Index│T│I│E│
 └────────────────────┴──────────────┴─┴─┴─┘
                                      │ │ │
                                      │ │ └── E: External (外部事件)
                                      │ └──── I: IDT (1=IDT, 0=GDT/LDT)
                                      └────── T: TI (1=LDT, 0=GDT)
```

**页错误错误码**：

```
  31                              5 4 3 2 1 0
 ┌─────────────────────────────────┬─┬─┬─┬─┬─┐
 │            Reserved             │I│R│U│W│P│
 └─────────────────────────────────┴─┴─┴─┴─┴─┘
                                    │ │ │ │ │
                                    │ │ │ │ └── P: 0=不存在, 1=保护违规
                                    │ │ │ └──── W: 0=读, 1=写
                                    │ │ └────── U: 0=内核, 1=用户
                                    │ └──────── R: 保留位错误
                                    └────────── I: 取指令
```

### 8.3 处理错误码的正确方式

完整的汇编实现应该区分：

```asm
# 无错误码的异常
.macro EXCEPTION_NO_ERR num
EXCEPTION_\num:
    pushl $0            # 压入假错误码，统一格式
    pushl $\num         # 压入异常号
    jmp common_handler
.endm

# 有错误码的异常
.macro EXCEPTION_WITH_ERR num
EXCEPTION_\num:
    # CPU 已经压入错误码
    pushl $\num         # 只压入异常号
    jmp common_handler
.endm

# 使用宏定义异常
EXCEPTION_NO_ERR 0      # 除零
EXCEPTION_NO_ERR 1      # 调试
# ...
EXCEPTION_WITH_ERR 8    # Double Fault
# ...
EXCEPTION_WITH_ERR 14   # Page Fault
# ...
```

---

## 9. CLI 和 STI 指令

### 9.1 CLI (Clear Interrupt Flag)

```asm
cli     ; EFLAGS.IF = 0，禁用可屏蔽中断
```

### 9.2 STI (Set Interrupt Flag)

```asm
sti     ; EFLAGS.IF = 1，启用可屏蔽中断
```

### 9.3 代码中的使用

```asm
interrupt_handler:
    popl %edi
    cmpl $0, %edi
    jl interrupt        # 中断不需要 CLI（中断门自动关）

    cmpl $SYSCALL, %edi
    je syscall_jump_sub

    cli                 # 异常处理前关中断
    jmp handle
```

**问题**：异常使用陷阱门，不会自动关中断，但代码这里手动 `cli` 了。这与 IDT 设置（陷阱门）矛盾，可能是为了简化。

---

## 10. 完整流程图

```
                          用户程序
                              │
                         int x = 1/0;
                              │
                              ▼
┌──────────────────────────────────────────────────────────────────────┐
│                           CPU 硬件                                    │
│  1. 检测到除零异常 (#DE)                                               │
│  2. 从 TSS 获取内核栈 SS0:ESP0                                         │
│  3. 压入: SS, ESP, EFLAGS, CS, EIP                                    │
│  4. 查 IDT[0]，获取 EXCEPTION_0 地址                                   │
│  5. 跳转到 EXCEPTION_0                                                │
└──────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌──────────────────────────────────────────────────────────────────────┐
│                    EXCEPTION_0 (汇编)                                │
│  pushal           ; 保存 EAX-EDI                                     │
│  pushfl           ; 保存 EFLAGS                                      │
│  pushl $0         ; 压入异常号                                        │
│  jmp interrupt_handler                                               │
└──────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌──────────────────────────────────────────────────────────────────────┐
│                  interrupt_handler (汇编)                             │
│  popl %edi        ; EDI = 异常号 (0)                                  │
│  cli              ; 关中断                                            │
│  call *int_jumptable(,%edi,4)  ; 调用 exception_0                     │
└──────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌──────────────────────────────────────────────────────────────────────┐
│                     exception_0 (C)                                  │
│  printf("Divide Error Exception\n");                                 │
│  print_err_addr();                                                   │
│  squash();         ; while(1);                                       │
└──────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
                        系统停止
```

---

## 11. 调试技巧

### 11.1 GDB 查看异常

```bash
# 在异常处理函数设断点
(gdb) break exception_14
(gdb) continue

# 查看栈
(gdb) info stack
(gdb) x/20x $esp

# 查看寄存器
(gdb) info registers

# 查看 CR2（页错误地址）
(gdb) print $cr2
```

### 11.2 触发测试异常

```c
// tests.c 中的测试

// 测试除零异常
void div_zero_test() {
    int x = 1 / 0;  // 触发 #DE
}

// 测试页错误
void page_fault_test() {
    int* ptr = (int*)0xDEADBEEF;  // 未映射地址
    int x = *ptr;  // 触发 #PF
}
```

### 11.3 常见问题

| 现象                | 可能原因                |
|-------------------|---------------------|
| Triple Fault (重启) | 异常处理程序本身出错          |
| 卡住不动              | squash() 的 while(1) |
| 乱码输出              | 视频内存未正确映射           |
| 栈溢出               | 中断嵌套太深              |

---

## 12. 总结

| 概念           | 要点                             |
|--------------|--------------------------------|
| **为什么要汇编包装** | 统一栈格式、保存寄存器、传递异常号              |
| **pushal**   | 保存 8 个通用寄存器                    |
| **iret**     | 中断返回，弹出 EIP/CS/EFLAGS/(ESP/SS) |
| **错误码**      | 异常 8/10/11/12/13/14/17 有错误码    |
| **跳转表**      | 根据异常号索引，调用对应 C 函数              |
| **CLI/STI**  | 关闭/开启可屏蔽中断                     |

---

## 13. 代码改进建议

当前实现的不足：

1. **未区分有/无错误码** - 应该统一压入假错误码
2. **print_err_addr() 不准确** - 应该从栈读取真实 EIP
3. **未打印完整寄存器** - 调试时信息不足
4. **页错误未读 CR2** - 不知道访问了什么地址

改进版见第 5.3 节的代码示例。

---

**文档版本**：1.0
**最后更新**：2025-12-07
**相关文件**：

- `student-distrib/interrupt_handler.S`
- `student-distrib/exception_handler.c`
- `student-distrib/exception_handler.h`
